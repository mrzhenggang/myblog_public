<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BEAST安装使用教程（Windows版）</title>
      <link href="//beast-install-windows/"/>
      <url>//beast-install-windows/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>BEAST 2是用于分子序列的贝叶斯系统发生分析的跨平台程序。它使用严格或宽松的分子时钟模型来估计有根的，经过时间测量的系统发育。</p><span id="more"></span><p>它可以用作重建系统发育的方法，但它也是测试进化假设的框架，而无需以单个树形拓扑为条件。BEAST 2使用马尔可夫链蒙特卡罗（MCMC）在树空间上求平均，因此每棵树的权重均与其后验概率成正比。BEAST 2包括用于设置标准分析的图形用户界面和用于分析结果的一套程序。</p><p>官网：<a href="http://www.beast2.org/">http://www.beast2.org/</a></p><h2 id="下载beast"><a href="#下载beast" class="headerlink" title="下载beast"></a>下载beast</h2><p>官网下载地址：<a href="http://www.beast2.org/">http://www.beast2.org/</a></p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/beast-install-windows/p1.png" style="zoom:75%;" /><blockquote><p>建议下载带java的版本，如果windows本地已有java环境，下载非java版本即可。</p></blockquote><h2 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h2><p>使用解压缩工具解压缩<code>BEAST_with_JRE.v2.6.2.Windows.zip</code>即可，比如我们解压到了D盘，目录为<code>D:\BEAST</code></p><h2 id="配置Java"><a href="#配置Java" class="headerlink" title="配置Java"></a>配置Java</h2><p>在windows下配置Java，就是设置系统环境变量即可，相关教程很多，下面还是赘述一下：</p><p>1.在开始菜单找到<code>编辑系统环境变量</code></p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/beast-install-windows/p2.png" style="zoom:75%;" /><p>2.选择<code>环境变量</code></p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/beast-install-windows/p3.png" style="zoom:75%;" /><p>3.在<code>系统变量</code>部分选择<code>新建</code></p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/beast-install-windows/p4.png" style="zoom:75%;" /><p>4.输入变量名和变量值，如下图：</p><ul><li>变量名：<code>Java_Home</code></li><li>变量值：<code>D:\BEAST\jre</code></li></ul><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/beast-install-windows/P5.png" style="zoom:75%;" /><p>5.修改<code>Path</code>环境变量，找到后选择<code>编辑</code></p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/beast-install-windows/p6.png" style="zoom:75%;" /><p>6.在编辑环境变量页面选择<code>新建</code></p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/beast-install-windows/p7.png" style="zoom:75%;" /><p>7.在输入位置写上Java的目录，然后点击<code>确定</code></p><ul><li>Java命令所在目录：<code>%Java_Home%\bin</code></li></ul><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/beast-install-windows/p8.png" style="zoom:75%;" /><p>8.我们在选择<code>新建</code>，这次添加名为<code>CLASSPATH</code>的变量</p><ul><li>变量名：<code>CLASSPATH</code></li><li>变量名：<code>.;%Java_Home%\bin;%Java_Home%\lib\dt.jar;%Java_Home%\lib\tools.jar</code></li></ul><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/beast-install-windows/p9.png" style="zoom:75%;" /><p>9.最后，我们点击<code>确定</code>即可。</p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/beast-install-windows/p10.png" style="zoom:75%;" /><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/beast-install-windows/p11.png" style="zoom:95%"/><h2 id="运行Beast"><a href="#运行Beast" class="headerlink" title="运行Beast"></a>运行Beast</h2><ol><li>按快捷键<code>Win+R</code>，输入<code>cmd</code>，进入命令行</li></ol><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/beast-install-windows/p12.png" style="zoom:75%;" /><ol start="2"><li>输入<code>d:</code>后回车，进入D盘</li><li>输入<code>cd BEAST</code>进入BEAST的解压目录</li><li>输入运行命令<code>java -jar %Java_Home%\..\lib\launcher.jar .\examples\testBSP.xml</code>，即可运行。</li></ol><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/beast-install-windows/p13.png" style="zoom:75%;" /><p>这里详细说明一下上图中<code>3</code>这一步的含义，</p><ul><li><code>java</code> 是运行java命令</li><li><code>-jar %Java_Home%\..\lib\launcher.jar</code> 是运行名为<code>launcher.jar</code>的模块，其中的<code>%Java_Home%</code>是刚才在系统环境中设置的环境变量，这里不需要更改，因为这个BEAST的压缩包的目录结构就是这样的</li><li><code>.\examples\testBSP.xml</code>是因为在BEAST文件夹下有一个examples文件夹，里面有一个testBSP.xml测试文件</li></ul><p>运行其他算例：</p><ol><li>打开cmd命令行</li><li>使用<code>cd</code>命令进入算例文件<code>input.xml</code>所在目录</li><li>运行java命令</li></ol><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar <span class="variable">%Java_Home%</span>\..\lib\launcher.jar .\input.xml</span><br></pre></td></tr></table></figure><p>程序运行后如下图：</p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/beast-install-windows/p14.png" style="zoom:75%;" /><blockquote><p>官方算例可以前往 <a href="https://www.beast2.org/tutorials/">https://www.beast2.org/tutorials/</a> 学习。</p></blockquote><h2 id="Linux版本"><a href="#Linux版本" class="headerlink" title="Linux版本"></a>Linux版本</h2><p>很久前写过Linux版本的使用方法，请参考：<a href="https://blog.mrzhenggang.com/beast-install/">BEAST安装使用教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 应用软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用软件 </tag>
            
            <tag> beast </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用linux64位系统登录天河VPN</title>
      <link href="//vpn-login-linux64/"/>
      <url>//vpn-login-linux64/</url>
      
        <content type="html"><![CDATA[<h2 id="安装运行-VPN-所需的-32-位库"><a href="#安装运行-VPN-所需的-32-位库" class="headerlink" title="安装运行 VPN 所需的 32 位库"></a>安装运行 VPN 所需的 32 位库</h2><h3 id="安装32位库的命令"><a href="#安装32位库的命令" class="headerlink" title="安装32位库的命令"></a>安装32位库的命令</h3><p>安装运行 VPN 所需的 32 位库，不同操作系统对应的命令有所不同，具体如下（需要切换为 root 权限）</p><h4 id="CentOS-7-和-Redhat-7"><a href="#CentOS-7-和-Redhat-7" class="headerlink" title="CentOS 7 和 Redhat 7"></a>CentOS 7 和 Redhat 7</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install glibc.i686</span><br><span class="line">yum install libstdc++-4.8.5-4.el7.i686</span><br></pre></td></tr></table></figure><h4 id="Fedora-22-workstation"><a href="#Fedora-22-workstation" class="headerlink" title="Fedora 22 workstation"></a>Fedora 22 workstation</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install glibc.i686</span><br><span class="line">yum install libstdc++-4.8.5-4.el7.i686</span><br><span class="line">yum install libstdc++.so.6</span><br></pre></td></tr></table></figure><h4 id="Ubuntu-16-和-Debian-8"><a href="#Ubuntu-16-和-Debian-8" class="headerlink" title="Ubuntu 16 和 Debian 8"></a>Ubuntu 16 和 Debian 8</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install lib32stdc++6</span><br></pre></td></tr></table></figure><h3 id="ubuntu16-04系统安装VPN所需的32位库"><a href="#ubuntu16-04系统安装VPN所需的32位库" class="headerlink" title="ubuntu16.04系统安装VPN所需的32位库"></a>ubuntu16.04系统安装VPN所需的32位库</h3><center><video src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vpn-login-linux64/install-lib.mp4" controls="controls" width="85%">您的浏览器不支持 video 标签。</video></center><h2 id="安装VPN脚本"><a href="#安装VPN脚本" class="headerlink" title="安装VPN脚本"></a>安装VPN脚本</h2><h3 id="安装VPN脚本命令"><a href="#安装VPN脚本命令" class="headerlink" title="安装VPN脚本命令"></a>安装VPN脚本命令</h3><p>用户联系天河的技术支持专员获取install_vpn_linux_x86.sh脚本，并自行拷贝到本地所使用的Linux系统中。然后执行如下安装命令即可（需要切换为 root 权限）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x install_vpn_linux_x86.sh</span><br><span class="line">./install_vpn_linux_x86.sh</span><br></pre></td></tr></table></figure><h3 id="ubuntu16-04系统安装VPN脚本"><a href="#ubuntu16-04系统安装VPN脚本" class="headerlink" title="ubuntu16.04系统安装VPN脚本"></a>ubuntu16.04系统安装VPN脚本</h3><center><video src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vpn-login-linux64/install-script.mp4" controls="controls"  width="85%">您的浏览器不支持 video 标签。</video></center><h2 id="登陆VPN"><a href="#登陆VPN" class="headerlink" title="登陆VPN"></a>登陆VPN</h2><h3 id="svpnc登陆VPN命令"><a href="#svpnc登陆VPN命令" class="headerlink" title="svpnc登陆VPN命令"></a>svpnc登陆VPN命令</h3><p>安装完成后，我们就可以使用 svpnc 命令进行VPN登陆相关操作了。（使用普通用户登陆即可）</p><p>（1）设置 vpn 地址 <code>svpnc -h thvpn.nscc-tj.cn:443</code></p><p>（2）设置用户名密码 <code>svpnc -u your_username:your_ssh_password</code> 或 <code>svpnc -U</code> 交互输入</p><p>（3）登陆 vpn <code>svpnc -i</code></p><p>（4）查询 vpn 运行状态 <code>svpnc -s</code></p><p>（5）注销 vpn <code>svpnc -o</code></p><p>（6）退出 vpn <code>svpnc -q</code></p><blockquote><p>备注：1.可以使用 svpnc -U 进行交互式配置用户名密码，先输入用户名，然后输入密码即可；2. 使用-q 退出 VPN 后下次登录需要再重新配置。</p></blockquote><h3 id="ubuntu16-04系统使用svpnc登陆VPN"><a href="#ubuntu16-04系统使用svpnc登陆VPN" class="headerlink" title="ubuntu16.04系统使用svpnc登陆VPN"></a>ubuntu16.04系统使用svpnc登陆VPN</h3><center><video src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vpn-login-linux64/svpnc-login.mp4" controls="controls"  width="85%">您的浏览器不支持 video 标签。</video></center><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vpn-login-linux64/vpn-login-linux64-p2.png" alt="如何使用linux64位系统登录天河VPN"></p>]]></content>
      
      
      <categories>
          
          <category> VPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vpn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何设置环境变量</title>
      <link href="//set-environment-variables/"/>
      <url>//set-environment-variables/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是环境变量？"><a href="#什么是环境变量？" class="headerlink" title="什么是环境变量？"></a>什么是环境变量？</h2><ul><li>变量是计算机系统用于保存可变值的数据类型，我们可以直接通过变量名称来提取到对应的变量值。</li><li>在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录（HOME）、可执行程序搜索路径（PATH）等。</li><li>值得一提的是，Linux 系统中环境变量的名称一般都是大写的，这是一种约定俗成的规范。</li></ul><h2 id="如何显示系统的环境变量？"><a href="#如何显示系统的环境变量？" class="headerlink" title="如何显示系统的环境变量？"></a>如何显示系统的环境变量？</h2><ul><li>我们可以使用 <code>env</code> 命令来查看到 Linux 系统中所有的环境变量</li></ul><center><video src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/set-environment-variables/env.mp4" controls="controls" width="85%">您的浏览器不支持 video 标签。</video></center><ul><li>我们可以使用 echo $变量名 来显示指定环境变量，例如<code>echo $PATH</code></li></ul><center><video src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/set-environment-variables/echo.mp4" controls="controls" width="85%">您的浏览器不支持 video 标签。</video></center><h2 id="常见系统环境变量有哪些？"><a href="#常见系统环境变量有哪些？" class="headerlink" title="常见系统环境变量有哪些？"></a>常见系统环境变量有哪些？</h2><table><thead><tr><th><strong>环境变量名称</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>PATH</td><td>定义命令行解释器搜索用户执行命令的路径</td></tr><tr><td>LD_LIBRARY_PATH</td><td>定义命令行解释器搜索用户执行命令所链接的动态库搜索路径</td></tr><tr><td>HOME</td><td>用户的主目录（也称家目录）</td></tr><tr><td>C_INCLUDE_PATH</td><td>编译程序使C语言头文件的搜索路径</td></tr><tr><td>CXX_INCLUDE_PATH</td><td>编译程序时C++语言头文件的搜索路径</td></tr></tbody></table><h2 id="如何修改系统环境变量？"><a href="#如何修改系统环境变量？" class="headerlink" title="如何修改系统环境变量？"></a>如何修改系统环境变量？</h2><h3 id="使用export命令设置环境变量"><a href="#使用export命令设置环境变量" class="headerlink" title="使用export命令设置环境变量"></a>使用export命令设置环境变量</h3><ul><li>在 shell 中执行程序时，shell 会提供一组环境变量。</li><li><code>export</code>命令 可新增，修改或删除环境变量，供后续执行的程序使用。</li></ul><h3 id="在shell终端设置环境变量"><a href="#在shell终端设置环境变量" class="headerlink" title="在shell终端设置环境变量"></a>在shell终端设置环境变量</h3><ul><li><p>直接在shell终端运行 export 命令设置变量，只对当前shell临时有效。打开新的shell需要重新设置。</p></li><li><p>在shell的命令行下使用export命令设置环境变量的方法为： <code>export 变量名=变量值</code></p></li><li><p>我们可以使用 <code>$</code> 符引用变量本身，进而实现环境变量内容的增加，例如：<code>export 变量名=$变量名:变量值</code></p></li><li><p>增加可执行程序搜索路径</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/path/to/newprogram/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><ul><li>增加动态链接库搜索路径</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/path/to/newprogram/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：请将<code>/path/to/newprogram/bin</code>部分替换为实际可执行程序所在路径，请将<code>/path/to/newprogram/lib</code>部分替换为动态链接库(.so文件)所在路径</p></blockquote><center><video src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/set-environment-variables/changeshell.mp4" controls="controls" width="85%">您的浏览器不支持 video 标签。</video></center><h3 id="在-bashrc文件中设置环境变量"><a href="#在-bashrc文件中设置环境变量" class="headerlink" title="在~/.bashrc文件中设置环境变量"></a>在~/.bashrc文件中设置环境变量</h3><ul><li><code>~/.bashrc</code>文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时，该该文件被读取。</li><li>修改该文件后，可以执行 <code>source ~/.bashrc</code>命令让修改即可生效。或者重新ssh连接到系统，刚才的修改会在用户登录时自动生效。</li></ul><center><video src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/set-environment-variables/changebashrc.mp4" controls="controls" width="85%">您的浏览器不支持 video 标签。</video></center><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>什么是环境变量？定义系统运行环境的一些参数</li><li>如何显示系统的环境变量？执行env显示全部，或执行echo $变量名</li><li>常见系统环境变量有哪些？最常见就是 PATH（可执行程序搜索路径）和LD_LIBRARY_PATH（动态链接库搜索路径）</li><li>如何修改系统环境变量？</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=新的路径:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=新的路径:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境变量 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何保持VPN永久在线和SSH连接活跃</title>
      <link href="//keep-alive/"/>
      <url>//keep-alive/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么会断线"><a href="#为什么会断线" class="headerlink" title="为什么会断线"></a>为什么会断线</h2><p>我们通过<code>EasyConnect</code>建立VPN链接，当长时间没有操作的时候，由于保护机制，VPN会自动下线。这与网页登录邮箱长时间不操作就提示重新登录的原理是一样的。</p><h2 id="如何保持VPN永久在线"><a href="#如何保持VPN永久在线" class="headerlink" title="如何保持VPN永久在线"></a>如何保持VPN永久在线</h2><p>鼠标右键单击任务栏的<code>EasyConnect</code>的图标，在弹出的页面中选择<code>系统设置</code>，然后勾选<code>永久在线</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/keep-alive/1.png" alt="EasyConnect永久在线"></p><p>这样就不会因为长时间不操作，由于保护机制而断开连接了。</p><span id="more"></span><h2 id="如何保持SSH连接活跃"><a href="#如何保持SSH连接活跃" class="headerlink" title="如何保持SSH连接活跃"></a>如何保持SSH连接活跃</h2><p>使用ssh连接远程服务器的时候，如果长时间没有操作，远程连接就有可能中断。正在执行的程序和vim等缓冲区数据都会丢失。</p><h3 id="windows系统"><a href="#windows系统" class="headerlink" title="windows系统"></a>windows系统</h3><ul><li>使用<code>MobaXterm</code>连接远程服务器，在<code>settings</code> -&gt; <code>Configuration</code> 的 <code>SSH</code> 选项卡中，勾选<code>SSH keepalive</code>。 </li><li>使用<code>SecureCRT</code>连接远程服务器，在<code>会话</code>选项 -&gt; <code>终端设置</code>中勾选<code>发送协议 NO-OP</code>。</li><li>使用<code>putty</code>连接远程服务器，找到<code>Connection</code> -&gt; <code>Seconds between keepalives ( 0 to turn off )</code>， 默认为<code>0</code>，改为<code>60</code>。</li><li>使用<code>xshell</code>连接远程服务器，找到当前连接，右击连接选择属性，在连接页面设置：勾选重新连接，设置间隔。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/keep-alive/2.png" alt="mobaxterm截图, 其他终端类似"></p><h3 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h3><p>在linux系统中使用ssh连接远程服务器时，可以使用 <code>-o</code> 的一个参数 <code>ServerAliveInterval</code> 来设置防止超时的时间。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -o serveraliveinterval=60 username@host</span><br></pre></td></tr></table></figure><h3 id="服务器配置修改"><a href="#服务器配置修改" class="headerlink" title="服务器配置修改"></a>服务器配置修改</h3><p>修改服务器端的 <code>ssh</code> 配置文件 <code>/etc/ssh/sshd_config</code> ，添加或者修改 <code>ClientAliveInterval</code> 为 <code>ClientAliveInterval 60</code> 。</p><p>这个参数的是意思是每1分钟，服务器向客户端发一个消息，用于保持连接。保存后记得重启<code>ssh</code>服务。</p><blockquote><p> 用户自己做不了，需要有管理员权限</p></blockquote><p>修改过后，上面几个办法都可以让<code>ssh</code>保持连接，一直处于<code>alive</code>状态，不会因为没有操作而被服务器强制断线了。</p>]]></content>
      
      
      <categories>
          
          <category> VPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VPN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站更新说明 2020年4月18日</title>
      <link href="//website-update-20200418/"/>
      <url>//website-update-20200418/</url>
      
        <content type="html"><![CDATA[<h2 id="网站更新说明"><a href="#网站更新说明" class="headerlink" title="网站更新说明"></a>网站更新说明</h2><p>本blog网站更新了，从<code>hexo-next</code>主题更新为<code>hexo-melody</code>主题，更新主要原因是之前我对<code>hexo-next</code>主题进行了源码修改，未知原因导致网站访问速度很慢，甚至部分用户反馈打不开。因此，本周末更新此网站，重新建站。</p><p>目前使用的环境为：</p><ul><li>域名和DNS：从 <a href="https://wanwang.aliyun.com/">阿里云万网</a> 购买com域名，使用阿里云管理控制台的云解析DNS进行DNS解析。需要实名认证。</li><li>代码托管：使用 (coding)[<a href="https://coding.net]">https://coding.net]</a> 建立代码仓库，并发布为静态网址</li><li>网站代码：使用<a href="https://hexo.io/">hexo</a>框架，使用 <a href="https://github.com/Molunerfinn/hexo-theme-melody">melody</a> 主题，主题配置方法为 <a href="https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/theme-config.html">theme-config</a></li><li>文章：使用Markdown语法编写，教程可以参考 <a href="https://www.runoob.com/markdown/md-tutorial.html">Markdown教程</a></li><li>CDN：使用 <a href="https://github.com/">github</a> 建立CDN仓库，使用 <a href="https://www.jsdelivr.com/">jsdelivr</a> 实现CDN支持</li></ul><p>对建站感兴趣的朋友，可以自己试试。</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nciplot安装说明</title>
      <link href="//nciplot-install/"/>
      <url>//nciplot-install/</url>
      
        <content type="html"><![CDATA[<h1 id="nciplot安装使用说明"><a href="#nciplot安装使用说明" class="headerlink" title="nciplot安装使用说明"></a>nciplot安装使用说明</h1><p>nciplot 3.0  2020.03.30 by zhenggang</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>web : <a href="https://www.lct.jussieu.fr/pagesperso/contrera/nciplot.html">https://www.lct.jussieu.fr/pagesperso/contrera/nciplot.html</a></p><p>src : <a href="https://www.lct.jussieu.fr/pagesperso/contrera/nciplot-3.0.tar.gz">https://www.lct.jussieu.fr/pagesperso/contrera/nciplot-3.0.tar.gz</a> 102MB</p><p>doc : <a href="https://www.lct.jussieu.fr/pagesperso/contrera/nciplot-manual.pdf">https://www.lct.jussieu.fr/pagesperso/contrera/nciplot-manual.pdf</a></p><span id="more"></span><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>通过阅读压缩包中的<code>README</code>文件，了解如何编译它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf nciplot-3.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> nciplot-3.0</span><br><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">sed -i <span class="string">&quot;s/FCFLAGS = -O2 -fopenmp/FCFLAGS = -O3 -fopenmp/&quot;</span> Makefile.inc</span><br><span class="line">make mrproper</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li> <code>Makefile.inc</code>文件用来指定编译器和编译参数是，默认是<code>gfortran</code>编译器。</li><li>上面的编译过程非常简单，我们仅仅把优化级别改为了<code>-O3</code>，其他不用改。</li><li>它还支持<code>ifort</code>编译器。</li></ul><h2 id="配置运行环境"><a href="#配置运行环境" class="headerlink" title="配置运行环境"></a>配置运行环境</h2><p>我们需要配置相关环境来保证软件运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NCIPLOT_HOME=/home/nciplot-3.0</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$NCIPLOT_HOME</span>/src:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> OMP_NUM_THREADS=4</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>NCIPLOT_HOME</code>是软件解压缩后的目录，该目录下需要包含名为<code>dat</code>的文件夹，软件运行需要。</li><li>设置<code>PATH</code>环境变量是为了方便直接调用<code>nciplot</code>命令。</li><li>设置<code>OMP_NUM_THREADS</code>是因为该软件支持多线程运行，该参数设置多线程数，这样可以加速。本实例中写为4，说明软件运行时会开启4个线程。</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我们进入test目录，运行算例看一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> test-cases/adenin-thymine</span><br><span class="line">nciplot AT.nci</span><br></pre></td></tr></table></figure><p>如果运行顺利，可以获得如下运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># ----------------- NCIPLOT ------------------------</span></span><br><span class="line"> <span class="comment"># --- PLOTTING NON COVALENT INTERACTION REGIONS ----</span></span><br><span class="line"> <span class="comment"># ---             E.R. Johnson                  ----</span></span><br><span class="line"> <span class="comment"># ---          J. Contreras-Garcia              ----</span></span><br><span class="line"> <span class="comment"># ----------    Duke University         ------------</span></span><br><span class="line"> <span class="comment"># --------------------------------------------------</span></span><br><span class="line"> <span class="comment"># ---              Please cite                  ----</span></span><br><span class="line"> <span class="comment"># --J. Am. Chem. Soc., 2010, 132 (18), pp 6498–6506-</span></span><br><span class="line"> <span class="comment"># --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment"># --------------------------------------------------</span></span><br><span class="line"> <span class="comment"># ---     Contributions for the wfn properties  ----</span></span><br><span class="line"> <span class="comment"># ---      from H. L. Schmider are acknowledged  ---</span></span><br><span class="line"> <span class="comment"># --------------------------------------------------</span></span><br><span class="line"> <span class="comment">#</span></span><br><span class="line"> <span class="comment"># Start -- 2020.03.30, 21:24:48.139</span></span><br><span class="line"></span><br><span class="line">+ Read density file : /home/nciplot-3.0/dat/h__lda.wfc</span><br><span class="line">  Log grid (r = a*e^(b*x)) with a =   2.4788E-03, b =   2.0000E-03</span><br><span class="line">  Num. grid points =  4392, rmax (bohr) =    16.1513</span><br><span class="line">  Integrated charge =           0.99999998</span><br><span class="line">  El. conf. :  1S(1)</span><br><span class="line"></span><br><span class="line">+ Read density file : /home/nciplot-3.0/dat/c__lda.wfc</span><br><span class="line">  Log grid (r = a*e^(b*x)) with a =   4.1313E-04, b =   2.0000E-03</span><br><span class="line">  Num. grid points =  5326, rmax (bohr) =    17.4308</span><br><span class="line">  Integrated charge =           5.99999996</span><br><span class="line">  El. conf. :  1S(2) 2S(2) 2P(2)</span><br><span class="line"></span><br><span class="line">+ Read density file : /home/nciplot-3.0/dat/n__lda.wfc</span><br><span class="line">  Log grid (r = a*e^(b*x)) with a =   3.5411E-04, b =   2.0000E-03</span><br><span class="line">  Num. grid points =  5343, rmax (bohr) =    15.4574</span><br><span class="line">  Integrated charge =           6.99999996</span><br><span class="line">  El. conf. :  1S(2) 2S(2) 2P(3)</span><br><span class="line"></span><br><span class="line">+ Read density file : /home/nciplot-3.0/dat/o__lda.wfc</span><br><span class="line">  Log grid (r = a*e^(b*x)) with a =   3.0984E-04, b =   2.0000E-03</span><br><span class="line">  Num. grid points =  5358, rmax (bohr) =    13.9372</span><br><span class="line">  Integrated charge =           7.99999996</span><br><span class="line">  El. conf. :  1S(2) 2S(2) 2P(4)</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line">      INPUT INFORMATION:</span><br><span class="line">-----------------------------------------------------</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line">      Calculation details:</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">RHO  THRESHOLD   (au): 0.10</span><br><span class="line">RDG  THRESHOLD   (au): 1.00</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line">      Operating grid and increments:</span><br><span class="line">-----------------------------------------------------</span><br><span class="line"> x0,y0,z0  = -12.2843  -3.5798  -7.4277</span><br><span class="line"> x1,y1,z1  =  14.3483   3.7251   6.8277</span><br><span class="line"> ix,iy,iz  =  0.10    0.10    0.10</span><br><span class="line"> nx,ny,nz  =  267      74     143</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line">      Writing output <span class="keyword">in</span> the following units:</span><br><span class="line">-----------------------------------------------------</span><br><span class="line"> Reduced Density Gradient,RDG  = AT-grad.cube</span><br><span class="line"> Sign(lambda2)xDensity,LS      = AT-dens.cube</span><br><span class="line"> ELF cube file                 = AT-elf.cube</span><br><span class="line"> XC energy density cube file   = AT-xc.cube</span><br><span class="line"> LS x RDG                      = AT.vmd</span><br><span class="line"> VMD script                    = AT.dat</span><br><span class="line">-----------------------------------------------------</span><br><span class="line"></span><br><span class="line">End -- 2020.03.30, 21:25:01.206</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 应用软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nciplot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设置编辑器语法高亮支持NCL</title>
      <link href="//editor-enhancements-for-use-with-NCL-scripts/"/>
      <url>//editor-enhancements-for-use-with-NCL-scripts/</url>
      
        <content type="html"><![CDATA[<h2 id="设置编辑器语法高亮支持NCL"><a href="#设置编辑器语法高亮支持NCL" class="headerlink" title="设置编辑器语法高亮支持NCL"></a>设置编辑器语法高亮支持NCL</h2><h2 id="官方说明"><a href="#官方说明" class="headerlink" title="官方说明"></a>官方说明</h2><p>Editor enhancements for use with NCL scripts</p><p><a href="http://www.ncl.ucar.edu/Applications/editor.shtml">http://www.ncl.ucar.edu/Applications/editor.shtml</a></p><p>英文好的朋友直接看就行了</p><p>支持如下编辑器：</p><ul><li><a href="http://www.ncl.ucar.edu/Applications/editor.shtml#Atom">Atom</a></li><li><a href="http://www.ncl.ucar.edu/Applications/editor.shtml#aquamacs">Aquamacs</a></li><li><a href="http://www.ncl.ucar.edu/Applications/editor.shtml#emacs">Emacs</a></li><li><a href="http://www.ncl.ucar.edu/Applications/editor.shtml#jed">JED</a></li><li><a href="http://www.ncl.ucar.edu/Applications/editor.shtml#gedit">gedit</a></li><li><a href="http://www.ncl.ucar.edu/Applications/editor.shtml#Kate">Kate</a></li><li><a href="http://www.ncl.ucar.edu/Applications/editor.shtml#nedit">NEdit</a></li><li><a href="http://www.ncl.ucar.edu/Applications/editor.shtml#netbeans">NetBeans</a></li><li><a href="http://www.ncl.ucar.edu/Applications/editor.shtml#Notepad++">Notepad++</a></li><li><a href="http://www.ncl.ucar.edu/Applications/editor.shtml#SublimeText">Sublime Text</a></li><li><a href="http://www.ncl.ucar.edu/Applications/editor.shtml#textmate">TextMate</a></li><li><a href="http://www.ncl.ucar.edu/Applications/editor.shtml#TextWrangler">TextWrangler</a></li><li><a href="http://www.ncl.ucar.edu/Applications/editor.shtml#vim">vi/vim</a></li></ul><span id="more"></span><h2 id="实践举例"><a href="#实践举例" class="headerlink" title="实践举例"></a>实践举例</h2><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>对于<code>vim</code>的支持也有好多版本，我们选择<code>https://github.com/xiexinyls/vim</code>，下载压缩包。<code>vim-master.zip</code>，配置步骤如下：</p><ol><li>下载压缩包 <a href="https://github.com/xiexinyls/vim.git">vim-master.zip</a></li><li>上传到系统用户根目录</li><li>解压缩：<code>unzip vim-master.zip</code></li><li>创建文件夹<code>mkdir ~/.vim</code>, </li><li>将刚刚解压缩的内容拷贝到文件夹中：<code>cp -rf  vim-master/* ~/.vim</code></li><li>配置 <code>~/.vimrc</code> 文件</li></ol><ul><li>如果之前不存在该文件，则直接执行拷贝命令即可：<code>cp ./vim-master/.vimrc ~/.vimrc</code></li><li>如果之前用户自己配置过该文件，则请把<code>./vim-master/.vimrc</code> 文件中的内容手动追加到<code>~/.vimrc</code>中。</li></ul><h3 id="gedit"><a href="#gedit" class="headerlink" title="gedit"></a>gedit</h3><p>过程类似<code>vim</code>的配置，不过更简单。下载对应的压缩包，解压缩，执行安装脚本即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf ncl_gedit_xml.tgz</span><br><span class="line">cd ncl_gedit_xml</span><br><span class="line"># Install for gedit 2.x</span><br><span class="line">./install.sh 2</span><br><span class="line"># Install for gedit 3.x</span><br><span class="line">./install.sh 3</span><br></pre></td></tr></table></figure><p>然后我们打开<code>gedit</code>，然后设置语法高亮为<code>NCAR Command Language</code>即可。</p><p>其他的请见官网网址吧，写的非常详细。</p>]]></content>
      
      
      <categories>
          
          <category> 工具软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NCL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用WRF</title>
      <link href="//how-to-use-wrf/"/>
      <url>//how-to-use-wrf/</url>
      
        <content type="html"><![CDATA[<h2 id="WRF简介"><a href="#WRF简介" class="headerlink" title="WRF简介"></a>WRF简介</h2><p>官方主页：<a href="https://www.mmm.ucar.edu/weather-research-and-forecasting-model">https://www.mmm.ucar.edu/weather-research-and-forecasting-model</a></p><p>WRF为美国国家大气研究中心(NCAR)联合其他机构共同开发的中尺度气象模式，可用于天气预报业务和大气科学领域相关科研。</p><p>WRF分为ARW(Advanced Research WRF) 和 NMM(Nonhydrostatic Mesoscale Model)两种。绝大多数气象领域的研究者使用的主要都是ARW版本。</p><ul><li>前处理：WPS （仅real case需要）</li><li>观测资料同化：WRFDA (Data Assimilation)</li><li>Nudging: OBSGRID</li><li>后处理：ARWpost等格式转换、插值及绘图软件</li><li>nco : 针对nc格式文件的处理套件，可方便地进行裁剪、做差、统计分析</li></ul><span id="more"></span><h2 id="调用系统已安装版本"><a href="#调用系统已安装版本" class="headerlink" title="调用系统已安装版本"></a>调用系统已安装版本</h2><p>可以通过 <code>module avail wrf</code> 来搜索系统已经安装的WRF版本，例如<code>3.8</code>,<code>3.9.1</code>,<code>4.0</code>,<code>4.1</code>等，可以直接加载使用。</p><p>系统已经配置了常用的地形数据库，目录为：<code>/THL6/software/WRFDATA/geog</code></p><p>其他文件系统的用户请自行寻找。</p><h2 id="使用方法举例"><a href="#使用方法举例" class="headerlink" title="使用方法举例"></a>使用方法举例</h2><p><strong>1.</strong> 创建测试文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/workdir/wrf/81km-test</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/workdir/wrf/81km-test</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 上传算例</p><p>利用ARSC(北极地区超级计算中心)及阿拉斯加大学开发的一套benchmark套件 <a href="http://weather.arsc.edu/BenchmarkSuite">http://weather.arsc.edu/BenchmarkSuite</a> 进行WRF相关的测试工作。该套件分为81km, 27km, 9km, 3km等不同分辨率，可适用于不同规模的计算测速。</p><p>将81Km.tar.gz的算例文件（28MB）上传到测试文件夹。</p><p><strong>3.</strong> 解压缩，设置相关环境</p><ul><li>解压缩、拷贝、修改名字</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp -r  /THL6/software/wrf/3.8-emreal-dmpar-icc16-mvapich2/run/ .</span><br><span class="line">tar zxvf 81km.tar.gz </span><br><span class="line">mv 81km/* run/</span><br><span class="line"><span class="built_in">cd</span> run/</span><br><span class="line">mv wrfrst_d01_2009-12-20_00-00-00 wrfrst_d01_2009-12-20_00:00:00 </span><br></pre></td></tr></table></figure><ul><li>加载系统环境</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># module</span></span><br><span class="line">module add Intel_compiler/16.0.3</span><br><span class="line">module add MPI/mvapich2-2.2/intel2016u3</span><br><span class="line">module add netcdf/4.4-icc16-mvapich2 </span><br><span class="line">module add wrf/3.8-emreal-dmpar-icc16-mvapich2</span><br></pre></td></tr></table></figure><p><strong>4.</strong> 测试算例</p><p>编写提交脚本文件<code>sub.sh</code>，写入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">yhrun -N 1 -n 28 -pTH_HPC1 wrf.exe</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>-N 节点数</li><li>-n 总核数</li><li>-p 计算分区名</li><li>wrf.exe 可执行程序名称</li></ol><p>备注：</p><ol><li>wrf的前处理过程可以写入脚本，或者在登陆节点执行。</li></ol><p><strong>5.</strong> 查看结果</p><p>查看结果文件即可，运行会生成wrfout输出文件，以及rsl.out.00xx和rsl.error.00xx等log文件，文件末尾数字对应核数，一个核生成一个文件。可查看rsl文件末尾是否有“SUCCESS COMPLETE WRF”提示。</p><h2 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h2><p>VIP技术支持： <a href="mailto:&#x7a;&#104;&#x65;&#110;&#103;&#x67;&#x61;&#x6e;&#x67;&#x40;&#110;&#x73;&#x63;&#99;&#x2d;&#x74;&#106;&#x2e;&#99;&#x6e;">&#x7a;&#104;&#x65;&#110;&#103;&#x67;&#x61;&#x6e;&#x67;&#x40;&#110;&#x73;&#x63;&#99;&#x2d;&#x74;&#106;&#x2e;&#99;&#x6e;</a></p>]]></content>
      
      
      <categories>
          
          <category> 应用软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何修改系统密码</title>
      <link href="//how-to-change-password/"/>
      <url>//how-to-change-password/</url>
      
        <content type="html"><![CDATA[<h2 id="用户密码管理"><a href="#用户密码管理" class="headerlink" title="用户密码管理"></a>用户密码管理</h2><ol><li>用户在使用天河系统的时候，需要使用SSH工具连接到系统的登陆节点，输入系统账号和登录密码。</li><li>登陆密码建议定期更换（系统每过一段时间会强制要求更换，快到期时登陆系统后会有英文提示）。</li><li>用户可以使用<code>password</code>密码修改密码。</li></ol><span id="more"></span><h2 id="如何修改密码"><a href="#如何修改密码" class="headerlink" title="如何修改密码"></a>如何修改密码</h2><h3 id="能够正常登陆，主动修改密码"><a href="#能够正常登陆，主动修改密码" class="headerlink" title="能够正常登陆，主动修改密码"></a>能够正常登陆，主动修改密码</h3><p>当出现用户密码快要过期的提示时，建议用户主动修改密码。修改密码的方法很简单，只需要以下几步：</p><ol><li>登陆系统</li><li>输入修改密码命令：<code>password</code></li><li>输入一次旧密码（注意：输入密码时，并没有显示已经输入的内容，这是一种保护机制，不是输不进去）</li><li>然后再输入两次新密码（注意：密码要求一定的安全强度，比如数字、字母、符号都要有，要满足一定的长度，不能和用户名太相似等等，如果输入后未通过，请阅读英文提示即可）</li><li>重新用新密码登录</li></ol><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[zhenggang@ln2 ~]$ passwd </span><br><span class="line">Changing password <span class="keyword">for</span> user zhenggang. </span><br><span class="line">Enter login(LDAP) password:    <span class="comment"># 注意：在输入原始账号密码或新密码时，系统都不会显示输入的字符</span></span><br><span class="line">New password:   </span><br><span class="line">Re-enter new password:   </span><br><span class="line">LDAP password information changed <span class="keyword">for</span> ncps </span><br><span class="line">passwd: all authentication tokens updated successfully. </span><br></pre></td></tr></table></figure><h3 id="已经过期无法登陆，强制修改密码"><a href="#已经过期无法登陆，强制修改密码" class="headerlink" title="已经过期无法登陆，强制修改密码"></a>已经过期无法登陆，强制修改密码</h3><p>如果用户长期<strong>无视</strong>密码快要过期的提示警告，那么一旦密码过期用户将无法正常登陆系统。这时也不用担心，用户可以依据提示，完成修改密码的步骤，即可重新登录系统。</p><ol><li>登陆系统</li><li>系统提示密码过期，请修改密码</li><li>输入一次旧密码（注意：输入密码时，并没有显示已经输入的内容，这是一种保护机制，不是输不进去）</li><li>然后再输入两次新密码</li><li>重新用新密码登录</li></ol><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Your password has expired.</span><br><span class="line">You must change your password now and login again!</span><br><span class="line">更改用户 zhenggang 的密码 。</span><br><span class="line">(current) LDAP Password:</span><br><span class="line">新的 密码：</span><br><span class="line">新的 密码：</span><br><span class="line">重新输入新的 密码：</span><br><span class="line">passwd：所有的身份验证令牌已经成功更新。</span><br></pre></td></tr></table></figure><p>注意：如果出现了乱码，或者显示异常等情况，很有可能是由于您使用的SSH登陆工具对 <strong>中文</strong> 支持不好，请尝试使用其他登陆工具。在这里我们推荐使用 <code>mobaxterm</code> 工具免费版。</p><p>关于该工具的详细介绍可以参考：<a href="https://blog.mrzhenggang.com/supercomputer-courses-ssh-sftp-mobaxterm/">超算入门课程2 ssh和sftp工具的使用之mobaxterm软件教学</a></p><h2 id="长期未使用用户锁定"><a href="#长期未使用用户锁定" class="headerlink" title="长期未使用用户锁定"></a>长期未使用用户锁定</h2><p>如果一个系统账号长期未登录，系统会将该账号<strong>锁定</strong>。用户登录时会提示<strong>账号已过期</strong>。</p><p>此时，只需要联系中心技术人员，让管理员协助修改即可。</p><h2 id="VPN登陆密码修改"><a href="#VPN登陆密码修改" class="headerlink" title="VPN登陆密码修改"></a>VPN登陆密码修改</h2><p>如需更换 VPN 账号密码，请告知中心技术人员，我们帮您更换。 普通用户无法自行修改。</p>]]></content>
      
      
      <categories>
          
          <category> 密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国家超级计算天津中心用户培训资料下载20191115</title>
      <link href="//user-conference-training-materials-20191115/"/>
      <url>//user-conference-training-materials-20191115/</url>
      
        <content type="html"><![CDATA[<p>大家好！非常感谢大家来参加本次的培训会，下面的资料是此次培训会的报告<code>pdf</code>，请大家下载学习，如有问题，欢迎来信交流。</p><blockquote><p>资料下载有效期 <strong>30</strong> 天，同时注意请不要用于商业用途。</p></blockquote><span id="more"></span><h2 id="1-在线阅读PDF"><a href="#1-在线阅读PDF" class="headerlink" title="1. 在线阅读PDF"></a>1. 在线阅读PDF</h2><ol><li><a href="/doc/%E5%9F%B9%E8%AE%AD1-%E4%B8%AD%E5%BF%83%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%A4%A9%E6%B2%B3%E7%B3%BB%E5%88%97%E8%B6%85%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BB%8B%E7%BB%8D-20191115-NSCCTJ-%E8%8F%85%E6%99%93%E4%B8%9C%E8%80%81%E5%B8%88.pdf">中心介绍及天河系列超级计算机介绍</a>  </li><li><a href="/doc/%E5%9F%B9%E8%AE%AD2-Linux%E4%BD%BF%E7%94%A8%E6%93%8D%E4%BD%9C%E5%85%A5%E9%97%A8%E5%9F%B9%E8%AE%AD-20191115-NSCCTJ-%E6%9D%8E%E9%9D%92%E5%B3%B0%E8%80%81%E5%B8%88.pdf">Linux使用操作入门培训</a></li><li><a href="/doc/%E5%9F%B9%E8%AE%AD3-%E5%A4%A9%E6%B2%B3%E7%B3%BB%E5%88%97%E8%B6%85%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E5%9F%B9%E8%AE%AD-20191115-NSCCTJ-%E9%83%91%E5%88%9A%E8%80%81%E5%B8%88.pdf">天河系列超级计算机入门使用培训</a></li><li><a href="/doc/%E5%9F%B9%E8%AE%AD4-HPC%E4%BA%91%E4%BD%BF%E7%94%A8%E6%93%8D%E4%BD%9C%E5%9F%B9%E8%AE%AD-20191115-NSCCTJ-%E9%83%91%E5%88%9A%E8%80%81%E5%B8%88.pdf">HPC云使用操作培训</a></li><li><a href="/doc/%E5%9F%B9%E8%AE%AD5-IO%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E8%AF%A6%E8%A7%A3-20191115-NSCCTJ-%E6%9D%8E%E4%BA%91%E9%BE%99%E8%80%81%E5%B8%88.pdf">IO优化案例详解</a></li><li><a href="/doc/%E5%9F%B9%E8%AE%AD6-MPI%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E5%9F%B9%E8%AE%AD-20191115-TJU-%E4%BA%8E%E7%AD%96%E8%80%81%E5%B8%88.pdf">MPI并行编程入门培训</a></li></ol><h2 id="2-一键下载压缩包"><a href="#2-一键下载压缩包" class="headerlink" title="2. 一键下载压缩包"></a>2. 一键下载压缩包</h2><ul><li><a href="/doc/%E5%9B%BD%E5%AE%B6%E8%B6%85%E7%BA%A7%E8%AE%A1%E7%AE%97%E5%A4%A9%E6%B4%A5%E4%B8%AD%E5%BF%83%E7%94%A8%E6%88%B7%E5%9F%B9%E8%AE%AD%E8%B5%84%E6%96%99%E4%B8%8B%E8%BD%BD20191115.zip">国家超级计算天津中心用户培训资料下载20191115.zip</a></li></ul><h2 id="3-免费试用"><a href="#3-免费试用" class="headerlink" title="3. 免费试用"></a>3. 免费试用</h2><p>您可以填写相关申请表发送给我们，详见网址首页导航栏。</p><p>联系方式：</p><ul><li>高性能计算部&ensp;（科研类用户）&ensp;郑刚&ensp;&ensp; <a href="mailto:&#122;&#x68;&#101;&#x6e;&#x67;&#x67;&#x61;&#x6e;&#103;&#x40;&#x6e;&#x73;&#99;&#99;&#x2d;&#x74;&#x6a;&#46;&#99;&#x6e;">&#122;&#x68;&#101;&#x6e;&#x67;&#x67;&#x61;&#x6e;&#103;&#x40;&#x6e;&#x73;&#99;&#99;&#x2d;&#x74;&#x6a;&#46;&#99;&#x6e;</a></li><li>企业服务部&ensp;&ensp;&ensp;（企业用户）&ensp;&ensp;&ensp;张婷&ensp;&ensp; <a href="mailto:&#122;&#104;&#x61;&#x6e;&#103;&#116;&#105;&#x6e;&#x67;&#x40;&#110;&#x73;&#99;&#99;&#45;&#116;&#x6a;&#x2e;&#x63;&#110;">&#122;&#104;&#x61;&#x6e;&#103;&#116;&#105;&#x6e;&#x67;&#x40;&#110;&#x73;&#99;&#99;&#45;&#116;&#x6a;&#x2e;&#x63;&#110;</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 培训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> slurm </tag>
            
            <tag> 培训 </tag>
            
            <tag> mpi </tag>
            
            <tag> linux </tag>
            
            <tag> hpc云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天河系统数据拷贝系统用户使用流程</title>
      <link href="//data-copy/"/>
      <url>//data-copy/</url>
      
        <content type="html"><![CDATA[<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li>用户通过快递方式将硬盘寄送给对接的支持专员</li><li>支持专员检查硬件安全后，将硬盘插入硬盘柜</li><li>系统管理将硬盘挂载到系统某数据拷贝节点，并返回一个挂载目录</li><li>支持专员将挂载目录提供给用户进行拷贝</li><li>用户拷贝完成后告知支持专员</li><li>支持专员联系系统管理员卸载硬盘，然后从硬盘柜取出硬盘寄回给用户</li></ol><span id="more"></span><h2 id="拷贝方法"><a href="#拷贝方法" class="headerlink" title="拷贝方法"></a>拷贝方法</h2><h3 id="登陆到数据拷贝节点"><a href="#登陆到数据拷贝节点" class="headerlink" title="登陆到数据拷贝节点"></a>登陆到数据拷贝节点</h3><p>用户登录到支持专员提供的数据拷贝节点，确认挂载路径可用。</p><ul><li><p>对于 <code>TH-1A</code> 系统，我们常用的登陆节点为 <code>ln3</code> (ip 为 192.168.2.5)。先登录 <code>ln3</code> 登陆节点，然后使用 <code>ssh ns1</code> 命令，跳转到数据拷贝节点 <code>ns1</code>。</p></li><li><p>对于 <code>TH-HPC1/TH-HPC2</code> 系统，我们常用的登陆节点为 <code>th-hpc1-ln0</code> (ip 为 192.168.2.101) 和  <code>th-hpc2-ln0</code> (ip 为 192.168.2.103)。先登录到对应的登陆节点，然后使用 <code>ssh ns3</code> 命令，跳转到数据拷贝节点 <code>ns3</code> 。</p></li></ul><blockquote><p>以下数据拷贝方法相同，以 <code>TH-1A</code> 系统为例。</p></blockquote><h3 id="检查拷贝路径"><a href="#检查拷贝路径" class="headerlink" title="检查拷贝路径"></a>检查拷贝路径</h3><p>用户执行 <code>df -h</code> 可看到挂载路径。该路径只有用户有权限读写，用户可以直接用 <code>cd</code> 命令进入该路径查看自己硬盘内的数据文件，然后用 <code>cp</code> 或 <code>rsync</code> 命令进行数据的拷贝。</p><p>如下，可以看到硬盘挂载路径为 <code>/mnt/zhenggang</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登陆ln3, 切换到数据拷贝节点</span></span><br><span class="line">[zhenggang@ln3%tianhe ~]$ ssh ns1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看挂载目录</span></span><br><span class="line">[zhenggang@ns1%tianhe ~]$ df -h</span><br><span class="line">Filesystem                      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda2                       487G  375G   88G  82% /</span><br><span class="line">tmpfs                            16G   72K   16G   1% /dev/shm</span><br><span class="line">mds0-gn0@tcp1:/HOME             430T  345T   64T  85% /vol-th</span><br><span class="line">mds1-gn0@tcp1:/WORK             419T  321T   78T  81% /WORK</span><br><span class="line">mds2-gn0@tcp1:/THFS             1.4P  1.2P  165T  88% /vol6</span><br><span class="line">mds3-gn0@tcp1:/THL4             688T  583T   71T  90% /THL4</span><br><span class="line">192.103.5.21:/TH_backup         1.3P  1.1P  170T  87% /TH_backup</span><br><span class="line">192.168.2.21:/mnt/zhenggang     2.0T  1.0T  1.0T  50% /mnt/zhenggang</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试进入硬盘挂载目录</span></span><br><span class="line">[zhenggang@ns1%tianhe ~]$ <span class="built_in">cd</span> /mnt/zhenggang</span><br><span class="line">[zhenggang@ns1%tianhe ~]$ ls</span><br></pre></td></tr></table></figure><p>我们可以看看这个盘是否正常挂载，以及能否快到硬盘的文件。</p><h3 id="进入用户共享存储目录"><a href="#进入用户共享存储目录" class="headerlink" title="进入用户共享存储目录"></a>进入用户共享存储目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zhenggang@ns1%tianhe ~]$ <span class="built_in">cd</span> ~</span><br></pre></td></tr></table></figure><p>因为如果我们使用下面介绍的 <code>rsync</code> 等命令并将log文件定向到硬盘，对硬盘压力比较高，所以建议从账号跟目录进行操作。</p><h3 id="拷贝方法1：使用cp命令进行拷贝（少量数据推荐）"><a href="#拷贝方法1：使用cp命令进行拷贝（少量数据推荐）" class="headerlink" title="拷贝方法1：使用cp命令进行拷贝（少量数据推荐）"></a>拷贝方法1：使用cp命令进行拷贝（少量数据推荐）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zhenggang@ns1%tianhe ~]$ cp  $源路径  $目标路径</span><br></pre></td></tr></table></figure><blockquote><p>该命令非常常用，不在赘述。</p></blockquote><h3 id="拷贝方法2：使用rsync命令进行拷贝（强烈推荐）"><a href="#拷贝方法2：使用rsync命令进行拷贝（强烈推荐）" class="headerlink" title="拷贝方法2：使用rsync命令进行拷贝（强烈推荐）"></a>拷贝方法2：使用rsync命令进行拷贝（强烈推荐）</h3><p><strong>同步命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zhenggang@ns1%tianhe ~]$ nohup  rsync  -avP  $源路径  $目标路径  &gt;<span class="built_in">log</span> 2&gt;log.err  &amp;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>nohup ... &amp;</code> : 提交到后台，这样能够提供可靠性，避免由于前端网页断开导致任务终止；</li><li><code>rsync -avp</code> : 同步命令+同步参数，无需更改</li><li><code>$源路径 $目标路径</code> ： 从哪里同步到哪里</li><li><code>&gt;log</code> ： 将标准输出定向到名为log的文件，方便查看进度</li><li><code>2&gt;log.err</code> : 将标准错误输出定向到名为log.err的文件，方便查看报错</li></ul><p>举例1：从我的根目录同步文件 <code>1.txt</code>到硬盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zhenggang@ns1%tianhe ~]$ nohup  rsync  -avP  ~/1.txt  /mnt/zhenggang/  &gt;<span class="built_in">log</span> 2&gt;log.err  &amp;</span><br></pre></td></tr></table></figure><p>举例2：从我的根目录同步文件夹 <code>data1</code> 到硬盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zhenggang@ns1%tianhe ~]$ nohup  rsync  -avP  ~/data1  /mnt/zhenggang/  &gt;<span class="built_in">log</span> 2&gt;log.err  &amp;</span><br></pre></td></tr></table></figure><p>举例3：从我的挂载硬盘同步文件 <code>2.txt</code> 到我的用户跟目录~/tmp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zhenggang@ns1%tianhe ~]$ nohup  rsync  -avP  /mnt/zhenggang/2.txt  ~/tmp/  &gt;<span class="built_in">log</span> 2&gt;log.err  &amp;</span><br></pre></td></tr></table></figure><p>举例4：从我的挂载硬盘同步文件夹 <code>data2</code> 到我的用户跟目录~/tmp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zhenggang@ns1%tianhe ~]$ nohup  rsync  -avP  /mnt/zhenggang/data2  ~/tmp/  &gt;<span class="built_in">log</span> 2&gt;log.err  &amp;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是：如果是文件夹同步，请注意”/“的使用，可以源目录最后不加”/“ 目标目录最后加”/“</p></blockquote><p><strong>同步进度</strong></p><p>通过查看 <code>log</code> 文件，可以看到数据拷贝的情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前进度</span></span><br><span class="line">[zhenggang@ns1%tianhe ~]$ tail -f <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p><strong>同步报错</strong></p><p>通过查看 <code>log.err</code> 文件，可以看到数据拷贝的报错（如无报错，此文件为空）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看报错</span></span><br><span class="line">[zhenggang@ns1%tianhe ~]$ tail -f log.err</span><br></pre></td></tr></table></figure><blockquote><p>如果log.err里有报错信息，熟悉linux的用户应该能自己处理，不熟悉的可以反馈给技术支持专员</p></blockquote><p><strong>取消同步</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 获得进程号</span></span><br><span class="line">[zhenggang@ns1%tianhe ~]$ ps aux | grep 自己用户名 | grep rsync </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. kill掉任务</span></span><br><span class="line">[zhenggang@ns1%tianhe ~]$ <span class="built_in">kill</span> -9 $进程号</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BEAST安装使用教程</title>
      <link href="//beast-install/"/>
      <url>//beast-install/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>BEAST 2是用于分子序列的贝叶斯系统发生分析的跨平台程序。它使用严格或宽松的分子时钟模型来估计有根的，经过时间测量的系统发育。</p><span id="more"></span><p>它可以用作重建系统发育的方法，但它也是测试进化假设的框架，而无需以单个树形拓扑为条件。BEAST 2使用马尔可夫链蒙特卡罗（MCMC）在树空间上求平均，因此每棵树的权重均与其后验概率成正比。BEAST 2包括用于设置标准分析的图形用户界面和用于分析结果的一套程序。</p><p>官网：<a href="http://www.beast2.org/">http://www.beast2.org/</a></p><h2 id="下载beast和相关包"><a href="#下载beast和相关包" class="headerlink" title="下载beast和相关包"></a>下载beast和相关包</h2><p>官网下载地址：</p><p><a href="https://github.com/CompEvol/CBAN">https://github.com/CompEvol/CBAN</a></p><p><a href="https://github.com/CompEvol/CBAN/blob/master/packages2.6.xml">https://github.com/CompEvol/CBAN/blob/master/packages2.6.xml</a></p><p>下载所有需要的包（依据个人情况下载）：</p><ul><li><p>BEAST_with_JRE2.v2.6.0.Linux.tgz</p><p>  <a href="https://www.beast2.org/download-linux-with-jre/">https://www.beast2.org/download-linux-with-jre/</a>  # 这个是带java的版本，就省得配置java了。</p></li><li><p>BEAST.package.v2.6.1.zip</p><p>  <a href="https://github.com/CompEvol/beast2/releases/download/v2.6.1/BEAST.package.v2.6.1.zip">https://github.com/CompEvol/beast2/releases/download/v2.6.1/BEAST.package.v2.6.1.zip</a></p></li><li><p>starbeast2 v0.15.5</p><p>  <a href="https://github.com/genomescale/starbeast2/releases/download/v0.15.5/StarBEAST2.zip">https://github.com/genomescale/starbeast2/releases/download/v0.15.5/StarBEAST2.zip</a></p></li><li><p>SA v2.0.2</p><p>  <a href="https://github.com/BEAST2-Dev/bdsky/releases/download/1.4.5/BDSKY.addon.v1.4.5.zip">https://github.com/BEAST2-Dev/bdsky/releases/download/1.4.5/BDSKY.addon.v1.4.5.zip</a></p></li><li><p>BEASTLabs v1.9.0</p><p>  <a href="https://github.com/BEAST2-Dev/BEASTLabs/releases/download/v1.9.0/BEASTlabs.addon.v1.9.0.zip">https://github.com/BEAST2-Dev/BEASTLabs/releases/download/v1.9.0/BEASTlabs.addon.v1.9.0.zip</a></p></li><li><p>MM v1.1.1</p><p>  <a href="https://github.com/CompEvol/morph-models/releases/download/untagged-74152ea8507b4e08d3ad/MM.addon.v1.1.1.zip">https://github.com/CompEvol/morph-models/releases/download/untagged-74152ea8507b4e08d3ad/MM.addon.v1.1.1.zip</a></p></li><li><p>BDSKY v1.4.5</p><p>  <a href="https://github.com/BEAST2-Dev/bdsky/releases/download/1.4.5/BDSKY.addon.v1.4.5.zip">https://github.com/BEAST2-Dev/bdsky/releases/download/1.4.5/BDSKY.addon.v1.4.5.zip</a></p></li></ul><h2 id="上传到服务器"><a href="#上传到服务器" class="headerlink" title="上传到服务器"></a>上传到服务器</h2><p>将所有包上传到服务器</p><h2 id="安装beast"><a href="#安装beast" class="headerlink" title="安装beast"></a>安装beast</h2><p>二进制包 <code>BEAST_with_JRE2.v2.6.0.Linux.tgz</code> 直接解压缩即可使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压缩</span></span><br><span class="line">tar zxvf BEAST_with_JRE2.v2.6.0.Linux.tgz</span><br><span class="line"><span class="comment"># 设置路径</span></span><br><span class="line">beast_root=/path/to/beast <span class="comment"># 请修改为实际的解压后的绝对路径!!!!</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$beast_root</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$beast_lib</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=<span class="variable">$beast_root</span>/jre1.8.0_212</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br></pre></td></tr></table></figure><h2 id="安装其他包"><a href="#安装其他包" class="headerlink" title="安装其他包"></a>安装其他包</h2><p>创建包安装的根目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ ! -d ~/.beast/2.6 ];<span class="keyword">then</span></span><br><span class="line">    mkdir -p ~/.beast/2.6</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>然后将各个需要的包解压缩到这个目录即可安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unzip BEAST.package.v2.6.1.zip -d ~/.beast/2.6/BEAST  <span class="comment"># 2.6.0 -&gt; 2.6.1</span></span><br><span class="line"></span><br><span class="line">unzip StarBEAST2.zip -d ~/.beast/2.6/StarBEAST2</span><br><span class="line">unzip SA.v2.0.2.zip -d ~/.beast/2.6/SA</span><br><span class="line">unzip BEASTlabs.addon.v1.9.0.zip -d ~/.beast/2.6/BEASTlabs</span><br><span class="line">unzip MM.addon.v1.1.1.zip -d ~/.beast/2.6/MM</span><br><span class="line"></span><br><span class="line">mkdir BDSKY</span><br><span class="line">unzip BDSKY.addon.v1.4.5.zip -d BDSKY   <span class="comment"># 官网下载的这个包目录层级不对，所以自己改一下</span></span><br><span class="line">mv BDSKY ~/.beast/2.6</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>直接运行 <code>beast</code> 命令，看是否可以成功启动。成功启动如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[zhenggang@ln2%tianhe beast]$ beast</span><br><span class="line"></span><br><span class="line">                        BEAST v2.6.1, 2002-2019</span><br><span class="line">             Bayesian Evolutionary Analysis Sampling Trees</span><br><span class="line">                       Designed and developed by</span><br><span class="line"> Remco Bouckaert, Alexei J. Drummond, Andrew Rambaut &amp; Marc A. Suchard</span><br><span class="line"></span><br><span class="line">                   Centre <span class="keyword">for</span> Computational Evolution</span><br><span class="line">                         University of Auckland</span><br><span class="line">                       r.bouckaert@auckland.ac.nz</span><br><span class="line">                        alexei@cs.auckland.ac.nz</span><br><span class="line"></span><br><span class="line">                   Institute of Evolutionary Biology</span><br><span class="line">                        University of Edinburgh</span><br><span class="line">                           a.rambaut@ed.ac.uk</span><br><span class="line"></span><br><span class="line">                    David Geffen School of Medicine</span><br><span class="line">                 University of California, Los Angeles</span><br><span class="line">                           msuchard@ucla.edu</span><br><span class="line"></span><br><span class="line">                      Downloads, Help &amp; Resources:</span><br><span class="line">                           http://beast2.org/</span><br><span class="line"></span><br><span class="line">  Source code distributed under the GNU Lesser General Public License:</span><br><span class="line">                   http://github.com/CompEvol/beast2</span><br><span class="line"></span><br><span class="line">                           BEAST developers:</span><br><span class="line">   Alex Alekseyenko, Trevor Bedford, Erik Bloomquist, Joseph Heled,</span><br><span class="line"> Sebastian Hoehna, Denise Kuehnert, Philippe Lemey, Wai Lok Sibon Li,</span><br><span class="line">Gerton Lunter, Sidney Markowitz, Vladimir Minin, Michael Defoin Platel,</span><br><span class="line">          Oliver Pybus, Tim Vaughan, Chieh-Hsi Wu, Walter Xie</span><br><span class="line"></span><br><span class="line">                               Thanks to:</span><br><span class="line">          Roald Forsberg, Beth Shapiro and Korbinian Strimmer</span><br></pre></td></tr></table></figure><p>我们编写一个简单的 <code>1.xml</code> 输入文件，运行 <code>beast 1.xml</code>，观察是否能够正常运行，例如（部分输出）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">                        BEAST v2.6.1, 2002-2019</span><br><span class="line">             Bayesian Evolutionary Analysis Sampling Trees</span><br><span class="line">                       Designed and developed by</span><br><span class="line"> Remco Bouckaert, Alexei J. Drummond, Andrew Rambaut &amp; Marc A. Suchard</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">                               Thanks to:</span><br><span class="line">          Roald Forsberg, Beth Shapiro and Korbinian Strimmer</span><br><span class="line"></span><br><span class="line">Random number seed: 1572754201802</span><br><span class="line"></span><br><span class="line">File: 1_s_f.xml seed: 1572754201802 threads: 1</span><br><span class="line">Loading package BEAST v2.6.1</span><br><span class="line">Loading package starbeast2 v0.15.5</span><br><span class="line">Loading package SA v2.0.2</span><br><span class="line">Loading package BEASTLabs v1.9.0</span><br><span class="line">Loading package MM v1.1.1</span><br><span class="line">Loading package BDSKY v1.4.5</span><br><span class="line">Loading package BEAST v2.6.1</span><br><span class="line">t82_0: 5000 4</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Start likelihood: -10843.63302484645</span><br><span class="line">Writing file 1_s_f.log</span><br><span class="line">Writing file 1_s_f.trees</span><br><span class="line">         Sample      posterior     likelihood          prior</span><br><span class="line">              0    -10843.6330    -10768.6374       -74.9955 --</span><br><span class="line">           1000     -9928.8676     -9865.9374       -62.9302 --</span><br><span class="line">           2000     -9929.6049     -9862.7149       -66.8900 --</span><br></pre></td></tr></table></figure><blockquote><p>官方算例可以前往 <a href="https://www.beast2.org/tutorials/">https://www.beast2.org/tutorials/</a> 学习。</p></blockquote><h2 id="以后用"><a href="#以后用" class="headerlink" title="以后用"></a>以后用</h2><p>可以将如下代码写在 <code>~/.bashrc</code> 文件中，下回登陆即可自动加载 <code>beast</code> 了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beast_root=/path/to/beast <span class="comment"># 请修改为beast的安装路径!!!!</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$beast_root</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$beast_lib</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=<span class="variable">$beast_root</span>/jre1.8.0_212</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 应用软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用软件 </tag>
            
            <tag> beast </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Collectl在TH-ES上的使用</title>
      <link href="//collectl-on-th-es/"/>
      <url>//collectl-on-th-es/</url>
      
        <content type="html"><![CDATA[<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module add collectl</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="拷贝脚本"><a href="#拷贝脚本" class="headerlink" title="拷贝脚本"></a>拷贝脚本</h3><p>进入脚本目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$COLLECTL_HOME</span>/scripts</span><br></pre></td></tr></table></figure><p>拷贝需要的脚本到算例的目录，例如我们使用template目录下的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="variable">$COLLECTL_HOME</span>/scripts/template/* .</span><br><span class="line">chmod +x collectl-*</span><br></pre></td></tr></table></figure><h3 id="修改相关参数"><a href="#修改相关参数" class="headerlink" title="修改相关参数"></a>修改相关参数</h3><p>依据不同任务，修改<code>collectl-run.sh</code>脚本参数，包括：</p><ul><li>partition 计算分区，可用<code>yhi</code>查看可用分区。（通常为TH_ES，无需修改）</li><li>nodes 运行节点数</li><li>cpuspernode 每个节点运行的核数（不要超过28核）</li><li>OMP_NUM_THREADS 设置线程数（通常mpi任务设置为1即可）</li><li>exe 运行命令及相关参数，例如<code>a.out &lt; input.txt &gt; out.log</code>。（写的是实际运行的命令，而不是提交脚本或类似 <code>yhrun -N 1 -n 28 a.out &lt; input.txt &gt; out.log</code>)</li></ul><blockquote><p>这一步是主要工作，不同任务的运行主要就是修改运行的软件和命令。软件自身运行需要的环境变量，请提前自行加载好。</p></blockquote><h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><p>直接执行该脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./collectl-run.sh</span><br></pre></td></tr></table></figure><p>会获得<code>jobid</code>号，例如：14570273。</p><p>使用 <code>yhq</code> 查看任务状态， <code>PD</code> 为等待， <code>R</code> 为运行， 如果任务消失则表示结束。</p><h2 id="分析数据"><a href="#分析数据" class="headerlink" title="分析数据"></a>分析数据</h2><p>等待任务结束后，分析数据，运行脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./collectl-analysis.sh nodesfile-14570273</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>nodesfile-14570273</code> 为运行得到的节点编号文件，请依据实际 <code>jobid</code> 进行修改。</li></ul><p>分析结果类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">==============================================================</span><br><span class="line">This is collectl script --- analysis calculate node messages.</span><br><span class="line">==============================================================</span><br><span class="line">Job Start Time       = 2019-10-23 12:06:43</span><br><span class="line">JOb ID               = 14570273</span><br><span class="line">Computing partition  = TH_ES</span><br><span class="line">Number of nodes      = 2</span><br><span class="line">Number of processes  = 56</span><br><span class="line">Tasks Per Node       = 28(x2)</span><br><span class="line">SLURM_NODELIST       = cn[21-22]</span><br><span class="line">Submit Directory     = /THL5/home/zhenggang/workdir/colleclt/lmp</span><br><span class="line">Report File          = report.txt</span><br><span class="line">--------------------------------------------</span><br><span class="line">Analyzing nodesfile-1864420 cn21</span><br><span class="line">         Operation          Max        Min       Mean</span><br><span class="line">         CPU USAGE(%)    100.00       0.00     100.00</span><br><span class="line">          MEMORY(MB)    6663.00    6663.00    6663.00</span><br><span class="line">     NetworkIn(KB/s)       0.00       0.00       0.00</span><br><span class="line">  NetworkIn(count/s)       0.00       0.00       0.00</span><br><span class="line">    NetworkOut(KB/s)       0.00       0.00       0.00</span><br><span class="line"> NetworkOut(count/s)       0.00       0.00       0.00</span><br><span class="line">        IORead(KB/s)     320.00       0.00       7.50</span><br><span class="line">     IORead(count/s)      65.00       8.00      14.29</span><br><span class="line">       IOWrite(KB/s)      32.00       0.00       2.73</span><br><span class="line">    IOWrite(count/s)      59.00       0.00       2.00</span><br><span class="line">--------------------------------------------</span><br><span class="line">Analyzing nodesfile-1864420 cn22</span><br><span class="line">         Operation          Max        Min       Mean</span><br><span class="line">         CPU USAGE(%)    100.00       0.00     100.00</span><br><span class="line">          MEMORY(MB)    6663.00    6663.00    6663.00</span><br><span class="line">     NetworkIn(KB/s)       0.00       0.00       0.00</span><br><span class="line">  NetworkIn(count/s)       0.00       0.00       0.00</span><br><span class="line">    NetworkOut(KB/s)       0.00       0.00       0.00</span><br><span class="line"> NetworkOut(count/s)       0.00       0.00       0.00</span><br><span class="line">        IORead(KB/s)     320.00       0.00       7.37</span><br><span class="line">     IORead(count/s)      65.00       8.00      14.24</span><br><span class="line">       IOWrite(KB/s)      32.00       0.00       2.67</span><br><span class="line">    IOWrite(count/s)      59.00       0.00       1.96</span><br><span class="line">--------------------------------------------</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li><code>CPU USAGE(%)</code> 为CPU 使用率</li><li><code>MEMORY(MB)</code> 为内存使用量</li><li><code>Network</code> 为网络通信数据, <code>KB/s</code> 每秒通信量, <code>count/s</code> 每秒通信次数</li><li><code>IORead</code>, <code>IOWrite</code> 为IO读写情况</li><li>程序会生成<code>png</code>图片用于分析</li></ol><h2 id="视频教学"><a href="#视频教学" class="headerlink" title="视频教学"></a>视频教学</h2><blockquote><p>TH-1A系统版本, TH_ES系统类似</p></blockquote><center><video src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/collectl/collectl-th1a.mp4" controls="controls" height="400" weight="700" >您的浏览器不支持 video 标签。</video></center>]]></content>
      
      
      <categories>
          
          <category> 性能分析工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> collectl </tag>
            
            <tag> 性能分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言包的安装教程</title>
      <link href="//R-package-install/"/>
      <url>//R-package-install/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>R语言包在线安装比较简单，离线安装相对麻烦，尤其是解决依赖问题，本文介绍在线和离线安装R语言包的方法。</p><span id="more"></span><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><h3 id="Linux系统R语言包在线安装"><a href="#Linux系统R语言包在线安装" class="headerlink" title="Linux系统R语言包在线安装"></a>Linux系统R语言包在线安装</h3><p>在<code>Shell</code>命令行终端输入<code>R</code>, 打开R的控制台, 输入:</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 gridExtra</span></span><br><span class="line">install.packages(<span class="string">&quot;gridExtra&quot;</span>, dependencies = <span class="literal">TRUE</span>) </span><br></pre></td></tr></table></figure><p>这样就可以在可以联网的环境下直接安装了。</p><h3 id="Linux系统单个R语言包离线安装"><a href="#Linux系统单个R语言包离线安装" class="headerlink" title="Linux系统单个R语言包离线安装"></a>Linux系统单个R语言包离线安装</h3><p>前往 <a href="https://cran.r-project.org/web/packages/available_packages_by_name.html">https://cran.r-project.org/web/packages/available_packages_by_name.html</a> 下载需要的语言包，例如<code>gridExtra</code>。</p><p>然后把下载 <code>gridExtra.tar.gz</code> 压缩包上传到待安装R语言包的系统上的某个目录，进入该目录，在<code>Shell</code>命令行终端（注意不是R的控制台）输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R CMD INSTALL gridExtra.tar.gz</span><br></pre></td></tr></table></figure><h3 id="Windows系统批量下载安装包"><a href="#Windows系统批量下载安装包" class="headerlink" title="Windows系统批量下载安装包"></a>Windows系统批量下载安装包</h3><p><strong>在windows系统下安装R环境</strong> </p><p>前往 <a href="https://cran.r-project.org/bin/windows/base/">https://cran.r-project.org/bin/windows/base/</a> 下载 <code>R</code> 的安装包。</p><p>例如：<a href="https://cran.r-project.org/bin/windows/base/R-3.6.1-win.exe">https://cran.r-project.org/bin/windows/base/R-3.6.1-win.exe</a></p><p>我们获得了 <code>R-3.6.1-win.exe</code> 安装包，直接双击运行即可安装成功。</p><p>运行成功后，我们在例如 <code>D</code> 盘创建一个文件夹，用于存放下载好的安装包，例如 <code>D:/Rpackages</code>。</p><p>然后我们打开R的环境，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/r/r-1.png" alt="R-package-install"></p><p>在这个R的控制台输入一些代码，来让R帮助我们自动下载依赖包，例如：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#download  </span></span><br><span class="line">getPackages &lt;- <span class="keyword">function</span>(packs)&#123;  </span><br><span class="line">  packages &lt;- unlist(  </span><br><span class="line">    tools::package_dependencies(packs, available.packages(),which=<span class="built_in">c</span>(<span class="string">&quot;Depends&quot;</span>, <span class="string">&quot;Imports&quot;</span>), recursive=<span class="literal">TRUE</span>)  </span><br><span class="line">  )  </span><br><span class="line">  packages &lt;- union(packs, packages)  </span><br><span class="line">  packages</span><br><span class="line">&#125;  </span><br><span class="line">myPackages &lt;- <span class="built_in">c</span>(<span class="string">&quot;raster&quot;</span>,<span class="string">&quot;gtools&quot;</span>, <span class="string">&quot;rhdf5&quot;</span>, <span class="string">&quot;dplyr&quot;</span>, <span class="string">&quot;DBI&quot;</span>, <span class="string">&quot;doBy&quot;</span>, <span class="string">&quot;foreign&quot;</span>, <span class="string">&quot;ggplot2&quot;</span>, <span class="string">&quot;maptools&quot;</span>, <span class="string">&quot;ncdf4&quot;</span>, <span class="string">&quot;sp&quot;</span>, <span class="string">&quot;rgdal&quot;</span>, <span class="string">&quot;ROzone2&quot;</span>, <span class="string">&quot;baidumap&quot;</span>, <span class="string">&quot;magrittr&quot;</span> , <span class="string">&quot;tsModel&quot;</span>)  </span><br><span class="line">packages &lt;- getPackages(myPackages)</span><br><span class="line">download.packages(packages, destdir=<span class="string">&quot;D:/Rpackages/&quot;</span>, type=<span class="string">&quot;source&quot;</span>)</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li><code>myPackages</code>后面添加的是需要安装的包，请依据实际需求修改。</li><li><code>destdir=&quot;D:/Rpackages/&quot;</code> 为下载目录，可以依据实际需求修改。</li><li>执行过程中会弹出选项下载源的提示，可以选择China中的任意一个，例如<code>LanZhou</code>，如下图：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/r/r-2.png" alt="R-package-install"></p><h3 id="在Linux系统下离线安装R环境"><a href="#在Linux系统下离线安装R环境" class="headerlink" title="在Linux系统下离线安装R环境"></a>在Linux系统下离线安装R环境</h3><p>把包和依赖传入离线环境后，<strong>在这些安装包所在的目录</strong>，运行离线环境中的<code>R</code>环境，打开R的控制台，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/r/r-3.png" alt="R-package-install"></p><p>在这个R的控制台输入一些代码，来让R帮助我们自动安装依赖包，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">library(tools)  </span><br><span class="line">path &lt;- <span class="string">&quot;./&quot;</span>  </span><br><span class="line">write_PACKAGES(path,<span class="built_in">type</span>=<span class="string">&quot;source&quot;</span>)  </span><br><span class="line">myPackages &lt;- c(<span class="string">&quot;raster&quot;</span>,<span class="string">&quot;gtools&quot;</span>, <span class="string">&quot;rhdf5&quot;</span>, <span class="string">&quot;dplyr&quot;</span>, <span class="string">&quot;DBI&quot;</span>, <span class="string">&quot;doBy&quot;</span>, <span class="string">&quot;foreign&quot;</span>, <span class="string">&quot;ggplot2&quot;</span>, <span class="string">&quot;maptools&quot;</span>, <span class="string">&quot;ncdf4&quot;</span>, <span class="string">&quot;sp&quot;</span>, <span class="string">&quot;rgdal&quot;</span>, <span class="string">&quot;ROzone2&quot;</span>, <span class="string">&quot;baidumap&quot;</span>, <span class="string">&quot;magrittr&quot;</span> , <span class="string">&quot;tsModel&quot;</span>) </span><br><span class="line">install.packages(myPackages, contriburl=paste(<span class="string">&quot;file:&quot;</span>,path,sep=<span class="string">&#x27;&#x27;</span>),<span class="built_in">type</span>=<span class="string">&quot;source&quot;</span>)  </span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li><code>path &lt;- &quot;./&quot;</code> 表示当前目录。如果提示找不到安装包，请使用<code>cd</code> 命令切换到上传安装包的目录。</li></ol><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><h3 id="stringi"><a href="#stringi" class="headerlink" title="stringi"></a>stringi</h3><p>报错：<br>checking whether we can fetch icudt… downloading the ICU data library (icudt)</p><p>解决方法：<br>手动下载一个master版本的，包含这个坑爹的包….<br><a href="https://raw.githubusercontent.com/gagolews/stringi/master/INSTALL">https://raw.githubusercontent.com/gagolews/stringi/master/INSTALL</a></p><h3 id="qvalue"><a href="#qvalue" class="headerlink" title="qvalue"></a>qvalue</h3><p>Package ‘qvalue’ was removed from the CRAN repository.<br>Formerly available versions can be obtained from the archive.<br>This package is now available from Bioconductor only, see <a href="http://www.bioconductor.org/packages/release/bioc/html/qvalue.html">http://www.bioconductor.org/packages/release/bioc/html/qvalue.html</a></p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>官网地址：<a href="https://www.r-project.org/">传送门</a></p><p>参考文章：<a href="https://blog.csdn.net/liu365560704/article/details/70321153">R语言离线下载包和依赖</a></p>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jfeff安装说明</title>
      <link href="//jfeff-install/"/>
      <url>//jfeff-install/</url>
      
        <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="http://leonardo.phys.washington.edu/jfeff-9.7.1/#opennewwindow">http://leonardo.phys.washington.edu/jfeff-9.7.1/#opennewwindow</a></p><h2 id="上传，增加可执行权限，执行安装"><a href="#上传，增加可执行权限，执行安装" class="headerlink" title="上传，增加可执行权限，执行安装"></a>上传，增加可执行权限，执行安装</h2><p>在windows下下载后的文件名为 <code>jfeff-9.7.1-linux-x64-installer.man</code> ，使用 <code>ftp</code> 工具上传到服务器某目录。然后使用 <code>chmod +x 文件名</code> 命令增加可执行权限。使用 <code>./文件名</code> 来执行安装命令，如下图：</p><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/jfeff/jfeff-1.png" alt="jfeff-istall"></p><p>选择<code>Next</code></p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/jfeff/jfeff-2.png" alt="jfeff-istall"></p><p>勾选<code>I accept ... ...</code>，选择<code>Next</code></p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/jfeff/jfeff-3.png" alt="jfeff-istall"></p><p>选择<code>Next</code></p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/jfeff/jfeff-4.png" alt="jfeff-istall"></p><p>安装中：</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/jfeff/jfeff-5.png" alt="jfeff-istall"></p><p>选择<code>Finish</code> 完成安装。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/jfeff/jfeff-6.png" alt="jfeff-istall"></p><p>软件自动勾选<code>launch JFEFF</code>，选择<code>Finish</code>后会自动加载软件，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/jfeff/jfeff-7.png" alt="jfeff-istall"></p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>用户以后想再次打开软件，可以通过一下操作实现：</p><ol><li>修改打开脚本 <code>jfeff.command</code> 的路径为自己的目录；</li><li>为命令添加软连接；</li><li>写入 <code>~/.bashrc</code> 文件可以自动加载环境。</li></ol><p>可以执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/JFEFF</span><br><span class="line">sed -i <span class="string">&quot;s%/Applications/jfeff.app/Contents/Resources%<span class="variable">$HOME</span>%g&quot;</span> jfeff.command</span><br><span class="line">ln -sf jfeff.command jfeff</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:$HOME/JFEFF&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>以后再用，直接执行 <code>jfeff</code> 命令即可。</p><ol start="5"><li>   系统环境<br>如果系统已经安装该软件，可以咨询系统管理员，得到使用方法，例如：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module add jfeff/9.7.1</span><br><span class="line">jfeff</span><br></pre></td></tr></table></figure><blockquote><p>注意，请使用支持图像界面的SSH终端，例如mobaxterm，可以参考：<a href="https://blog.mrzhenggang.com/supercomputer-courses-ssh-sftp-mobaxterm/">https://blog.mrzhenggang.com/supercomputer-courses-ssh-sftp-mobaxterm/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 可视化软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jfeff </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BerkeleyGW-2.1 安装教程</title>
      <link href="//berkeleygw-install/"/>
      <url>//berkeleygw-install/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是一个免费开源的大规模并行的电子激发态属性计算包，它基于采用ab initio GW和GW加Bethe-Salpeter方程方法的多体扰动理论。</p><p>编译方法可以参考官网：<a href="http://manual.berkeleygw.org/2.1/compilation/">http://manual.berkeleygw.org/2.1/compilation/</a></p><span id="more"></span><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><ul><li>编译器；如intel compiler</li><li>MPI编译器：如impi</li><li>fftw库：如fftw3</li><li>hdf5库：可选</li></ul><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>安装intel compiler 和 impi 的过程不再赘述。</p><h3 id="安装fftw库"><a href="#安装fftw库" class="headerlink" title="安装fftw库"></a>安装fftw库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget ftp://ftp.fftw.org/pub/fftw/fftw-3.3.8.tar.gz</span><br><span class="line">tar zxvf fftw-3.3.8.tar.gz</span><br><span class="line"><span class="built_in">cd</span> fftw-3.3.8</span><br><span class="line"><span class="comment"># 编译双精度版本</span></span><br><span class="line">./configure CC=icc FC=ifort CXX=icpc --prefix=<span class="variable">$HOME</span>/software/fftw/3.3.8</span><br><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li><code>CC</code>/<code>FC</code>/<code>CXX</code> 用来指定编译器的名字，如果不写，默认是GNU的编译器。</li><li><code>--prefix</code> 用来指定安装目录</li></ol><h3 id="安装hdf5"><a href="#安装hdf5" class="headerlink" title="安装hdf5"></a>安装hdf5</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载页面</span></span><br><span class="line"><span class="comment"># https://www.hdfgroup.org/downloads/hdf5/source-code/</span></span><br><span class="line"></span><br><span class="line">tar zxvf hdf5-1.10.5.tar.gz</span><br><span class="line"><span class="built_in">cd</span> hdf5-1.10.5 </span><br><span class="line">./configure CC=mpiicc FC=mpiifort CXX=mpiicpc \</span><br><span class="line">--enable-fortran --enable-parallel --enable-shared \</span><br><span class="line">--prefix=<span class="variable">$HOME</span>/software/hdf5/1.10.4 </span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li><code>--enable-fortran</code> 开启fortran支持，BGW需要</li><li><code>--enable-parallel</code> 开启并行支持，BGW需要</li></ol><h2 id="安装应用"><a href="#安装应用" class="headerlink" title="安装应用"></a>安装应用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载地址</span></span><br><span class="line"><span class="comment"># https://berkeleygw.org/download/</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">tar zxvf BerkeleyGW-2.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> BerkeleyGW-2.1</span><br></pre></td></tr></table></figure><p>需要一个名为<code>arch.mk</code>的配置文件，下面为我写好的配置文件，通常需要用户依据自身需求进行细微修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># arch.mk</span></span><br><span class="line">COMPFLAG  = -DINTEL</span><br><span class="line">PARAFLAG  = -DMPI</span><br><span class="line">MATHFLAG  = -DUSESCALAPACK -DHDF5 -DUNPACKED -DUSEFFTW3</span><br><span class="line">FCPP    = cpp -C</span><br><span class="line">F90free = mpiifort -free</span><br><span class="line"><span class="comment">#LINK    = mpiifort -i-static -openmp</span></span><br><span class="line">LINK    = mpiifort -qopenmp</span><br><span class="line">FOPTS   = -O3 -no-prec-div</span><br><span class="line">FNOOPTS = -O2 -no-prec-div</span><br><span class="line">MOD_OPT = -module</span><br><span class="line">INCFLAG = -I</span><br><span class="line">C_PARAFLAG = -DPARA</span><br><span class="line">CC_COMP = mpiicpc</span><br><span class="line">C_COMP  = mpiicc</span><br><span class="line">C_LINK  = mpiicpc</span><br><span class="line">C_OPTS  = -O3</span><br><span class="line">C_DEBUGFLAG =</span><br><span class="line">REMOVE  = /bin/rm -f</span><br><span class="line">FFTWPATH     = $(HOME)/software/fftw/3.3.8  <span class="comment"># fftw path</span></span><br><span class="line">FFTWLIB      = $(FFTWPATH)/lib/libfftw3.a</span><br><span class="line">FFTWINCLUDE  = $(FFTWPATH)/include</span><br><span class="line">MKLPATH      = $(MKLROOT)/lib/intel64</span><br><span class="line">LAPACKLIB    = -Wl,--start-group $(MKLPATH)/libmkl_intel_lp64.a $(MKLPATH)/libmkl_sequential.a \</span><br><span class="line">               $(MKLPATH)/libmkl_core.a $(MKLPATH)/libmkl_blacs_intelmpi_lp64.a \</span><br><span class="line">               -Wl,--end-group -lpthread</span><br><span class="line">SCALAPACKLIB = $(MKLPATH)/libmkl_scalapack_lp64.a</span><br><span class="line">HDF5DIR      = $(HOME)/software/hdf5/1.10.4 <span class="comment"># hdf5 path</span></span><br><span class="line">HDF5LIB      = $(HDF5DIR)/lib/libhdf5hl_fortran.a $(HDF5DIR)/lib/libhdf5_hl.a \</span><br><span class="line">               $(HDF5DIR)/lib/libhdf5_fortran.a $(HDF5DIR)/lib/libhdf5.a -lz</span><br><span class="line">HDF5INCLUDE  = $(HDF5DIR)/include</span><br><span class="line">TESTSCRIPT = sbatch hbar.scr</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>该文件详细描述了各个编译参数和库的路径。</li><li>请依据自身的需要进行修改。</li><li><code>MATHFLAG</code> 参数用来添加<code>FFTW3</code>和<code>HDF5</code>的支持。</li></ol><p>然后进行编译即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make all-flavors</span><br><span class="line">make install PREFIX=<span class="variable">$HOME</span>/software/bgw/2.1-real</span><br></pre></td></tr></table></figure><p>编译cplx版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make clean-flavored</span><br><span class="line">make cplx</span><br><span class="line">make install PREFIX=<span class="variable">$HOME</span>/software/bgw/2.1-cplx</span><br></pre></td></tr></table></figure><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> BGW_HOME=<span class="variable">$HOME</span>/software/bgw/2.1-real   <span class="comment"># real or cplx , 用&quot;#&quot; 注释掉其中一行</span></span><br><span class="line"><span class="built_in">export</span> BGW_HOME=<span class="variable">$HOME</span>/software/bgw/2.1-cplx</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$BGW_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$BGW_HOME</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 应用软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> berkeleygw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Collectl在TH-1A上的使用</title>
      <link href="//collectl-on-th1a/"/>
      <url>//collectl-on-th1a/</url>
      
        <content type="html"><![CDATA[<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module add collectl</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="拷贝脚本"><a href="#拷贝脚本" class="headerlink" title="拷贝脚本"></a>拷贝脚本</h3><p>拷贝脚本到算例的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="variable">$COLLECTL_HOME</span>/scripts/v1.0/* .</span><br></pre></td></tr></table></figure><h3 id="修改相关参数"><a href="#修改相关参数" class="headerlink" title="修改相关参数"></a>修改相关参数</h3><p>依据不同任务，修改<code>collectl-run.sh</code>脚本参数，包括：</p><ul><li>partition 计算分区，可用<code>yhi</code>查看可用分区。</li><li>nodes 运行节点数</li><li>cores 运行总核数</li><li>exe 运行命令及相关参数，例如<code>lmp &lt; in.lj &gt; out.log</code>。（写的是实际运行的命令，而不是提交脚本或类似 <code>yhrun -N1 exe</code>)</li><li>OMP_NUM_THREADS 设置线程数</li></ul><h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><p>直接执行该脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./collectl-run.sh</span><br></pre></td></tr></table></figure><p>会获得<code>jobid</code>号，例如：14570273。</p><p>使用 <code>yhq</code> 查看任务状态， <code>PD</code> 为等待， <code>R</code> 为运行， 如果任务消失则表示结束。</p><h2 id="分析数据"><a href="#分析数据" class="headerlink" title="分析数据"></a>分析数据</h2><p>等待任务结束后，分析数据，运行脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./collectl-analysis.sh nodesfile-14570273</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>nodesfile-14570273</code> 为运行得到的节点编号文件，请依据实际 <code>jobid</code> 进行修改。</li></ul><p>分析结果类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">This is collectl script --- analysis calculate node messages.</span><br><span class="line">Analyzing nodesfile-14570273 cn2021</span><br><span class="line">         Operation          Max        Min       Mean</span><br><span class="line">         CPU USAGE(%)     33.00       0.00       5.43</span><br><span class="line">          MEMORY(MB)    6144.00    5120.00    5266.29</span><br><span class="line">     NetworkIn(KB/s)       0.00       0.00       0.00</span><br><span class="line">  NetworkIn(count/s)       0.00       0.00       0.00</span><br><span class="line">    NetworkOut(KB/s)       0.00       0.00       0.00</span><br><span class="line"> NetworkOut(count/s)       0.00       0.00       0.00</span><br><span class="line">        IORead(KB/s)    5075.00      12.00    2179.29</span><br><span class="line">     IORead(count/s)    1394.00      46.00     632.29</span><br><span class="line">       IOWrite(KB/s)     372.00       4.00     178.86</span><br><span class="line">    IOWrite(count/s)    1256.00      44.00     548.43</span><br><span class="line">Plt cn2021.log_cpuuse.png</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li><code>CPU USAGE(%)</code> 为CPU 使用率</li><li><code>MEMORY(MB)</code> 为内存使用量</li><li><code>Network</code> 为网络通信数据, <code>KB/s</code> 每秒通信量, <code>count/s</code> 每秒通信次数</li><li><code>IORead</code>, <code>IOWrite</code> 为IO读写情况</li><li>程序会生成<code>png</code>图片用于分析</li></ol><h2 id="视频教学"><a href="#视频教学" class="headerlink" title="视频教学"></a>视频教学</h2><center><video src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/collectl/collectl-th1a.mp4" controls="controls" height="400" weight="700" >您的浏览器不支持 video 标签。</video></center>]]></content>
      
      
      <categories>
          
          <category> 性能分析工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> collectl </tag>
            
            <tag> 性能分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SLURM作业计算顺序的调整方法</title>
      <link href="//slurm-change-job-calculation-order/"/>
      <url>//slurm-change-job-calculation-order/</url>
      
        <content type="html"><![CDATA[<h2 id="用户需求"><a href="#用户需求" class="headerlink" title="用户需求"></a>用户需求</h2><blockquote><p>已经提交了很多任务，一部分已经在计算中 <code>RUN</code>，一部分在排队中 <code>PD</code>。现在新提交一个任务，希望该任务能够优先计算。</p></blockquote><span id="more"></span><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>使用 <code>yhcontrol hold | release</code> 来解决。</p><h2 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h2><ol><li>提交新任务。</li><li>使用<code>yhcontrol hold</code>来 <code>暂停</code> 已经提交任务中状态为排队 <code>PD</code> 的任务。</li><li>等待新任务开始计算，使用<code>yhcontrol release</code>来 恢复之前被 <code>暂停</code> 的任务。（手动或写脚本自动实现）</li></ol><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><h3 id="1-提交新任务"><a href="#1-提交新任务" class="headerlink" title="1.提交新任务"></a>1.提交新任务</h3><p>已经提交了5个任务，使用 <code>yhq</code> 命令查看，得到如下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ yhq</span><br><span class="line">JOBID     PARTITION  NAME     USER       ST  TIME      NODES NODELIST(REASON)</span><br><span class="line">100001    debug      sub.sh   zhenggang  R   00:05:01  1     cn[11]</span><br><span class="line">100002    debug      sub.sh   zhenggang  R   00:05:02  1     cn[12]</span><br><span class="line">100003    debug      sub.sh   zhenggang  PD  0:00      1     (Resources)</span><br><span class="line">100004    debug      sub.sh   zhenggang  PD  0:00      1     (Resources)</span><br><span class="line">100005    debug      sub.sh   zhenggang  PD  0:00      1     (Resources)</span><br></pre></td></tr></table></figure><p>其中，<code>100001 100002</code> 在计算， <code>100003 100004 100005</code> 在排队。</p><p>现在我们提交一个新的任务，然后再 <code>yhq</code> 查看，得到如下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ yhq</span><br><span class="line">JOBID     PARTITION  NAME     USER       ST  TIME      NODES NODELIST(REASON)</span><br><span class="line">100001    debug      sub.sh   zhenggang  R   00:05:11  1     cn[11]</span><br><span class="line">100002    debug      sub.sh   zhenggang  R   00:05:12  1     cn[12]</span><br><span class="line">100003    debug      sub.sh   zhenggang  PD  0:00      1     (Resources)</span><br><span class="line">100004    debug      sub.sh   zhenggang  PD  0:00      1     (Resources)</span><br><span class="line">100005    debug      sub.sh   zhenggang  PD  0:00      1     (Resources)</span><br><span class="line">100006    debug      sub.sh   zhenggang  PD  0:00      1     (Resources)</span><br></pre></td></tr></table></figure><h3 id="2-暂停任务"><a href="#2-暂停任务" class="headerlink" title="2.暂停任务"></a>2.暂停任务</h3><p>我们希望任务 <code>100006</code> 在任务 <code>100003 100004 100005</code> 之前先计算，那么我们就将这3个任务 <code>hold</code> 一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yhcontrol hold 100003 100004 100005</span><br></pre></td></tr></table></figure><p>然后我们再 <code>yhq</code> 查看，得到如下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ yhq</span><br><span class="line">JOBID     PARTITION  NAME     USER       ST  TIME      NODES NODELIST(REASON)</span><br><span class="line">100001    debug      sub.sh   zhenggang  R   00:05:21  1     cn[11]</span><br><span class="line">100002    debug      sub.sh   zhenggang  R   00:05:22  1     cn[12]</span><br><span class="line">100003    debug      sub.sh   zhenggang  PD  0:00      1     (JobHeldUser)</span><br><span class="line">100004    debug      sub.sh   zhenggang  PD  0:00      1     (JobHeldUser)</span><br><span class="line">100005    debug      sub.sh   zhenggang  PD  0:00      1     (JobHeldUser)</span><br><span class="line">100006    debug      sub.sh   zhenggang  PD  0:00      1     (Resources)</span><br></pre></td></tr></table></figure><p>可以看到这3个任务的 <code>NODELIST(REASON)</code> 变为了 <code>JobHeldUser</code> 。</p><p>这样修改后，当系统有可用的计算资源时，会优先计算任务 <code>100006</code> ，跳过被 <code>hold</code> 的任务。</p><h3 id="3-恢复任务"><a href="#3-恢复任务" class="headerlink" title="3.恢复任务"></a>3.恢复任务</h3><p>之前我们把任务 <code>100003 100004 100005</code> 变为了 <code>hold</code> 的任务，如果不恢复，那么它们会一直无法计算的。</p><p>所以需要在希望优先计算的任务 <code>100006</code> 开始计算后，将这些被 <code>hold</code> 的任务状态改回来，即为 <code>release</code> ， 命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yhcontrol release 100003 100004 100005</span><br></pre></td></tr></table></figure><p>然后我们再 <code>yhq</code> 查看，得到如下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ yhq</span><br><span class="line">JOBID     PARTITION  NAME     USER       ST  TIME      NODES NODELIST(REASON)</span><br><span class="line">100001    debug      sub.sh   zhenggang  R   00:05:21  1     cn[11]</span><br><span class="line">100002    debug      sub.sh   zhenggang  R   00:05:22  1     cn[12]</span><br><span class="line">100003    debug      sub.sh   zhenggang  PD  0:00      1     (Resources)</span><br><span class="line">100004    debug      sub.sh   zhenggang  PD  0:00      1     (Resources)</span><br><span class="line">100005    debug      sub.sh   zhenggang  PD  0:00      1     (Resources)</span><br><span class="line">100006    debug      sub.sh   zhenggang  R   0:10      1     cn[13]</span><br></pre></td></tr></table></figure><h3 id="4-自动暂停-恢复"><a href="#4-自动暂停-恢复" class="headerlink" title="4.自动暂停|恢复"></a>4.自动暂停|恢复</h3><h4 id="4-1-暂停任务"><a href="#4-1-暂停任务" class="headerlink" title="4.1 暂停任务"></a>4.1 暂停任务</h4><p>当需要被 <code>hold</code> 的任务很多的时候，使用 <code>yhq</code> 命令得到 <code>jobid</code> 的列表，然后逐一粘贴，不是很方便。我们可以写一个简单的脚本实现。</p><p>1.获得需要被hold的任务列表，存到一个临时文件 <code>jobhold.txt</code> 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yhq | grep PD | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> &gt; jobhold.txt</span><br></pre></td></tr></table></figure><p>2.循环遍历这个临时文件的每一行，逐一 <code>hold</code> 这些任务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> jobid <span class="keyword">in</span> `cat jobhold.txt`;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">yhcontrol hold <span class="variable">$jobid</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="4-2-恢复任务"><a href="#4-2-恢复任务" class="headerlink" title="4.2 恢复任务"></a>4.2 恢复任务</h4><p>我们可以编写一个脚本，例如 <code>jobrelease.sh</code> ，然后提交到登陆节点后台，自动的定期检查新提交任务的状态，如果任务已经在计算，则自动恢复之前被 <code>hold</code> 的任务。脚本举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">jobid=100006</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ture</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  jobst=`yhqueue | grep <span class="variable">$jobid</span> | awk <span class="string">&#x27;&#123;print $5&#125;&#x27;</span> || <span class="built_in">echo</span> <span class="string">&quot;None&quot;</span>`</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="variable">$jobst</span> == <span class="string">&#x27;PD&#x27;</span> ]];<span class="keyword">then</span></span><br><span class="line">    sleep 60</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span> jobid <span class="keyword">in</span> `cat jobhold.txt`;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      yhcontrol release <span class="variable">$jobid</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">break</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><blockquote><p>脚本中 <code>jobid=&#39;100006&#39;</code> 需要根据实际需求来修改。</p></blockquote><p>然后将这个脚本提交到登陆节点后台：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x jobrelease.sh</span><br><span class="line">nohup ./jobrelease.sh &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>如果我们不止有一个任务需要被优先计算，例如新提交了 <code>100006 100007 100008</code> 三个任务，希望先算这3个，然后再算之前提交的任务，我们可以略微修改一下刚才的 <code>jobrelease.sh</code> 脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">jobids=(100006 100007 100008)</span><br><span class="line">bool_release=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">for</span> jobid <span class="keyword">in</span> <span class="variable">$&#123;jobids[@]&#125;</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    jobst=`yhqueue | grep <span class="variable">$jobid</span> | awk <span class="string">&#x27;&#123;print $5&#125;&#x27;</span> || <span class="built_in">echo</span> <span class="string">&quot;None&quot;</span>`</span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$jobst</span> == <span class="string">&#x27;PD&#x27;</span> ]] ;<span class="keyword">then</span></span><br><span class="line">      bool_release=<span class="literal">false</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> [[ <span class="variable">$bool_release</span> == <span class="string">&#x27;true&#x27;</span> ]] ;<span class="keyword">then</span> </span><br><span class="line">    <span class="keyword">for</span> jobid <span class="keyword">in</span> `cat jobhold.txt`;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      yhcontrol release <span class="variable">$jobid</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">break</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    sleep 60</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>然后再提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x jobrelease.sh</span><br><span class="line">nohup ./jobrelease.sh &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 作业调度 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> slurm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于存储配额的说明</title>
      <link href="//storage-quota-introduction/"/>
      <url>//storage-quota-introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="1-存储说明"><a href="#1-存储说明" class="headerlink" title="1. 存储说明"></a>1. 存储说明</h2><p>天河系统采用Lustre分布式存储文件系统，该文件系统由多个存储结点构成，对外提供一个统一的大分区，供所有登陆结点与计算结点进行挂载。</p><p>Lustre高性能存储用于用户进行计算任务的数据存储，用户在登陆系统后看到的数据存储在Lustre存储中。</p><span id="more"></span><p>比如，用户名为 <code>zhenggang</code>，所属的文件系统为 <code>THL6</code>， 那么用户的根目录为 <code>/THL6/home/zhenggang</code> 。</p><h2 id="2-存储查询"><a href="#2-存储查询" class="headerlink" title="2. 存储查询"></a>2. 存储查询</h2><h3 id="2-1-登陆系统时可以显示"><a href="#2-1-登陆系统时可以显示" class="headerlink" title="2.1 登陆系统时可以显示"></a>2.1 登陆系统时可以显示</h3><p>登陆系统后，通常就会显示该用户所属group（即用户组）的存储情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Disk quotas <span class="keyword">for</span> group zhenggang (gid 5005):</span><br><span class="line">     Filesystem    used    quota  <span class="built_in">limit</span>   grace    files      quota   <span class="built_in">limit</span>   grace</span><br><span class="line">          /THL6    123G     500G    1T       -       123   1000000  2000000       -</span><br></pre></td></tr></table></figure><center>表1 磁盘配额各关键词说明 </center><table><thead><tr><th>关键词</th><th>含义</th></tr></thead><tbody><tr><td>Filesystem</td><td>用户所在的共享分布式存储</td></tr><tr><td>used</td><td>用户目前已经使用的存储（单位KB）</td></tr><tr><td>quota</td><td>存储软限制（单位KB）</td></tr><tr><td>limit</td><td>存储硬限制（单位KB）</td></tr><tr><td>grace</td><td>存储状态</td></tr><tr><td>files</td><td>用户已有的文件数量（单位：个）</td></tr><tr><td>quota</td><td>文件数量软限制（单位：个）</td></tr><tr><td>limit</td><td>文件数量硬限制（单位：个）</td></tr><tr><td>grace</td><td>文件数量状态</td></tr></tbody></table><h3 id="2-2-使用查询命令查询"><a href="#2-2-使用查询命令查询" class="headerlink" title="2.2 使用查询命令查询"></a>2.2 使用查询命令查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TH-1A系统</span></span><br><span class="line">lfs quota -g `whoami` `<span class="built_in">echo</span> <span class="variable">$HOME</span>  | awk -F / <span class="string">&#x27;&#123;print &quot;/&quot;$2&#125;&#x27;</span>`  <span class="comment"># 查询用户组</span></span><br><span class="line">lfs quota -u `whoami` `<span class="built_in">echo</span> <span class="variable">$HOME</span>  | awk -F / <span class="string">&#x27;&#123;print &quot;/&quot;$2&#125;&#x27;</span>`  <span class="comment"># 查询用户</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TH-HPC系统</span></span><br><span class="line">lfs quota -g -h `whoami` `<span class="built_in">echo</span> <span class="variable">$HOME</span>  | awk -F / <span class="string">&#x27;&#123;print &quot;/&quot;$2&#125;&#x27;</span>`  <span class="comment"># 查询用户组</span></span><br><span class="line">lfs quota -u -h `whoami` `<span class="built_in">echo</span> <span class="variable">$HOME</span>  | awk -F / <span class="string">&#x27;&#123;print &quot;/&quot;$2&#125;&#x27;</span>`  <span class="comment"># 查询用户</span></span><br></pre></td></tr></table></figure><h2 id="3-磁盘配额限制"><a href="#3-磁盘配额限制" class="headerlink" title="3. 磁盘配额限制"></a>3. 磁盘配额限制</h2><p>为了合理利用有限的存储资源，目前中心对用户默认进行存储软限制<code>500G</code>，存储硬限制<code>1T</code>，文件数软限制<code>100万</code>，文件数硬限制<code>200万</code>的磁盘配额限制。</p><p>1）用户使用存储低于500G时，存储状态正常；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Disk quotas <span class="keyword">for</span> group zhenggang (gid 5005):</span><br><span class="line">     Filesystem    used    quota  <span class="built_in">limit</span>   grace    files      quota   <span class="built_in">limit</span>   grace</span><br><span class="line">          /THL6    123G     500G    1T       -       123   1000000  2000000       -</span><br></pre></td></tr></table></figure><p>2）当用户使用存储介于<code>500G</code>和<code>1T</code>之间时，used参数对应的数字带有“*”表示用户配额异常，“6d23h59m57s”表示倒计时，如果用户在倒计时结束前将使用存储清理到<code>500G</code>以下，则存储状态恢复正常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Disk quotas <span class="keyword">for</span> group zhenggang (gid 5005):</span><br><span class="line">     Filesystem    used     quota  <span class="built_in">limit</span>          grace    files      quota   <span class="built_in">limit</span>  grace</span><br><span class="line">          /THL6    768G*     500G    1T     6d23h59m57s    12345   1000000  2000000      -</span><br></pre></td></tr></table></figure><p>3）如果在规定时间，否则用户的数据量超出软限制且超出倒计时，则无法使用了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Disk quotas <span class="keyword">for</span> group zhenggang (gid 5005):</span><br><span class="line">     Filesystem    used     quota  <span class="built_in">limit</span>   grace    files     quota    <span class="built_in">limit</span>  grace</span><br><span class="line">          /THL6    768G*     500G    1T     none    12345   1000000  2000000      -</span><br></pre></td></tr></table></figure><p>4）如果用户数据在倒计时期间继续增长，超出硬限制，则用户存储将无法写入，如图3-4所示；数据操作也会受限制，如图3-5所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Disk quotas <span class="keyword">for</span> group zhenggang (gid 5005):</span><br><span class="line">     Filesystem    used     quota  <span class="built_in">limit</span>   grace   files     quota     <span class="built_in">limit</span>  grace</span><br><span class="line">          /THL6    1.2T*     500G    1T        -   45678   1000000  2000000       -</span><br></pre></td></tr></table></figure><blockquote><p>有的时候用户登录会出现错误提示“Some errors happened when getting quota info. Some devices may be not working or deactivated. The data in “[]” is inaccurate.”这是因为登陆结点quota服务没有启用，对用户本身的操作和作业不会有影响。</p></blockquote><hr><blockquote><p>小结</p></blockquote><blockquote><ol><li>存储是有配额限制的：超出软限制，开启倒计时，倒计时到期就用不了了；超出硬限制，直接就用不了了。</li><li>查询配额，可以开启新终端登陆时自动显示，或通过命令查询<code>lfs quota -g -h zhenggang</code> ，请将命令中的<code>zhenggang</code>改为自己的帐户名。</li><li>当配额出现<code>*</code>时，请及时清理数据。</li><li>免费配额不足，可以申请购买，<a href="https://blog.mrzhenggang.com/about/">联系我们</a>。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配额 </tag>
            
            <tag> storage </tag>
            
            <tag> quota </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超算入门课程3 linux基本命令教学</title>
      <link href="//supercomputer-courses-linux-basic-commands/"/>
      <url>//supercomputer-courses-linux-basic-commands/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/linux/linux-logo.png"></p><h2 id="1-linux的简介"><a href="#1-linux的简介" class="headerlink" title="1. linux的简介"></a>1. linux的简介</h2><p>Linux是一套免费使用和自由传播的类Unix操作系统。</p><span id="more"></span><h2 id="2-linux的图形界面和命令行"><a href="#2-linux的图形界面和命令行" class="headerlink" title="2. linux的图形界面和命令行"></a>2. linux的图形界面和命令行</h2><p>不要对linux有误解，以为它只有一个黑框框，实际上现在的常见的Linux发行版的图形界面，非常好看，例如：</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/linux/linux-ubuntu-logo.png"></p><p>但实际上，我们最常用的还是一个黑框框<code>Terminal</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/linux/linux-terminal.png"></p><h2 id="3-linux的常用命令"><a href="#3-linux的常用命令" class="headerlink" title="3. linux的常用命令"></a>3. linux的常用命令</h2><h3 id="3-1-举一个例子"><a href="#3-1-举一个例子" class="headerlink" title="3.1 举一个例子"></a>3.1 举一个例子</h3><p>在windows下，我们习惯了用窗口图形化界面的方式进行各种基本操作，比如创建一个新文件夹<code>temp</code>，我们需要：</p><ol><li>单击鼠标右键</li><li>选择新建</li><li>选择文件夹</li><li>输入文件夹的名字<code>temp</code></li><li>按回车键确认</li></ol><p>如果了解一点快捷键，可以：</p><ol><li>单击鼠标邮件</li><li>按键盘”w”</li><li>按键盘”f”</li><li>输入文件夹的名字<code>temp</code></li><li>按回车键确认</li></ol><p>再进一步，我们用快捷键，可以：</p><ol><li>按”ctrl+shift+n”</li><li>输入文件夹的名字<code>temp</code></li><li>按回车键确认</li></ol><p>在linux下，我们使用一行命令即可创建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir temp</span><br></pre></td></tr></table></figure><p>大家感受一下哪一种方式比较快？</p><h3 id="3-2-常用命令"><a href="#3-2-常用命令" class="headerlink" title="3.2 常用命令"></a>3.2 常用命令</h3><center><video src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/linux/linux-command-1080p.mp4" controls="controls" height="400" weight="700" >您的浏览器不支持 video 标签。</video></center><p>我们下面举一个实际的例子，大家跟着做，输入带有<code>$</code>行的命令，看看会得到什么（<code>#</code>号后面的内容是注释，不需要输入）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ date      <span class="comment"># 显示日期和当前时间</span></span><br><span class="line">Sun Dec 23 14:16:39 CST 2018</span><br><span class="line">$ whoami    <span class="comment"># 查询当前登录在系统中的用户信息</span></span><br><span class="line">zhenggang</span><br><span class="line">$ <span class="built_in">pwd</span>       <span class="comment"># 显示当前工作目录</span></span><br><span class="line">/home/zhenggang</span><br><span class="line">$ ls        <span class="comment"># 显示目录内容</span></span><br><span class="line">backup  Desktop  downloads  projects  PycharmProjects  software  temp  workdir</span><br><span class="line">$ mkdir temp     <span class="comment"># 创建目录</span></span><br><span class="line">$ <span class="built_in">cd</span> temp   <span class="comment"># 改变工作目录</span></span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/zhenggang/temp</span><br><span class="line">$ touch 1.txt    <span class="comment"># 创建内容为空的文件</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> &gt; 1.txt  <span class="comment"># 将&quot;hello world&quot;字符串显示，并定向到1.txt文件</span></span><br><span class="line">$ cat 1.txt      <span class="comment"># 用于显示文件内容</span></span><br><span class="line">hello world</span><br><span class="line">$ clear     <span class="comment"># 清屏</span></span><br><span class="line">$ grep hello 1.txt    <span class="comment"># 查找字符串：在1.txt文件中查找hello字符串，找到了就返回匹配的行</span></span><br><span class="line">hello world</span><br><span class="line">$ find * -name 1.txt  <span class="comment"># 查找文件：*表示当前目录，从当前目录递归查找名为 1.txt的文件</span></span><br><span class="line">1.txt</span><br><span class="line">$ mv 1.txt 2.txt      <span class="comment"># 文件的搬移或更名，将1.txt改名为2.txt</span></span><br><span class="line">$ ls</span><br><span class="line">2.txt</span><br><span class="line">$ cp 2.txt 3.txt      <span class="comment"># 复制文件或目录，如果拷贝的是目录，则加入&quot;-r&quot; 参数</span></span><br><span class="line">$ ls</span><br><span class="line">2.txt 3.txt</span><br><span class="line">$ <span class="built_in">cd</span> ..    <span class="comment"># 退回到上一级目录</span></span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/zhenggang</span><br><span class="line">$ <span class="built_in">cd</span>       <span class="comment"># 退回到用户根目录</span></span><br><span class="line">/home/zhenggang</span><br></pre></td></tr></table></figure><h3 id="3-2-文件的权限（菜鸟版）"><a href="#3-2-文件的权限（菜鸟版）" class="headerlink" title="3.2 文件的权限（菜鸟版）"></a>3.2 文件的权限（菜鸟版）</h3><p>最常用的是修改可执行权限，举例：为<code>1.txt</code>文件增加可执行权限，使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x 1.txt</span><br></pre></td></tr></table></figure><blockquote><p><code>+x</code>表示增加可执行权限；<code>-x</code>表示去除可执行权限：如果是递归修改，可以增加参数<code>-R</code></p></blockquote><h3 id="3-2-文件的权限（进阶版）"><a href="#3-2-文件的权限（进阶版）" class="headerlink" title="3.2 文件的权限（进阶版）"></a>3.2 文件的权限（进阶版）</h3><blockquote><p>Linux 一般将文件可存取的身份分为三个类别，分别是 owner/group/others，且三种身份各有read/write/execute 等权限。</p></blockquote><p>我们画一个示意图来介绍：</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/linux/linux-chmod.png"></p><ul><li><p>第一个字符代表这个文件是『目录、文件或链接文件等等』</p><ul><li>当为[ d ]则是目录</li><li>当为[ - ]则是文件</li><li>若是[ l ]则表示为连结档(link file)</li></ul></li><li><p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</p><ul><li>第一组为『文件拥有者可具备的权限』</li><li>第二组为『加入此群组之账号的权限』</li><li>第三组为『非本人且没有加入本群组之其他账号的权限</li></ul></li></ul><p>我们用<code>ls -al</code> 命令来查看刚才的<code>1.txt</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al</span><br><span class="line">-rw-rw-r--  1 zhenggang zhenggang    0 Dec 23 15:40 1.txt</span><br></pre></td></tr></table></figure><p>我们仔细观察第一列<code>-rw-rw-r--</code>，它表示<code>1.txt</code>文件的权限，因此<code>-rw-rw-r--</code> 表示：</p><ul><li>它是一个文件</li><li>对于自己，该文件可读可写不可执行</li><li>对于组内用户，该文件可读可写不可执行</li><li>对于其他用户，该文件可读不可写不可执行</li></ul><p>文件权限的改变使用的是 <code>chmod</code>这个指令，但是，权限的设定方法有两种， 分别可以使用数字或者是符号来进行权限的变更。</p><p><strong>使用数字改变权限</strong></p><p>我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><ul><li>r 4</li><li>w 2</li><li>x 1</li></ul><p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rw-rw-r–] 分数则：</p><ul><li>owner = rw- = 4+2+0 = 6</li><li>group = rw- = 4+2+0 = 6</li><li>others= r– = 4+0+0 = 4</li></ul><p>我们使用chmod命令，语法如下：</p><table><thead><tr><th>命令</th><th>数字</th><th>目标</th></tr></thead><tbody><tr><td>chmod</td><td>764</td><td>文件或目录</td></tr></tbody></table><blockquote><p>第一个数字表示owner的，第二个数字并表示group的，第三个数字表示others的。</p></blockquote><p>为<code>1.txt</code>文件增加<code>owner</code>的可执行权限，则为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chmod 764 1.txt</span><br><span class="line">$ ls -sl</span><br><span class="line">-rwxrw-r--  1 zhenggang zhenggang    0 Dec 23 15:40 1.txt</span><br></pre></td></tr></table></figure><p>我们可以发现，各种权限是不重复的，如下：</p><table><thead><tr><th>数字</th><th>可读</th><th>可写</th><th>可执行</th></tr></thead><tbody><tr><td>0</td><td>&times;</td><td>&times;</td><td>&times;</td></tr><tr><td>1</td><td>&times;</td><td>&times;</td><td>1</td></tr><tr><td>2</td><td>&times;</td><td>2</td><td>&times;</td></tr><tr><td>3</td><td>&times;</td><td>2</td><td>1</td></tr><tr><td>4</td><td>4</td><td>&times;</td><td>&times;</td></tr><tr><td>5</td><td>4</td><td>&times;</td><td>1</td></tr><tr><td>6</td><td>4</td><td>2</td><td>&times;</td></tr><tr><td>7</td><td>4</td><td>2</td><td>1</td></tr></tbody></table><p>用户可以依据自己的需求设置相应的权限，当需要递归修改文件夹时，可以使用<code>-R</code>参数。</p><p><strong>使用符号改变权限</strong></p><table><thead><tr><th>命令</th><th>对象</th><th>操作</th><th>读写执行权限</th><th>目标</th></tr></thead><tbody><tr><td>chmod</td><td>u(自己)<br/>g(同组用户)<br/>o(其他用户)<br/>a(所有人)</td><td>+(加入)<br/>-(除去)<br/>=(设定)</td><td>r(可读)<br/>w(可写)<br/>x(可执行)</td><td>文件或目录</td></tr></tbody></table><p>举例，将<code>1.txt</code> 从 <code>-rw-rw-r---</code> 改为<code>-rwxrw-r--</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chmod u+x 1.txt</span><br><span class="line">$ ls -al</span><br><span class="line">-rwxrw-r--  1 zhenggang zhenggang    0 Dec 23 15:40 1.txt</span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="A-Linux基本命令"><a href="#A-Linux基本命令" class="headerlink" title="A Linux基本命令"></a>A Linux基本命令</h3><p><strong>A1 基本命令</strong></p><table><thead><tr><th>命令</th><th>含义</th><th>格式</th></tr></thead><tbody><tr><td>date</td><td>显示日期和当前时间</td><td>$ date</td></tr><tr><td>who</td><td>查询当前登录在系统中的用户信息</td><td>$ who</td></tr><tr><td>ps</td><td>用于查看当前系统中的活跃进程</td><td>$ ps [options]</td></tr><tr><td>kill</td><td>终止指定进程</td><td>$ kill [-signal] pid</td></tr></tbody></table><p><strong>A2 目录操作</strong></p><table><thead><tr><th>命令</th><th>含义</th><th>格式</th></tr></thead><tbody><tr><td>mkdir</td><td>创建目录</td><td>$ mkdir directory …</td></tr><tr><td>rmdir</td><td>删除目录</td><td>$ rmdir directory …</td></tr><tr><td>pwd</td><td>显示当前工作目录</td><td>$ pwd</td></tr><tr><td>ls</td><td>显示目录内容</td><td>$ ls [options] [names]，选项可合用</td></tr><tr><td>cd</td><td>改变工作目录</td><td>$ cd [directory]</td></tr></tbody></table><p><strong>A3 文件创建、复制与删除</strong></p><table><thead><tr><th>命令</th><th>含义</th><th>格式</th></tr></thead><tbody><tr><td>touch</td><td>创建内容为空的文件</td><td>$ touch 文件名</td></tr><tr><td>rm</td><td>删除文件或目录</td><td>$ rm [-r] [-f] [-i] file …</td></tr><tr><td>cp</td><td>复制文件或目录</td><td>$ cp [-i] [-r] file1 [file2…] target <br/>-r 如果 file 为目录，则 cp 将复制该目录及其所有文件</td></tr><tr><td>mv</td><td>文件的搬移或更名</td><td>$ mv file1 target</td></tr></tbody></table><p><strong>A4 文件属性</strong></p><table><thead><tr><th>命令</th><th>含义</th><th>格式</th></tr></thead><tbody><tr><td>chmod</td><td>改变文件的读、写或执行权限</td><td>$ chmod [who] operator [permission] file-list</td></tr><tr><td>chown</td><td>改变文件的属主</td><td>$ chown [-R] [-h] owner file</td></tr><tr><td>chgrp</td><td>改变文件的组主</td><td>$ chgrp [-R] [-h] group file</td></tr></tbody></table><p><strong>A5 文件显示与连接</strong></p><table><thead><tr><th>命令</th><th>含义</th><th>格式</th></tr></thead><tbody><tr><td>cat</td><td>用于显示文件内容或文件连接</td><td>$ cat file1 file2 显示 file1 和 file2 的内容 <br/> $ cat file1 file2 &gt; file3 将 file1 和 file2 合并成 file3</td></tr><tr><td>more</td><td>显示文件的内容</td><td>$ more 文件名</td></tr><tr><td>head</td><td>显示文件的前几行</td><td>$ head [-n] [file…]</td></tr><tr><td>tail</td><td>将文件从指定位置开始的内容全部显示到屏幕上</td><td>$ tail [+n] [lbc] file 从文件头加上 n 处开始显示 <br/> $ tail [-n] [lbc] file 从文件尾减去 n 处开始显示 <br/> $ tail -f file 间隔 1 秒循环显示文件新内容</td></tr><tr><td>ln</td><td>建立指定文件的硬链接或符号链接</td><td>$ ln [-s] [-f] [-n] file target</td></tr></tbody></table><p><strong>A6 文件查找与比较</strong></p><table><thead><tr><th>命令</th><th>含义</th><th>格式</th></tr></thead><tbody><tr><td>grep</td><td>查找字符串</td><td>$ grep pattern files</td></tr><tr><td>find</td><td>从指定目录开始，递归地从子目录寻找匹配文件</td><td>$ find dirname option-list</td></tr><tr><td>diff</td><td>比较两个文本文件的差异</td><td>$ diff [options] file1 file2</td></tr></tbody></table><p><strong>A7 文件压缩与备份</strong></p><table><thead><tr><th>命令</th><th>含义</th><th>格式</th></tr></thead><tbody><tr><td>compress</td><td>进行文件压缩</td><td>$ compress [-cfv] filename</td></tr><tr><td>uncompress</td><td>解压缩文件</td><td>$ uncompress [-cfv] filename</td></tr><tr><td>tar</td><td>用于建立磁带档案（文件系统的备份）<br/> 或存到档案媒介或从档案媒介中读取文件</td><td>$ tar c|t|x [bvf] [tarfile] [bsize] [file_list]</td></tr></tbody></table><p><strong>A8 输入输出重定向</strong></p><table><thead><tr><th>命令</th><th>含义</th><th>格式</th></tr></thead><tbody><tr><td>&lt;</td><td>输入改向</td><td>$ command &lt; file</td></tr><tr><td>&gt;</td><td>输出改向，更新指定文件内容</td><td>$ command &gt; file</td></tr><tr><td>&gt;&gt;</td><td>输出改向，将执行结果接到指定文件内容后面</td><td>$ command &gt;&gt; file</td></tr></tbody></table><h3 id="B-Linux神书-—-《鸟哥的私房菜》"><a href="#B-Linux神书-—-《鸟哥的私房菜》" class="headerlink" title="B Linux神书 — 《鸟哥的私房菜》"></a>B Linux神书 — 《鸟哥的私房菜》</h3><p>在线版： <a href="http://cn.linux.vbird.org/linux_basic/linux_basic.php">传送门</a></p><p>下载版：<a href="https://pan.baidu.com/s/1O7lMeEjHkYLv2dQFgE_4tA">百度网盘</a> 提取码: uj28</p>]]></content>
      
      
      <categories>
          
          <category> 超算入门课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> command </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超算入门课程2 ssh和sftp工具的使用之mobaxterm软件教学</title>
      <link href="//supercomputer-courses-ssh-sftp-mobaxterm/"/>
      <url>//supercomputer-courses-ssh-sftp-mobaxterm/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/mobaxterm-logo.png"></p><p>本文将通过mobaxterm软件，介绍如何登陆超算以及如何传输数据。</p><span id="more"></span><h2 id="什么是SSH"><a href="#什么是SSH" class="headerlink" title="什么是SSH"></a>什么是<code>SSH</code></h2><p>官方的说法是这样子的：</p><ol><li><code>SSH</code> 为 <code>Secure Shell</code> 的缩写，</li><li><code>SSH</code> 为建立在应用层基础上的安全协议。</li><li><code>SSH</code> 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 <code>SSH</code> 协议可以有效防止远程管理过程中的信息泄露问题。</li></ol><p>我们的理解：</p><ul><li><code>SSH</code> 就是远程的命令行，敲命令的，通过它来使用登陆使用超算机器。</li></ul><p>常用的软件有：</p><ul><li><code>mobaxterm</code></li><li><code>ssh secure shell</code></li><li><code>xshell</code></li><li><code>putty</code></li><li><code>SecureCRT</code></li><li>…</li></ul><hr><h2 id="什么是FTP-SFTP"><a href="#什么是FTP-SFTP" class="headerlink" title="什么是FTP/SFTP"></a>什么是<code>FTP/SFTP</code></h2><p>官方的说法是这样子的：</p><ol><li><code>sftp</code>是<code>Secure File Transfer Protocol</code>的缩写</li><li><code>sftp</code>是安全文件传送协议。可以为传输文件提供一种安全的网络的加密方法。</li><li><code>sftp</code> 与 <code>ftp</code> 有着几乎一样的语法和功能。</li></ol><p>我们的理解：</p><ul><li>就是传文件的工具，用来实现自己的电脑和远程服务器之间文件的上传下载。</li></ul><p>常用的软件有：</p><ul><li><code>mobaxterm</code></li><li><code>Xftp</code></li><li><code>winscp</code></li><li><code>FileZilla</code></li><li>…</li></ul><hr><h2 id="什么是mobaxterm"><a href="#什么是mobaxterm" class="headerlink" title="什么是mobaxterm"></a>什么是<code>mobaxterm</code></h2><p><code>MobaXterm</code> 又名 <code>MobaXVT</code>，是一款增强型终端、X 服务器和 Unix 命令集（GNU/ cygwin）工具箱。</p><ul><li>支持各种连接 SSH，X11，RDP，VNC，FTP，MOSH</li><li>支持 Unix 命令（bash，ls，cat，sed，grep，awk，rsync，…）</li><li>连接 SSH 终端后支持 SFTP 传输文件</li><li>各种丰富的插件（git/dig/aria2…）</li><li>可运行 Windows 或软件</li></ul><p>总之，一句话：<strong>它是一个工具箱，非常强大</strong>。</p><hr><h2 id="为什么选择mobaxterm"><a href="#为什么选择mobaxterm" class="headerlink" title="为什么选择mobaxterm"></a>为什么选择<code>mobaxterm</code></h2><p>使用其他的<code>ssh</code>和<code>sftp</code>工具，经常遇到各种各样稀奇古怪的<code>bug</code>问题，不好解决，但我们发现这个软件竟然都解决了，堪称完美！</p><h3 id="每次都需要输入密码，记不住"><a href="#每次都需要输入密码，记不住" class="headerlink" title="每次都需要输入密码，记不住"></a>每次都需要输入密码，记不住</h3><p>很多ssh工具不提供记录密码的功能，所以每次都需要输入密码。有时候会忘记密码，有时候密码太长记不住，就写在一个<code>txt</code>文本文档里面，不安全。</p><p>但是mobaxterm可以自动记录密码，成功登陆后，选择<code>yes</code>即可，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/save-key.png"></p><h3 id="图形界面打不开"><a href="#图形界面打不开" class="headerlink" title="图形界面打不开"></a>图形界面打不开</h3><p>这是因为有些<code>ssh</code>工具不会自动加载图形界面所需的头文件和库的路径，所以导致error。这个软件会自动加载，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/graphic-interface.png"></p><h3 id="字符串出现乱码了，看不懂"><a href="#字符串出现乱码了，看不懂" class="headerlink" title="字符串出现乱码了，看不懂"></a>字符串出现乱码了，看不懂</h3><p>这是因为有些<code>ssh</code>工具对中文支持的并不好，所以遇到中文的时候就出现乱码了。</p><p>mobaxterm对于中文支持的很好，所以由于出现乱码，进而导致的各类问题都可以避免。</p><h3 id="修改密码时候自动退出"><a href="#修改密码时候自动退出" class="headerlink" title="修改密码时候自动退出"></a>修改密码时候自动退出</h3><p>这是因为有些<code>ssh</code>工具在修改登陆密码时候出现的bug，导致用户无法自己修改密码。只能说<code>mobaxterm</code>又可以完美支持。</p><p>说了这么多好处（其实就是以前遇到的各种坑），下面介绍一下如何安装和使用它的常用功能。</p><hr><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><blockquote><p>有的朋友反映无法下载，故在此给出我之前从官网下载过的压缩包：<a href="/doc/MobaXterm_Portable_v11.0.zip">MobaXterm_Portable_v11.0.zip 25MB</a></p></blockquote><p>非常简单，直接下载解压缩双击即可使用。</p><p>官网：<a href="https://mobaxterm.mobatek.net/">https://mobaxterm.mobatek.net</a></p><p>下载地址：<a href="https://mobaxterm.mobatek.net/download.html">https://mobaxterm.mobatek.net/download.html</a></p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/download-link.png"></p><p>直接点击免费版。</p><blockquote><p>付费版有兴趣的可以付一下，一般情况下免费版就足够了</p></blockquote><p>然后选择左侧的<code>Portable</code>版本。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/download-link-2.png"></p><blockquote><p><code>Portable</code>版本下载即用，无需安装；<code>Installer</code>版本是<code>msi</code>文件，需要安装。推荐前者。</p></blockquote><p>然后点击下载zip压缩包。</p><p>用解压缩工具（如winrar 7zip等工具）将下载好的<code>MobaXterm_Portable_v11.0.zip</code>压缩包解压缩。</p><p>我们双击<code>MobaXterm_Personal_11.0.exe</code>，就可以打开它，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/interface.png"></p><hr><h2 id="ssh登陆使用"><a href="#ssh登陆使用" class="headerlink" title="ssh登陆使用"></a>ssh登陆使用</h2><h3 id="方法1-新建ssh连接"><a href="#方法1-新建ssh连接" class="headerlink" title="方法1-新建ssh连接"></a>方法1-新建<code>ssh</code>连接</h3><center><video src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/mobaxterm-ssh-1080p.mp4" controls="controls" height="400" weight="700" >您的浏览器不支持 video 标签。</video></center><p>我们点击 <code>Session</code> 。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/new-session.png"></p><p>新建一个 <code>ssh</code> 连接。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/ssh-session.png"></p><p>输入远程服务器的ip地址（如192.168.2.5)，点击 <code>ok</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/ssh-1.png"></p><p>然后输入登陆远程服务器所需的帐户名，然后输入密码。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/input-username-and-key.png"></p><p>如果选择 <code>ok</code> ，就会自动保存密码，下次登陆无需输入，否则下次仍需要输入密码。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/save-key.png"></p><p>登陆成功：</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/login-success.png"></p><p>进阶：</p><ul><li>可以在建立<code>ssh session</code>连接的时候，勾选 <code>Specify username</code> ，输入用户名，以后每次就无需输入了。</li><li>可以在建立<code>ssh session</code>连接的时候，选择下方 <code>Bookmark settings</code> 选项卡，然后给这个新建的连接起一个名字，方便识别。</li></ul><hr><h3 id="方法2-打开已有的ssh连接"><a href="#方法2-打开已有的ssh连接" class="headerlink" title="方法2-打开已有的ssh连接"></a>方法2-打开已有的<code>ssh</code>连接</h3><p>以后再次连接，只需要<strong>双击</strong>左侧的任意一个ssh连接即可。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/ssh-3.png"></p><p>这个ssh连接已经保存了<code>ip</code>地址。</p><ul><li>如果这个ssh连接，没有保存帐户名和密码，那么输入登陆远程服务器的帐户名和密码即可。</li><li>如果这个ssh连接，保存了帐户名，没有保存密码，那么会自动登陆该账户，然后输入密码即可。</li><li>如果这个ssh连接，保存了帐户名和密码，那么直接就可以登陆成功。</li></ul><hr><h3 id="方法3-通过ssh命令建立连接"><a href="#方法3-通过ssh命令建立连接" class="headerlink" title="方法3-通过ssh命令建立连接"></a>方法3-通过ssh命令建立连接</h3><p>首先我们打开本地的命令行终端：</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/local-session.png"></p><p>然后使用<code>ssh</code>命令进行系统登陆，举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh zhenggang@192.168.2.5</span><br></pre></td></tr></table></figure><p>然后输入帐户密码即可。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/ssh-connect.png"></p><p>ssh命令说明：</p><ul><li><code>ssh</code> 同步命令</li><li><code>zhenggang@192.168.2.5:</code>  格式为：<code>用户名@ip</code><ul><li><code>zhenggang</code>为用户名</li><li><code>192.168.2.5</code>为远程服务器的<code>ip</code>地址</li></ul></li></ul><hr><h2 id="sftp数据传输"><a href="#sftp数据传输" class="headerlink" title="sftp数据传输"></a>sftp数据传输</h2><h3 id="方法1-建立ssh连接后直接拖拽"><a href="#方法1-建立ssh连接后直接拖拽" class="headerlink" title="方法1-建立ssh连接后直接拖拽"></a>方法1-建立<code>ssh</code>连接后直接拖拽</h3><p>我们在建立ssh后，可以直接通过拖拽的方式，将本地的文件拖拽到远程服务器。</p><blockquote><p>特别提示：可以将<code>mobaxterm</code>软件的窗口从最大化退出，就可以同时显示文件夹和<code>mobaxterm</code>了，方便拖拽。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/copy.png"></p><blockquote><p>特别提示：如果希望拖拽到的目标目录为<code>ssh</code>连接所在的当前目录，可以勾选下方的 <code>Follow ternimal folder</code> 这样就会自动跟随文件夹的切换了。</p></blockquote><hr><h3 id="方法2-建立sftp连接再拖拽"><a href="#方法2-建立sftp连接再拖拽" class="headerlink" title="方法2-建立sftp连接再拖拽"></a>方法2-建立<code>sftp</code>连接再拖拽</h3><center><video src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/mobaxterm-sftp-1080p.mp4" controls="controls" height="425" weight="720" >您的浏览器不支持 video 标签。</video></center><p>建立<code>sftp</code>连接的方式与建立<code>ssh</code>连接的方式非常相似，简述如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/new-session.png"></p><p>新建一个 <code>sftp</code> 连接。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/ssh-session.png"></p><p>输入远程服务器的ip地址（如192.168.2.5)，以及帐户名（必须输入），然后点击 <code>ok</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/sftp-1.png"></p><p>然后输入密码。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/sftp-key.png"></p><p>同样可以选择保存密码。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/save-key.png"></p><p>登陆成功，然后我们就可以通过窗口，鼠标拖拽的方式，上传或下载文件了。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/sftp-2.png"></p><hr><h3 id="方法3-直接使用rsync同步"><a href="#方法3-直接使用rsync同步" class="headerlink" title="方法3-直接使用rsync同步"></a>方法3-直接使用rsync同步</h3><p>此方法无需建立<code>ssh</code>或<code>sftp</code>连接，在本地的命令行终端，使用同步命令<code>rsync</code>，即可实现数据的同步。</p><p>同步到远程服务器即为上传，从远程服务器同步到本地即为下载。</p><p>首先我们打开本地的命令行终端：</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/local-session.png"></p><p>然后使用同步命令进行同步，举例如下：</p><p>我们将本地的d盘下的文件夹<code>directory</code>下的<code>1.txt</code>文件，同步到远程服务器，在命令行终端输入：</p><p>1）进入文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /media/d/directory</span><br></pre></td></tr></table></figure><p>2）同步命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -ltvP 1.txt zhenggang@192.168.2.5:/vol-th/home/zhenggang</span><br></pre></td></tr></table></figure><p>3）输入远程服务器密码</p><p>rsync命令说明：</p><ul><li><code>rsync</code> 同步命令</li><li><code>-ltvP</code> 同步参数</li><li><code>1.txt</code> 待同步的文件名，也可以是文件夹的名字</li><li><code>zhenggang@192.168.2.5:/vol-th/home/zhenggang</code>  格式为：<code>用户名@ip:目录</code><ul><li><code>zhenggang</code>为用户名</li><li><code>192.168.2.5</code>为远程服务器的<code>ip</code>地址</li><li><code>/vol-th/home/zhenggang</code>为远程服务器的目标目录</li></ul></li></ul><blockquote><p>请依据自己的同步需求自行修改相关参数，切记完全照抄，你会遇到报错的哦</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/rsync.png"></p><hr><h2 id="修改账户密码"><a href="#修改账户密码" class="headerlink" title="修改账户密码"></a>修改账户密码</h2><p>修改密码使用的命令叫做 <code>passwd</code> ， 我们只需要输入一次旧密码，再输入两次新密码即可。注意密码不要太简单。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/change-passwd.png"></p><hr><h2 id="当作linux使用"><a href="#当作linux使用" class="headerlink" title="当作linux使用"></a>当作linux使用</h2><p>mobaxterm相当于一个类linux的子系统，支持各种 Unix 命令（bash，ls，cat，sed，grep，awk，rsync，…），非常好用，熟悉<code>linux</code>的朋友可以用它做一些批量操作。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/linux.png"></p><hr><h2 id="建立开发编译环境"><a href="#建立开发编译环境" class="headerlink" title="建立开发编译环境"></a>建立开发编译环境</h2><p>比如<code>gcc</code>编译器<code>python</code>环境等，默认是没有的，但是我们可以通过操作来安装它们，并像<code>linux</code>一样使用。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/local-env-1.png"></p><p>如下图所示，里面有各种各样的包，可以直接选择并<code>install</code> ，非常简单。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/local-env-2.png"></p><p>如果发现本次配置的环境，下次登陆找不到了，可以修改一下slash的位置：</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/local-env-3.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/mobaxterm/local-env-4.png"></p>]]></content>
      
      
      <categories>
          
          <category> 超算入门课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> sftp </tag>
            
            <tag> mobaxerm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超算入门课程4 module命令使用教学</title>
      <link href="//supercomputer-courses-module/"/>
      <url>//supercomputer-courses-module/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是module"><a href="#1-什么是module" class="headerlink" title="1. 什么是module"></a>1. 什么是module</h2><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/module/module-logo.png"></p><p>Environment Modules包通过模块文件动态修改用户的环境。</p><span id="more"></span><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>module avail 或 module av</td><td>查看系统中可用的软件</td></tr><tr><td>module add 或 module load</td><td>加载模块</td></tr><tr><td>module rm 或 unload</td><td>卸载模块</td></tr><tr><td>module list 或 module li</td><td>显示已加载模块</td></tr><tr><td>module purge</td><td>卸载所有模块</td></tr><tr><td>module show</td><td>显示模块配置文件</td></tr><tr><td>module swap 或 module switch</td><td>将模块1 替换为 模块2</td></tr><tr><td>module help</td><td>查看具体软件的信息</td></tr></tbody></table><h2 id="2-module使用初级"><a href="#2-module使用初级" class="headerlink" title="2. module使用初级"></a>2. module使用初级</h2><h3 id="2-1-查看所有模块"><a href="#2-1-查看所有模块" class="headerlink" title="2.1 查看所有模块"></a>2.1 查看所有模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ module av</span><br><span class="line">------------- /usr/share/Modules/3.2.10/Applications -------------</span><br><span class="line">bedtools2/2.25.0-gcc4.8         </span><br><span class="line">bedtools2/2.26.0-gcc4.8(default)</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码中，行首为<code>$</code>符的行是用户输入的命令，其他行为显示的结果，同下。</p></blockquote><p>说明：</p><ol><li>有2个module模块</li><li>模块名称为<code>bedtools2/2.25.0-gcc4.8</code>和<code>bedtools2/2.26.0-gcc4.8</code></li><li>模块名通常的命令方式为：软件名/版本-[编译器名]-[MPI编译器名]</li><li>在 <code>bedtools2/2.26.0-gcc4.8</code>模块后面有一个<code>default</code>，表示它是<code>bedtools2</code>软件的默认版本，即只写<code>bedtools2</code> 即表示 <code>bedtools2/2.26.0-gcc4.8</code></li></ol><blockquote><p> 在平台上有数百个可用module模块，此处只列2个教学用。</p></blockquote><p><strong>加载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ module add bedtools2/2.25.0-gcc4.8</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><p>没有任何报错表明加载成功。</p><h3 id="2-2-查看已加载模块"><a href="#2-2-查看已加载模块" class="headerlink" title="2.2 查看已加载模块"></a>2.2 查看已加载模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ module li</span><br><span class="line">Currently Loaded Modulefiles:</span><br><span class="line">  1) bedtools2/2.25.0-gcc4.8</span><br></pre></td></tr></table></figure><h3 id="2-3-使用已加载模块"><a href="#2-3-使用已加载模块" class="headerlink" title="2.3 使用已加载模块"></a>2.3 使用已加载模块</h3><p>我们看到<code>bedtools2/2.25.0-gcc4.8</code>已经成功加载了，用户可以直接调用<code>bedtools2</code>软件的相关命令了，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ bedtools</span><br><span class="line">bedtools: flexible tools <span class="keyword">for</span> genome arithmetic and DNA sequence analysis.</span><br><span class="line">usage:    bedtools &lt;subcommand&gt; [options]</span><br><span class="line"></span><br><span class="line">The bedtools sub-commands include:</span><br><span class="line"></span><br><span class="line">[ Genome arithmetic ]</span><br><span class="line">    intersect     Find overlapping intervals <span class="keyword">in</span> various ways.</span><br><span class="line">    window        Find overlapping intervals within a window around an interval.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>友情提示：在超算中心使用，登陆节点与计算节点是分开的，因此请使用作业调度系统提交任务。</p></blockquote><h3 id="2-4-卸载模块"><a href="#2-4-卸载模块" class="headerlink" title="2.4 卸载模块"></a>2.4 卸载模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ module rm bedtools2/2.25.0-gcc4.8</span><br><span class="line">$ module li</span><br><span class="line">No Modulefiles Currently Loaded.</span><br></pre></td></tr></table></figure><p>到此处，我们学到了：</p><ol><li>如何查看所有的module模块 <code>module av</code></li><li>如何加载一个模块 <code>module add 模块名</code></li><li>如何查看已加载的模块 <code>module li</code></li><li>如何卸载一个模块 <code>module rm 模块名</code></li></ol><hr><h2 id="3-module使用中级"><a href="#3-module使用中级" class="headerlink" title="3. module使用中级"></a>3. module使用中级</h2><h3 id="3-1-显示模块详细信息"><a href="#3-1-显示模块详细信息" class="headerlink" title="3.1 显示模块详细信息"></a>3.1 显示模块详细信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ module show bedtools2/2.26.0-gcc4.8</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">/usr/share/Modules/Applications/bedtools2/2.26.0-gcc4.8:</span><br><span class="line"></span><br><span class="line">module-whatis    bedtools2/2.26.0-gcc4.8</span><br><span class="line">conflict         bedtools2</span><br><span class="line">prepend-path     PATH /THL6/software/bedtools2/2.26.0-gcc4.8/bin</span><br><span class="line">-------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h3 id="3-2-替换模块"><a href="#3-2-替换模块" class="headerlink" title="3.2 替换模块"></a>3.2 替换模块</h3><p>当我们加载了<code>bedtools2/2.25.0-gcc4.8</code>模块后，希望更改为<code>bedtools2/2.26.0-gcc4.8</code>模块，应该怎么做呢？</p><p>让我们先这样试一试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ module li</span><br><span class="line">Currently Loaded Modulefiles:</span><br><span class="line">  1) bedtools2/2.25.0-gcc4.8</span><br><span class="line">$ module rm  bedtools2/2.26.0-gcc4.8</span><br><span class="line">$ module add bedtools2/2.26.0-gcc4.8</span><br><span class="line">bedtools2/2.26.0-gcc4.8(25):ERROR:150: Module <span class="string">&#x27;bedtools2/2.26.0-gcc4.8&#x27;</span> </span><br><span class="line">    conflicts with the currently loaded module(s) <span class="string">&#x27;bedtools2/2.25.0-gcc4.8&#x27;</span></span><br><span class="line">bedtools2/2.26.0-gcc4.8(25):ERROR:102: Tcl <span class="built_in">command</span> execution failed: </span><br><span class="line">    conflict   bedtools2</span><br></pre></td></tr></table></figure><p>报错了！我们仔细观察这个错误<code>ERROR conflict  bedtools2</code>，想一想这是为什么？</p><p><code>bedtools2</code>软件有2个版本的，我们已经加载了一个了，要不把之前的先卸载了试试？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ module li</span><br><span class="line">Currently Loaded Modulefiles:</span><br><span class="line">  1) bedtools2/2.25.0-gcc4.8</span><br><span class="line"></span><br><span class="line">$ module rm bedtools2/2.25.0-gcc4.8</span><br><span class="line">$ module rm bedtools2/2.26.0-gcc4.8</span><br><span class="line"></span><br><span class="line">$ module li</span><br><span class="line">Currently Loaded Modulefiles:</span><br><span class="line">  1) bedtools2/2.26.0-gcc4.8</span><br></pre></td></tr></table></figure><p>成功了！因此，同类型的软件只能加载一个，加载新的之前要卸载旧的，否则就<code>conflict</code> 冲突了。</p><p>可是，更换版本是一个很常见的操作，有没有更简便的方法呢？有的，请往下看。</p><p>更简单的方法为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ module li</span><br><span class="line">Currently Loaded Modulefiles:</span><br><span class="line">  1) bedtools2/2.25.0-gcc4.8</span><br><span class="line"></span><br><span class="line">$ module swap bedtools2/2.25.0-gcc4.8 bedtools2/2.26.0-gcc4.8</span><br><span class="line"></span><br><span class="line">$ module li</span><br><span class="line">Currently Loaded Modulefiles:</span><br><span class="line">  1) bedtools2/2.26.0-gcc4.8</span><br></pre></td></tr></table></figure><p>使用<code>module swap 旧模块名 新模块名</code> 即可实现模块替换。</p><h3 id="3-3-卸载所有模块"><a href="#3-3-卸载所有模块" class="headerlink" title="3.3 卸载所有模块"></a>3.3 卸载所有模块</h3><p>当加载的模块非常多的时候，我们希望一次性都卸载了，命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ module purge</span><br><span class="line">$ module li</span><br><span class="line">No Modulefiles Currently Loaded.</span><br></pre></td></tr></table></figure><p>到此处，我们学到了：</p><ol><li>显示一个module模块的详细信息：<code>module show 模块名</code></li><li>替换一个module模块为新的module模块：<code>module swap 旧模块名 新模块名</code></li><li>一次性卸载所有已加载module模块：<code>module purge</code></li></ol><blockquote><p>注意：我们遇到过一个报错<code>ERROR conflict  bedtools2</code> ，关键词为 <code>conflict</code> 即为版本冲突，它表明 <code>bedtools2</code>  模块已经加载，如果想加载新的，需要先卸载旧的。<br>我们可以用 <code>module li</code> 看看已加载的模块，把对应的冲突模块用<code>module rm</code>卸载后，在加载新的模块。<br>我们也可以用<code>module swap</code> 来直接将旧模块替换为新的模块。</p></blockquote><hr><h2 id="4-module使用高级"><a href="#4-module使用高级" class="headerlink" title="4. module使用高级"></a>4. module使用高级</h2><h3 id="4-1-模块依赖问题-prereq"><a href="#4-1-模块依赖问题-prereq" class="headerlink" title="4.1 模块依赖问题 prereq"></a>4.1 模块依赖问题 prereq</h3><p>我们再次使用<code>module av</code>命令，查看所有可用的module模块，这次我们以<code>espresso</code>软件为例，因为它复杂一点点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ module av </span><br><span class="line">------------- /usr/share/Modules/3.2.10/Applications -------------</span><br><span class="line">espresso/5.4.0-icc16-IMPI5.1</span><br></pre></td></tr></table></figure><p>我们再来尝试加载一下<code>espresso/5.4.0-icc16-IMPI5.1</code>，输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ module add espresso/5.4.0-icc16-IMPI5.1</span><br><span class="line">espresso/5.4.0-icc16-IMPI5.1(27):ERROR:151: Module &#x27;espresso/5.4.0-icc16-IMPI5.1&#x27; </span><br><span class="line">    depends on one of the module(s) &#x27;Intel_compiler/16.0.3&#x27;</span><br><span class="line">espresso/5.4.0-icc16-IMPI5.1(27):ERROR:102: Tcl command execution failed: </span><br><span class="line">    prereq                Intel_compiler/16.0.3</span><br></pre></td></tr></table></figure><p>很遗憾，这回有信息提示，竟然是<code>ERROR prereq  Intel_compiler/16.0.3</code>，这次又是为什么呢？</p><p>我们观察这个模块的名称<code>espresso/5.4.0-icc16-IMPI5.1</code>，在第二节中我们提到过module模块的常见命名规则：软件名/版本-[编译器名]-[MPI编译器名]，因此我们分析如下：</p><ul><li>esresso 表示软件的名字</li><li>5.4.0 是软件的版本</li><li>icc16 是intel compiler的版本</li><li>IMPI5.1 是MPI编译器的版本</li></ul><p>详解：</p><blockquote><p>一款并行程序通常需要串行编译器加并行编译器来编译，然后它通过类似<code>mpirun</code>的并行执行命令来运行。如果运行过程中缺少动态库就会报错。因此，我们设置了<code>依赖</code>关系，让加载软件模块的时候，必须预先加载<code>依赖</code>的其它模块（如编译器模块等），然后再加载模块本身，以免报错。</p></blockquote><p>我们仔细观察报错中的内容：<code>prereq  Intel_compiler/16.0.3</code>，它表明<code>espresso</code>这个模块依赖于<code>Intel_compiler</code>这个模块。</p><p>我们决定先加载<code>Intel_compiler</code>，再加载<code>espresso</code>模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ module add Intel_compiler/16.0.3</span><br><span class="line">$ module add espresso/5.4.0-icc16-IMPI5.1</span><br></pre></td></tr></table></figure><p>然后我们发现，有报错了，不过报错和之前的很类似。</p><p>我们决定把<code>MPI/Intel/IMPI/5.1.3.210</code>模块也加载上，最终输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ module add Intel_compiler/16.0.3</span><br><span class="line">$ module add MPI/Intel/IMPI/5.1.3.210</span><br><span class="line">$ module add espresso/5.4.0-icc16-IMPI5.1</span><br></pre></td></tr></table></figure><p>如下图，没有任何报错，就成功了。</p><h3 id="4-2-自定义路径配置"><a href="#4-2-自定义路径配置" class="headerlink" title="4.2 自定义路径配置"></a>4.2 自定义路径配置</h3><p>用户可以通过设置 <code>MODULEPATH</code> 或者通过 <code>module</code> 命令来增加减少搜索路径。</p><p>方法1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> MODULEPATH=/path/to/new/directory:<span class="variable">$MODULEPATH</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 增加路径</span></span><br><span class="line">$ module use --append /path/to/new/directory</span><br><span class="line"><span class="comment">## 减少路径</span></span><br><span class="line">$ module unuse --append /path/to/old/directory</span><br></pre></td></tr></table></figure><blockquote><p>提别提醒：<code>MODULEPATH</code>等于号后面的值，以及<code>--append</code>后面的参数，都是实际希望增加或减少的搜索路径，不要照抄。</p></blockquote><h3 id="4-3-配置文件编写"><a href="#4-3-配置文件编写" class="headerlink" title="4.3 配置文件编写"></a>4.3 配置文件编写</h3><p>我们先来看一个标准的module配置文件模板</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#%Module1.0#####################################################################</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## modules modulefile</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## modulefiles/modules.  Generated from modules.in by configure.</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">proc ModulesHelp &#123; &#125; &#123;</span><br><span class="line">                global version prefix</span><br><span class="line"></span><br><span class="line">                puts stderr <span class="string">&quot;\tespresso/5.4.0-icc16-IMPI5.1, link with Intel_compiler/16.0.3,&quot;</span> </span><br><span class="line">                puts stderr <span class="string">&quot;MPI/Intel/IMPI/5.1.3.210&quot;</span></span><br><span class="line">                puts stderr <span class="string">&quot;\n\tAfter loading the module, you can try to use espresso&quot;</span></span><br><span class="line">                puts stderr <span class="string">&quot;\tAdds Intel compilers to your environment variables.&quot;</span></span><br><span class="line">                puts stderr <span class="string">&quot;\n\tThis adds <span class="variable">$prefix</span>/* to several of the&quot;</span></span><br><span class="line">                puts stderr <span class="string">&quot;\tenvironment variables.&quot;</span></span><br><span class="line">                puts stderr <span class="string">&quot;\n\tVersion <span class="variable">$version</span>\n&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module-whatis   <span class="string">&quot;espresso/5.4.0-icc16-IMPI5.1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for Tcl script use only</span></span><br><span class="line"><span class="built_in">set</span>     version         espresso/5.4.0-icc16-IMPI5.1</span><br><span class="line"><span class="built_in">set</span>     prefix          /home/software/espresso/5.4.0-icc16-IMPI5.1</span><br><span class="line"><span class="built_in">set</span>     exec_prefix     <span class="variable">$&#123;prefix&#125;</span></span><br><span class="line"><span class="built_in">set</span>     datarootdir     <span class="variable">$&#123;prefix&#125;</span>/share</span><br><span class="line"><span class="built_in">set</span>     INSTALL_DIR     <span class="variable">$&#123;prefix&#125;</span></span><br><span class="line"></span><br><span class="line">conflict        espresso</span><br><span class="line"></span><br><span class="line">prereq          Intel_compiler/16.0.3</span><br><span class="line">prereq          MPI/Intel/IMPI/5.1.3.210</span><br><span class="line"></span><br><span class="line">prepend-path    PATH           <span class="variable">$&#123;prefix&#125;</span>/bin</span><br><span class="line">prepend-path    LD_LIBRARY_PATH<span class="variable">$&#123;prefix&#125;</span>/lib</span><br><span class="line"></span><br><span class="line">prepend-path    LIBRARY_PATH<span class="variable">$&#123;prefix&#125;</span>/lib</span><br><span class="line">prepend-path    PKG_CONFIG_PATH<span class="variable">$&#123;prefix&#125;</span>/lib/pkgconfig</span><br><span class="line">prepend-path    C_INCLUDE_PATH<span class="variable">$&#123;prefix&#125;</span>/include</span><br><span class="line">prepend-path    CXX_INCLUDE_PATH<span class="variable">$&#123;prefix&#125;</span>/include</span><br><span class="line">prepend-path    MANPATH<span class="variable">$&#123;datarootdir&#125;</span>/man</span><br></pre></td></tr></table></figure><p>用户自己写module模块的时候，可以依照此模板进行修改。</p><p>参数说明：</p><table><thead><tr><th>参数</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>proc ModulesHelp</td><td>执行<code>module show 模块名</code>时候的反馈信息</td><td></td></tr><tr><td>set version</td><td>设置版本</td><td></td></tr><tr><td>set prefix</td><td>设置安装目录</td><td>非常关键</td></tr><tr><td>conflict</td><td>设置<code>conflict</code>报错的</td><td>这就是之前遇到<code>error</code>的原因，同下</td></tr><tr><td>prereq</td><td>用来设置依赖哪些模块的</td><td></td></tr><tr><td>prepend-path</td><td>添加一个路径到某个环境变量</td><td></td></tr><tr><td>PATH</td><td>将目录添加到<code>PATH</code>环境变量中</td><td>最常用的环境变量就是<code>PATH</code>和<code>LD_LIBRARY_PATH</code></td></tr><tr><td>LD_LIBRARY_PATH</td><td>将目录添加到<code>LD_LIBRARY_PATH</code>环境变量中</td><td></td></tr><tr><td>LIBRARY_PATH 等</td><td>与上面类似，通常运行软件命令时不需要，编译其他软件时候可能会用到</td><td></td></tr></tbody></table><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="A-安装"><a href="#A-安装" class="headerlink" title="A 安装"></a>A 安装</h3><h4 id="命令安装"><a href="#命令安装" class="headerlink" title="命令安装"></a>命令安装</h4><p>apt-get命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install environment-modules</span><br></pre></td></tr></table></figure><p>yum命令安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install environment-modules</span><br></pre></td></tr></table></figure><h4 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h4><p><strong>下载：</strong></p><p>从<code>https://sourceforge.net/projects/modules/files/</code>下载module源码，如果系统缺少tcl环境，需要额外下载安装<code>tcl</code>环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Modules-Tcl</span></span><br><span class="line">https://jaist.dl.sourceforge.net/project/modules/Modules-Tcl/modules-tcl-1.923.tar.gz</span><br><span class="line"><span class="comment"># Modules</span></span><br><span class="line">https://nchc.dl.sourceforge.net/project/modules/Modules/modules-3.2.10/modules-3.2.10.tar.gz</span><br></pre></td></tr></table></figure><p><strong>编译：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tar zxvf modules-3.2.10.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> modules-3.2.10</span><br><span class="line">$ ./configure</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure><blockquote><p>可以使用<code>--prefix</code>指定安装目录。</p></blockquote><p><strong>加载：</strong></p><p>如果使用的不是命令安装方式，而是源码方式编译到非系统默认路径，需要在使用<code>module</code>命令的时候，加载环境变量。</p><p>假如安装路径为 <code>$HOME/software</code> ，那么需要加载环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> <span class="variable">$HOME</span>/software/Modules/init/bash</span><br></pre></td></tr></table></figure><p>针对其他shell环境，如<code>csh</code>，可以加载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> <span class="variable">$HOME</span>/software/Modules/init/csh</span><br></pre></td></tr></table></figure><p>以下命令均针对<code>bash</code>环境。</p><p><strong>修改系统默认搜索路径</strong></p><p>在上面我们介绍了用户设置路径的方法，此处我们介绍如何修改系统默认的module模块搜索路径。</p><p>在安装后的<code>Modules/3.2.10/init</code>目录，打开隐藏文件，增加/删除路径实现配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim .modulespath</span><br></pre></td></tr></table></figure><blockquote><p>直接输入路径来增加搜索路径；通过<code>#</code>注释行，或直接删除行来减少搜索路径。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  @(#)$Id: 38aa24cc33a5f54a93781d63005a084f74418022 $</span></span><br><span class="line"><span class="comment">#  Module version 3.2.10</span></span><br><span class="line"><span class="comment">#  init/.modulespath.  Generated from .modulespath.in by configure.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Modulepath initial setup</span></span><br><span class="line"><span class="comment">#  ========================</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  This file defines the initial setup for the module files search path.</span></span><br><span class="line"><span class="comment">#  Comments may be added anywhere, which begin on # and continue until the</span></span><br><span class="line"><span class="comment">#     end of the line</span></span><br><span class="line"><span class="comment">#  Each line containing a single path will be added to the MODULEPATH</span></span><br><span class="line"><span class="comment">#     environment variable. You may add as many as you want - just</span></span><br><span class="line"><span class="comment">#     limited by the maximum variable size of your shell.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">/usr/share/Modules/versions                                <span class="comment"># location of version files</span></span><br><span class="line">/usr/share/Modules/<span class="variable">$MODULE_VERSION</span>/modulefiles     <span class="comment"># Module pkg modulefiles (if versioning)</span></span><br><span class="line"><span class="comment">#/usr/share/Modules/modulefiles    # Module pkg modulefiles (if no versioning)</span></span><br><span class="line">/usr/share/Modules/modulefiles                             <span class="comment"># General module files</span></span><br><span class="line"><span class="comment">#/usr/share/Modules/3.2.10/your_contribs                   # Edit for your requirements</span></span><br></pre></td></tr></table></figure><h3 id="B-常用命令列表"><a href="#B-常用命令列表" class="headerlink" title="B 常用命令列表"></a>B 常用命令列表</h3><p>表 Modules 常用命令</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>module avail 或 module av</td><td>查看系统中可用的软件</td></tr><tr><td>module add 或 module load</td><td>加载模块</td></tr><tr><td>module rm 或 unload</td><td>卸载模块</td></tr><tr><td>module list 或 module li</td><td>显示已加载模块</td></tr><tr><td>module purge</td><td>卸载所有模块</td></tr><tr><td>module show</td><td>显示模块配置文件</td></tr><tr><td>module swap 或 module switch</td><td>将模块1 替换为 模块2</td></tr><tr><td>module help</td><td>查看具体软件的信息</td></tr></tbody></table><h3 id="C-遇到报错"><a href="#C-遇到报错" class="headerlink" title="C 遇到报错"></a>C 遇到报错</h3><p>常见报错有2类：</p><p><strong>1. conflict</strong></p><p>对于<code>conflict</code>而言，通常是由于同款软件不能同时加载多个版本，因此建议卸载之前的，再加载新的。提示哪个模块冲突了就卸载哪一个。</p><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ module add bedtools2/2.26.0-gcc4.8</span><br><span class="line">bedtools2/2.26.0-gcc4.8(25):ERROR:150: Module <span class="string">&#x27;bedtools2/2.26.0-gcc4.8&#x27;</span> </span><br><span class="line">    conflicts with the currently loaded module(s) <span class="string">&#x27;bedtools2/2.25.0-gcc4.8&#x27;</span></span><br><span class="line">bedtools2/2.26.0-gcc4.8(25):ERROR:102: Tcl <span class="built_in">command</span> execution failed: </span><br><span class="line">    conflict   bedtools2</span><br></pre></td></tr></table></figure><p>我们要加载的是<code>bedtools2/2.26.0-gcc4.8</code>，但与<code>bedtools2/2.25.0-gcc4.8</code>冲突了，那么：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ module rm  bedtools2/2.25.0-gcc4.8</span><br><span class="line">$ module add bedtools2/2.26.0-gcc4.8</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><p><strong>2. prereq</strong></p><p>对于<code>prereq</code>而言，通常是加载的模块依赖其他默认，因此必须先加载依赖的模块，在加载该模块。</p><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ module add espresso/5.4.0-icc16-IMPI5.1</span><br><span class="line">espresso/5.4.0-icc16-IMPI5.1(27):ERROR:151: Module <span class="string">&#x27;espresso/5.4.0-icc16-IMPI5.1&#x27;</span> </span><br><span class="line">    depends on one of the module(s) <span class="string">&#x27;Intel_compiler/16.0.3&#x27;</span></span><br><span class="line">espresso/5.4.0-icc16-IMPI5.1(27):ERROR:102: Tcl <span class="built_in">command</span> execution failed: </span><br><span class="line">    prereq                Intel_compiler/16.0.3</span><br></pre></td></tr></table></figure><p>我们需要先加载<code>Intel_compiler/16.0.3</code>，再加载<code>espresso/5.4.0-icc16-IMPI5.1</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ module add Intel_compiler/16.0.3</span><br><span class="line">$ module add espresso/5.4.0-icc16-IMPI5.1</span><br></pre></td></tr></table></figure><p>留一个问题，以上两行命令能够加载成功吗？</p>]]></content>
      
      
      <categories>
          
          <category> 超算入门课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> module </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超算入门课程5 文本编辑器vim的使用教学</title>
      <link href="//supercomputer-courses-vim/"/>
      <url>//supercomputer-courses-vim/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vim/vim-logo.png"></p><blockquote><p>如果不会在<code>linux</code>下查看、修改文件（算例输入文件/配置文件/提交脚本），还要从<code>windows</code>下改完了上传，效率太低了！因此，让我们一起用10分钟来学习一下<code>vim</code>编辑器吧，能够大大提高工作效率。</p></blockquote><span id="more"></span><h2 id="什么是vi-vim"><a href="#什么是vi-vim" class="headerlink" title="什么是vi/vim"></a>什么是vi/vim</h2><p><code>linux</code>下我们经常需要编辑一些文本文件，比如提交任务的脚本文件，或者打开文件修改一些内容。</p><p>可是经常使用<code>windows</code>的用户第一次面对一个<code>linux</code>的<code>terminal</code>一脸懵，<code>WHAT??</code>，文件在哪？怎么打开？怎么编辑？啥都不知道。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vim/linux-terminal.png" alt="linux-terminal"></p><p>虽然，常用的linux也是带了一些图形化的文本编辑器的，比如LibreOffice，就类似一个记事本软件或者word软件。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vim/libreoffice.png" alt="图形文本软件"></p><p>但对于超算平台的用户，最为常用的还是推荐<code>vim</code>文本编辑器。在命令行输入<code>vim</code> 即可打开如下的界面：</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vim/vim-interface.png" alt="vim-interface"></p><p><code>vi</code> 编辑器是所有 <code>Unix</code> 及 <code>Linux</code> 系统下标准的编辑器，它就相当于windows系统中的记事本一样，它的强大不逊色于任何最新的文本编辑器。它是我们使用Linux系统不能缺少的工具。</p><hr><h2 id="vim使用初级"><a href="#vim使用初级" class="headerlink" title="vim使用初级"></a>vim使用初级</h2><p>比如，我们希望新建一个名为 <code>hello.txt</code> 的文件，里面记录一些内容，只需要：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim hello.txt</span><br></pre></td></tr></table></figure><p>此时，我们在当前目录下新建并打开了一个名为 <code>hello.txt</code> 的文件，里面是空的，什么都还没写呢。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vim/vim-1.png"></p><p>此时，<code>vim</code> 编辑器处于 <code>command mode</code> ，称作命令行模式吧。</p><p>我们按键盘上的小写字母 <code>i</code>，我们发现最地下出现了<code>-- INSERT -- </code>，这表明我们进入了 <code>Insert mode</code>（插入模式），可以开始输入内容了。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vim/vim-2.png"></p><p>此时，我们按键盘上的按键，就可以自由的输入了，比如输入一个<code>hello world</code>字符串吧。</p><p>输入完成后，我们按键盘上的 <code>Esc</code> 键，从插入模式退回到命令行模式。</p><p>然后我们用键盘输入 <code>:</code> 字符（就是<code>shift键+;</code>），可以发现最低端出现了一个<code>:</code>，此时我们从命令行模式进入了<code>last line mode</code>（称作末行模式吧）。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vim/vim-3.png"></p><p>然后输入字符<code>wq!</code> ，表示<code>w</code>保存+<code>q</code>退出+<code>!</code>强制，我们就把文件保存好了。此时我们用<code>cat</code>命令查看一下文件的内容吧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat hello.txt</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>到此为止，我们就初步学会了<code>vim</code>编辑器的使用。</p><p>小节：</p><ol><li><code>vim</code>的三种模式</li></ol><ul><li>命令模式（command mode）：<ul><li>控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入插入模式下，或者到末行模式。</li></ul></li><li>插入模式（Insert mode）<ul><li>只有在插入下，才可以做文字输入，按<code>Esc</code>键可回到命令行模式。</li></ul></li><li>底行模式（last line mode）<ul><li>将文件保存或退出vi；也可以设置编辑环境，如寻找字符串、列出行号……等。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vim/vim-mode.png"></p><ol start="2"><li>打开-编辑-退出</li></ol><ul><li>打开文件：<code>vim 文件名</code></li><li>插入内容：按<code>i</code>进入插入模式，插入完成后，按<code>Esc</code>退出插入模式。</li><li>保存文件：按<code>:</code>进入末行模式，输入<code>wq!</code>，然后回车，是强制保存并退出。</li></ul><hr><h2 id="vim使用中级"><a href="#vim使用中级" class="headerlink" title="vim使用中级"></a>vim使用中级</h2><p><code>vim</code>之所以强大，是因为它有非常非常多的快捷键和插件，非常厉害！我们一步一步来，此处介绍一小部分最为常用的快捷键。</p><h3 id="进入与退出"><a href="#进入与退出" class="headerlink" title="进入与退出"></a>进入与退出</h3><ul><li>进入 vi 命令格式：<code>$ vi filename</code></li><li>退出文件：<code>:q!</code> 退出不保存；<code>wq</code> 保存退出</li></ul><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><blockquote><p>要是想直接用方向键向下左右我也不拦着哈！</p></blockquote><p>我们可以通过如下快捷键来快速移动光标，熟练之后，你会觉得鼠标弱爆了。非常建议练习个10分钟把下面的掌握一下，收益终身。</p><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>↑或 k 键</td><td>把当前光标向上移动一行，保持光标的列位置。</td></tr><tr><td>↓或 j 键</td><td>把当前光标向下移动一行，保持光标的列位置。</td></tr><tr><td>→或 l 键</td><td>把当前光标向右移动一个字符。</td></tr><tr><td>←或 h 键</td><td>把当前光标向左移动一个字符。</td></tr><tr><td>$键</td><td>把当前光标移动到该行行末。</td></tr><tr><td>^键</td><td>把当前光标移动到该行行首。</td></tr><tr><td>w 键</td><td>把当前光标移动到该行的下一个字的首字符上。</td></tr><tr><td>b 键</td><td>把当前光标移动到该行的上一个字的首字符上。</td></tr><tr><td>e 键</td><td>把当前光标移动到该行的该字的末尾字符上。</td></tr><tr><td>ctrl+F</td><td>向前滚动一整屏正文。</td></tr><tr><td>ctrl+D</td><td>向下滚动半个屏正文。</td></tr><tr><td>ctrl+B</td><td>向后滚动一整屏正文。</td></tr><tr><td>ctrl+U</td><td>向上滚动半个屏正文。</td></tr></tbody></table><blockquote><p>友情提示：<br/> 1.在用 <code>k、j、h、l</code> 四个键时，可以在它们的前面加一个数字，这样在需要多次移动光标时不必多次按移动命令。<br/> 2.记住 <code>k、j、h、l</code>是上下左右，比方向键快一些。</p></blockquote><h3 id="正文常用命令"><a href="#正文常用命令" class="headerlink" title="正文常用命令"></a>正文常用命令</h3><p>在命令模式下，我们可以按一些键（如<code>a A i I o O</code>）来进入插入模式，然后输入一些内容。待输入完成，按<code>Esc</code>退出。</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>a</td><td>在光标的后面开始插入正文。</td></tr><tr><td>A</td><td>在光标所在行的行首插入正文。</td></tr><tr><td>i</td><td>在光标的前面开始插入正文。</td></tr><tr><td>I</td><td>在光标所在行的行首插入正文。</td></tr><tr><td>o</td><td>在光标所在行（当前行）的下一行的行首开始插入正文。</td></tr><tr><td>O</td><td>在光标所在行（当前行）的上一行的行首开始插入正文。</td></tr><tr><td>Esc</td><td>退出插入模式。</td></tr></tbody></table><p>这一部分，建议记住一个<code>i</code>插入就行了，然后用上一节介绍的快捷键移动光标。当然，全会更好。</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>在插入模式下，按<code>Backspace</code>键就是删除。在命令模式下，有如下快捷键：</p><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>x</td><td>x 删除当前光标所在的字符。<br/>nx 删除n个字符</td></tr><tr><td>dw</td><td>删除当前光标所在的字。<br/>ndw 删除n个字</td></tr><tr><td>dd</td><td>删除当前光标所在行。<br/>ndd删除n行</td></tr></tbody></table><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>rx</td><td>用 x 替代当前光标所在的字符。<br/>nrx 替换n个</td></tr></tbody></table><h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><blockquote><p>这个太有用了！就是撤销，就是上一步。</p></blockquote><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>u</td><td>废除最近的命令，恢复被修改或删除的内容。</td></tr><tr><td>U</td><td>把当前行恢复到修改它之前的状态。</td></tr></tbody></table><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><blockquote><p>这个也太有用了，类似windows下的<code>ctrl+f</code>的感觉。</p></blockquote><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>/pattern</td><td>在缓冲区中向下查找指定的字符串 pattern。</td></tr><tr><td>?pattern</td><td>在缓冲区中向上查找指定的字符串 pattern。</td></tr><tr><td>n</td><td>重复上一次查找命令。</td></tr><tr><td>N</td><td>以相反的查找方向重复上一次查找命令。</td></tr></tbody></table><h3 id="行编辑命令"><a href="#行编辑命令" class="headerlink" title="行编辑命令"></a>行编辑命令</h3><p>键入<code>:</code>，进入末行模式，并在屏幕底部的<code>:</code>号提示符下输入行编辑命令。</p><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>set nu</td><td>显示正文的行号。</td></tr><tr><td>set nonu</td><td>取消行号。</td></tr><tr><td>1,$p</td><td>显示缓冲区的整个内容。</td></tr><tr><td>r wqb</td><td>将文件 wqb 中的内容读入缓冲区，插入当前光标下。</td></tr><tr><td>1,5w clh</td><td>将正文中 1 到 5 行的内容写到名为 clh 的文件中去。</td></tr><tr><td>2,5d</td><td>将正文中 2 到 5 行删除。</td></tr><tr><td>2,5t8</td><td>将正文中 2 到 5 行复制到第 8 行的后面。</td></tr><tr><td>! ls</td><td>暂时转出 vi 编辑器，执行 shell 命令 ls。</td></tr><tr><td>sh</td><td>暂时转出 vi 编辑器, 执行 shell 命令,键入ctrl+D 或 exit 返回正文。</td></tr></tbody></table><hr><h2 id="vim使用高级"><a href="#vim使用高级" class="headerlink" title="vim使用高级"></a>vim使用高级</h2><h3 id="vim配置文件"><a href="#vim配置文件" class="headerlink" title="vim配置文件"></a>vim配置文件</h3><p>我们可以通过修改<code>vim</code>的默认配置文件，来修改用<code>vim</code>打开文件时候的默认配置，举一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.vimrc</span><br></pre></td></tr></table></figure><p>打开配置文件，写入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> nu</span><br></pre></td></tr></table></figure><p>如下图所示，然后保存退出。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vim/vim-4.png"></p><p>再次用<code>vim</code>打开<code>hello.txt</code>文件，我们可以看到这次默认带了行号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim hello.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vim/vim-5.png"></p><p>因此，我们可以依据它的常用配置文件，来修改成自己喜欢的默认打开样式，喜欢的样式自行百度搜索吧，我举一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> nocompatible</span><br><span class="line"><span class="built_in">set</span> nu</span><br><span class="line">filetype on </span><br><span class="line"><span class="built_in">set</span> <span class="built_in">history</span>=1000 </span><br><span class="line"><span class="built_in">set</span> background=dark </span><br><span class="line">syntax on </span><br><span class="line"><span class="built_in">set</span> autoindent</span><br><span class="line"><span class="built_in">set</span> smartindent</span><br><span class="line"><span class="built_in">set</span> tabstop=4</span><br><span class="line"><span class="built_in">set</span> shiftwidth=4</span><br><span class="line"><span class="built_in">set</span> showmatch</span><br><span class="line"><span class="built_in">set</span> guioptions-=T</span><br><span class="line"><span class="built_in">set</span> vb t_vb=</span><br><span class="line"><span class="built_in">set</span> ruler</span><br><span class="line"><span class="built_in">set</span> nohls</span><br><span class="line"><span class="built_in">set</span> incsearch</span><br><span class="line"><span class="keyword">if</span> has(<span class="string">&quot;vms&quot;</span>)</span><br><span class="line"><span class="built_in">set</span> nobackup</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">set</span> backup</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure><blockquote><p>这个配置文件来自：<a href="https://www.cnblogs.com/wuyudong/p/3981410.html">https://www.cnblogs.com/wuyudong/p/3981410.html</a></p></blockquote><h3 id="vim插件"><a href="#vim插件" class="headerlink" title="vim插件"></a>vim插件</h3><p><code>vim</code>可以安装非常多的插件，来打造成一个强大的<code>IDE</code>，自己百度吧。</p><p>推荐阅读：</p><ol><li><a href="http://www.open-open.com/lib/view/open1414227253419.html">Vim十大必备插件</a></li><li><a href="https://www.cnblogs.com/linuxprobe/p/5926821.html">10款优秀Vim插件帮你打造完美IDE</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 超算入门课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超算入门课程6 slurm作业管理系统使用教学</title>
      <link href="//supercomputer-courses-slurm/"/>
      <url>//supercomputer-courses-slurm/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是slurm"><a href="#1-什么是slurm" class="headerlink" title="1. 什么是slurm ?"></a>1. 什么是slurm ?</h2><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/slurm/slurm-logo.png"></p><p>官方说明：</p><blockquote><p>Slurm 是一个开源、容错、高可伸缩的集群管理和大型小型 Linux 集群作业调度系统。slurm不需要对操作系统内核进行修改，而是相对独立的。 </p></blockquote><span id="more"></span><p>用户理解：</p><blockquote><p>超算集群不能在登陆节点计算任务，需要提交到计算节点，怎么提交呢？用作业管理系统提交。<code>slurm</code>就是其中一种。</p></blockquote><p>下面介绍如何使用slurm。</p><h2 id="2-slurm使用初级"><a href="#2-slurm使用初级" class="headerlink" title="2. slurm使用初级"></a>2. slurm使用初级</h2><h3 id="查看可用节点-yhi"><a href="#查看可用节点-yhi" class="headerlink" title="查看可用节点 yhi"></a>查看可用节点 yhi</h3><p>查看可用计算节点信息的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ yhi</span><br><span class="line">PARTITION AVAIL  TIMELIMIT   NODES  STATE  NODELIST</span><br><span class="line">debug        up      30:00     100  drain  cn[1-100]</span><br><span class="line">debug        up      30:00     100  alloc  cn[101-200]</span><br><span class="line">debug        up      30:00     100  idle   cn[200-300]</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码中，行首为<code>$</code>符的行是用户输入的命令，其他行为显示的结果，同下。</p></blockquote><p>说明：</p><table><thead><tr><th>关键词</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>PARTITION</td><td>分区名</td><td>-p 分区名来指定分区</td></tr><tr><td>AVAIL</td><td>可用状态</td><td>up 可用<br/>down 不可用</td></tr><tr><td>TIMELIMIT</td><td>该分区的作业最大运行时长限制</td><td>30:00 表示30分钟<br/>2-00:00:00表示2天<br/>infinite表示不限时间</td></tr><tr><td>NODES</td><td>节点的数量</td><td>-N 数字 来指定节点数量</td></tr><tr><td>STATE</td><td>节点的状态</td><td>drain: 排空状态，表示该类结点不再分配到其他<br/>idle: 空闲状态<br/>alloc: 被分配状态</td></tr></tbody></table><p>通过查看系统可用资源情况，我们就知道了要将计算任务提交到那里了，比如例子中的debug计算分区。</p><h3 id="提交作业"><a href="#提交作业" class="headerlink" title="提交作业"></a>提交作业</h3><p>接下来应该就是使用slurm作业管理系统进行作业提交了，常用的提交方式有2种，分别介绍如下：</p><h4 id="yhrun-提交"><a href="#yhrun-提交" class="headerlink" title="yhrun 提交"></a>yhrun 提交</h4><p>在命令行终端直接执行yhrun命令进行作业提交计算：</p><p>天河系统的相应命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yhrun -N 2 -n 24 -p debug executable [args...]</span><br></pre></td></tr></table></figure><blockquote><p><strong>疑问：</strong><code>-N</code>与<code>-n</code>两个参数是什么关系？<br/><br><strong>解答：</strong><code>-N</code>是总节点数，<code>-n</code>是总核数。以TH-1A集群为例，一个节点有12个核。<br/><br>当 <code>N*12 &gt;= n</code>时，任务可以成功运行，并且占用了节点的全部核数，推荐使用；<br/><br>当 <code>N*12 &lt; n</code> 时，由于无法满足这种节点数和核数的组合，会提示报错如下：<code>yhbatch: error: Batch job submission failed: Requested node configuration is not available</code></p></blockquote><p>参数说明如下：</p><table><thead><tr><th>关键词</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>yhrun</td><td>并行执行程序的命令</td><td>类似于通用的<code>mpirun</code>命令</td></tr><tr><td>-N</td><td>总节点数</td><td>-N 2 表示用2个计算节点</td></tr><tr><td>-n</td><td>总核数</td><td>-n 24 表示一共用24个cpu核心，注意是总数，而不是每个节点的核数</td></tr><tr><td>-p</td><td>计算分区</td><td>-p debug 表示用debug计算分区，可以用<code>yhi</code>命令查询可用分区</td></tr><tr><td>executable</td><td>可执行程序名称</td><td>就是你要运行的程序的名字</td></tr><tr><td>[args…]</td><td>执行参数</td><td>有的程序需要加参数，就写在后面</td></tr></tbody></table><blockquote><p><code>yhrun</code>运行的程序，默认会将输出显示到屏幕上，而且当前终端断掉会导致任务退出，因此推荐用下面的<code>yhbatch</code>命令提交任务。</p></blockquote><h4 id="yhbatch提交"><a href="#yhbatch提交" class="headerlink" title="yhbatch提交"></a>yhbatch提交</h4><p>这种方式是最为推荐的方式，先编写一个脚本（别担心，很简单），然后用提交命令提交这个脚本即可。</p><p><strong>1）编写脚本</strong></p><p>使用文本编辑器（例如vim等），创建一个用于提交作业的脚本文件，例如名为<strong>sub.sh</strong>的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim sub.sh</span><br></pre></td></tr></table></figure><p>然后写入脚本内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">yhrun -N 2 -n 24 -p debug executable [args...]</span><br></pre></td></tr></table></figure><p>里面写的内容和<code>yhrun</code>提交方式的内容完全相同。</p><p><strong>2）提交脚本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yhbatch -N 2 -n 24 -p debug sub.sh</span><br><span class="line">Submitted batch job 1454916</span><br></pre></td></tr></table></figure><p>成功提交后，返回<code>Submitted batch job 1454916</code>，这一串数字就是该任务的<code>JOBID</code>。</p><blockquote><p><strong>疑问：</strong><code>yhbatch</code>和<code>yhrun</code>都指定了<code>-N -n</code>参数，哪个会起作用呢？<br/><br><strong>解答：</strong>当我们使用<code>yhbatch</code>提交一个任务时，首先会向作业管理系统申请指定分区指定节点数的计算资源（当核数与节点数不匹配时会报错，<code>yhrun</code>的部分已经解释过）<br/>当获得了计算资源后，任务脚本会在计算节点执行。<br/><br>当<code>yhrun运行需要的计算资源</code> <code>&lt;=</code> <code>yhbatch申请的计算资源</code>时，程序可以正常运行；<br/><br>当<code>yhrun运行需要的计算资源</code> <code>&gt;</code> <code>yhbatch申请的计算资源</code>时，程序就会报错退出，在<code>slurm-jobid.out</code>文件中显示类似报错;<br/></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yhrun: error: Only allocated 1 nodes asked <span class="keyword">for</span> 2</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><table><thead><tr><th>关键词</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>yhbatch</td><td>提交批处理脚本的命令</td><td></td></tr><tr><td>-N</td><td>总节点数</td><td>-N 2 表示用2个计算节点</td></tr><tr><td>-n</td><td>总核数</td><td>-n 24 表示一共用24个cpu核心</td></tr><tr><td>-p</td><td>计算分区</td><td>-p debug 表示用debug计算分区</td></tr><tr><td>sub.sh</td><td>提交脚本名</td><td>可以依据任务不同编写其他名称的脚本文件</td></tr></tbody></table><blockquote><p>优势：使用这种方式提交的任务，会自动生成一个名为<code>slurm-jobid.out</code>的文件，其中<code>jobid</code>是slurm分配给这个任务的具体编号数字。里面会有除了程序特殊指定，或用户重定向以外的所有作业的标准输出和错误信息。当计算任务出现错误的时候，我们也是第一时间查看该文件，寻找原因。</p></blockquote><h3 id="查看任务状态"><a href="#查看任务状态" class="headerlink" title="查看任务状态"></a>查看任务状态</h3><p>如果我们想查看一下当前用户的作业状态，可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yhq</span><br><span class="line">JOBID    PARTITION  NAME     USER       ST  TIME      NODES NODELIST(REASON)</span><br><span class="line">1454916  debug      sub.sh   zhenggang  R   00:05:00  2     cn[5-6]</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><table><thead><tr><th>关键词</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>JOBID</td><td>任务编号</td><td>唯一编号，方便追溯</td></tr><tr><td>PARTITION</td><td>计算分区名</td><td>可用<code>yhi</code>查询</td></tr><tr><td>NAME</td><td>任务名</td><td>默认以提交脚本的名称当作任务名</td></tr><tr><td>USER</td><td>用户名</td><td>提交该任务的用户名</td></tr><tr><td>ST</td><td>任务状态</td><td>PD排队<br/>R运行<br/>S挂起<br/>CG正在退出</td></tr><tr><td>TIME</td><td>任务运行时间</td><td>例子中为5分钟</td></tr><tr><td>NODES</td><td>任务作占节点数</td><td>例子中为1个</td></tr><tr><td>NODELIST(REASON)</td><td>节点列表（排队原因）</td><td>如果是排队状态的任务，则会给出排队原因</td></tr></tbody></table><p>备注常见排队原因：</p><blockquote><ul><li>AssociationResourceLimit：关联的资源限制已满 — 账户有使用节点数限制，已经用满了</li><li>Resources：当前可用资源不能满足作业需求 — 系统的可用节点资源不足</li><li>Dependency：作业的依赖关系未满足 — 作业之间有依赖关系，依赖的作业没完成</li><li>PartitionDown：作业所在的分区处于 down 状态 — 分区down，所以节点不可用</li></ul></blockquote><h3 id="任务完成-取消作业"><a href="#任务完成-取消作业" class="headerlink" title="任务完成/取消作业"></a>任务完成/取消作业</h3><p>如果提交作业后，如果正常结束，那么在<code>slurm-jobid.out</code>文件中并不会有任务的报错信息。</p><p>如果任务正在运行，发现需要将它取消，可以这样子：</p><p>1）确定任务编号</p><p>我们用<code>yhq</code>命令查看任务编号，比如为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yhq</span><br><span class="line">JOBID    PARTITION  NAME     USER       ST  TIME      NODES NODELIST(REASON)</span><br><span class="line">1454916  debug      sub.sh   zhenggang  R   00:15:00  2     cn[5-6]</span><br></pre></td></tr></table></figure><p>2）取消任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yhcancel 1454916</span><br></pre></td></tr></table></figure><h2 id="2-slurm使用中级"><a href="#2-slurm使用中级" class="headerlink" title="2. slurm使用中级"></a>2. slurm使用中级</h2><p>用户常用的功能，其实大部分是<code>yhrun/yhbatch</code>的其他参数，举例如下：</p><h3 id="设置线程数"><a href="#设置线程数" class="headerlink" title="设置线程数"></a>设置线程数</h3><p>默认情况下，一个MPI进程开启一个线程，当程序为多线程程序的时候，可以手动设置线程数：</p><p>方法一：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> OMP_NUM_THREADS=4</span><br></pre></td></tr></table></figure><p>通过环境变量参数设置线程数为4。</p><p>方法二：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yhrun -N 2 -n 8 -c 4 -p debug executable [args...]</span><br></pre></td></tr></table></figure><p>通过<code>yhrun -c 4</code>设置线程数为4。</p><h3 id="设置工作目录"><a href="#设置工作目录" class="headerlink" title="设置工作目录"></a>设置工作目录</h3><p>默认情况下，执行<code>yhbatch</code>命令的目录就是任务的默认目录。</p><p>如果希望修改任务的默认目录，可以使用<code>-D</code>参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yhbatch -D /path/to/new/directory -N 2 -n24 -p debug sub.sh</span><br></pre></td></tr></table></figure><blockquote><p>/path/to/new/directory 表示一个新的目录</p></blockquote><h3 id="指定节点"><a href="#指定节点" class="headerlink" title="指定节点"></a>指定节点</h3><p>我们可以用<code>-w</code>参数来指定任务使用哪些节点，可以用<code>-x</code>参数指定任务不使用哪些节点。</p><p>通常使用<code>-x</code>的场景为，当任务在某个节点报错退出后，如果怀疑该节点有问题，可以先用<code>-x</code>参数过滤掉该节点，重新提交任务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yhbatch -w cn10 -N 2 -n24 -p debug sub.sh</span><br><span class="line">$ yhbatch -x cn11 -N 2 -n24 -p debug sub.sh</span><br></pre></td></tr></table></figure><h3 id="指定任务名"><a href="#指定任务名" class="headerlink" title="指定任务名"></a>指定任务名</h3><p>当用户需要提交非常多的相似任务时，通常只会将提交脚本中的参数进行修改，但这样子提交的任务的任务名都相同，不好区分。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JOBID    PARTITION  NAME     USER       ST  TIME      NODES NODELIST(REASON)</span><br><span class="line">1454916  debug      sub.sh   zhenggang  R   00:15:00  2     cn[5-6]</span><br><span class="line">1454917  debug      sub.sh   zhenggang  R   00:15:00  2     cn[7-8]</span><br><span class="line">1454918  debug      sub.sh   zhenggang  R   00:15:00  2     cn[9-10]</span><br></pre></td></tr></table></figure><p>我们可以用<code>-J</code>参数为每一个任务指定任务名，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ yhbatch -J job1 -N 2 -n24 -p debug sub.sh</span><br><span class="line">Submitted batch job 1454920</span><br><span class="line">$ yhbatch -J job2 -N 2 -n24 -p debug sub.sh</span><br><span class="line">Submitted batch job 1454921</span><br><span class="line">$ yhbatch -J job3 -N 2 -n24 -p debug sub.sh</span><br><span class="line">Submitted batch job 1454922</span><br><span class="line">$ yhq</span><br><span class="line">JOBID    PARTITION  NAME     USER       ST  TIME      NODES NODELIST(REASON)</span><br><span class="line">1454920  debug      job1     zhenggang  R   00:00:05  2     cn[15-16]</span><br><span class="line">1454921  debug      job2     zhenggang  R   00:00:05  2     cn[17-18]</span><br><span class="line">1454922  debug      job3     zhenggang  R   00:00:05  2     cn[19-20]</span><br></pre></td></tr></table></figure><h3 id="任务运行时常"><a href="#任务运行时常" class="headerlink" title="任务运行时常"></a>任务运行时常</h3><p>默认情况下，任务会一直运行直到任务结束；在超算集群上，通常的计算分区都有设置最大运行时常，当超出时常后任务会自动退出，<code>slurm-jobid.out</code>文件报错类似：<code>Error: DUE TO TIME LIMIT</code></p><p>用户也可以用<code>-t</code>参数设置该任务的最大运行时常，时间单位为分钟，如设置为10分钟（即为<code>-t 10</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yhbatch -t 10 -N 2 -n 24 -p debug sub.sh</span><br></pre></td></tr></table></figure><h2 id="3-slurm使用高级"><a href="#3-slurm使用高级" class="headerlink" title="3. slurm使用高级"></a>3. slurm使用高级</h2><h3 id="yhalloc方式使用"><a href="#yhalloc方式使用" class="headerlink" title="yhalloc方式使用"></a>yhalloc方式使用</h3><p>除了<code>yhrun</code>和<code>yhbatch</code>，还有一个命令叫做<code>yhalloc</code>，适用于调试程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ yhballoc -N 2 -n 24 -pdebug</span><br><span class="line">yhalloc: Granted job allocation 1455031</span><br><span class="line"></span><br><span class="line">$ yhq</span><br><span class="line">  JOBID PARTITION     NAME     USER  ST       TIME  NODES NODELIST(REASON)</span><br><span class="line">1455031    debug      bash zhenggang  R       0:44      2 cn[31-32]</span><br></pre></td></tr></table></figure><p>我们接下来可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yhrun -N 2 -n24 -pdebug executable [args...]</span><br></pre></td></tr></table></figure><p>任务会在刚刚分配的cn[31-32]节点运行。</p><p>我们也可以用<code>ssh</code>命令切换到计算节点，进行各种操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh cn32</span><br><span class="line">Last login: Tue Dec 18 08:58:40 2018 from ln0</span><br></pre></td></tr></table></figure><blockquote><p>注意：用yhalloc申请的节点会在当前终端退出时释放掉，因此仅适用于高阶玩家调试用。</p></blockquote><h3 id="设置任务依赖"><a href="#设置任务依赖" class="headerlink" title="设置任务依赖"></a>设置任务依赖</h3><p>有时候任务1与任务2有点关系，我们希望等任务1结束后再运行任务2。</p><p>如果将任务1和任务2都提交了，它们之间没人关系，会再获得计算资源后都运行，这不是我们想要的。</p><p>因此，我们可以正常提交任务1，然后在提交任务2的时候，使用<code>-d jobid</code>参数设置依赖关系，让任务2等待任务1结束后再运行，即便有计算资源也等着。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ yhbatch -N 2 -n 24 -p debug sub1.sh</span><br><span class="line">Submitted batch job 1454946</span><br><span class="line">$ yhbatch -d 1454946 -N 2 -n 24 -p debug sub2.sh</span><br><span class="line">Submitted batch job 1454947</span><br><span class="line">$ yhq</span><br><span class="line">  JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON)</span><br><span class="line">1454947    debug   sub2.sh zhenggang PD       0:00      1 (Dependency)</span><br><span class="line">1454946    debug   sub1.sh zhenggang  R       0:37      1 cn46</span><br></pre></td></tr></table></figure><p>我们可以看到先提交的任务<code>1454946</code>已经在<code>R</code>，后提交的任务<code>1454947</code>在<code>PD</code>，原因是<code>Dependency</code>，这意味着它将等待<code>1454946</code>任务结束后才开始运行。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="slurm内置环境变量"><a href="#slurm内置环境变量" class="headerlink" title="slurm内置环境变量"></a>slurm内置环境变量</h3><p>slurm有很多内置的环境变量，可以在提交脚本中使用，来显示各类信息：</p><table><thead><tr><th>内置变量</th><th>含义</th></tr></thead><tbody><tr><td>SLURM_NODELIST</td><td>分配的节点列表</td></tr><tr><td>SLURM_NNODES</td><td>分配的任务数</td></tr><tr><td>SLURM_NPROCS</td><td>要加载的任务数</td></tr><tr><td>SLURM_JOBID</td><td>作业的 JobID</td></tr><tr><td>SLURM_TASKS_PER_NODE</td><td>每节点要加载的任务数</td></tr><tr><td>SLURM_JOB_ID</td><td>作业的 JobID</td></tr><tr><td>SLURM_SUBMIT_DIR</td><td>提交作业时的工作目录</td></tr><tr><td>SLURM_JOB_NODELIST</td><td>作业分配的节点列表</td></tr><tr><td>SLURM_JOB_CPUS_PER_NODE</td><td>每个节点上分配给作业的 CPU 数</td></tr><tr><td>SLURM_JOB_NUM_NODES</td><td>作业分配的节点数</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 超算入门课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> slurm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超算入门课程1 VPN登陆使用</title>
      <link href="//supercomputer-courses-vpn/"/>
      <url>//supercomputer-courses-vpn/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vpn/vpn-logo.png"></p><h2 id="什么是VPN"><a href="#什么是VPN" class="headerlink" title="什么是VPN"></a>什么是VPN</h2><p>虚拟专网(VPN-Virtual Private Network)指的是在公用网络上建立专用网络的技术。</p><span id="more"></span><blockquote><p>简单地说，VPN创建了一个安全的、加密的连接(可以认为是一个隧道)，连接在您的计算机和由VPN服务操作的服务器之间。在专业环境下，这条通道有效地让你成为公司网络的一部分，就好像你坐在办公室里一样。</p></blockquote><h2 id="VPN登陆"><a href="#VPN登陆" class="headerlink" title="VPN登陆"></a>VPN登陆</h2><h3 id="VPN网址"><a href="#VPN网址" class="headerlink" title="VPN网址"></a>VPN网址</h3><p>TH-1A系统的VPN网址：</p><table><thead><tr><th>运营商</th><th>网址</th></tr></thead><tbody><tr><td>联通</td><td><a href="https://thvpn.nscc-tj.cn/">https://thvpn.nscc-tj.cn</a></td></tr><tr><td>电信</td><td><a href="https://thvpn1.nscc-tj.cn/">https://thvpn1.nscc-tj.cn</a></td></tr></tbody></table><blockquote><p>百度搜索，输入 <code>ip</code> 即可获得当前的ip地址和网络运营商。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vpn/ip.png"></p><h3 id="初次登陆VPN"><a href="#初次登陆VPN" class="headerlink" title="初次登陆VPN"></a>初次登陆VPN</h3><p>其实，输入网址，再输入用户名和密码就ok了，如果提示下载安装插件，就允许。做了一个小动画分享给大家。</p><center><video src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vpn/vpn-windows.mp4" controls="controls" height="400" weight="700" >您的浏览器不支持 video 标签。</video></center><blockquote><p>该方法适用于各类操作系统，如果是Linux64位操作系统，请下载专用VPN脚本<a href="https://pan.baidu.com/s/1LpvarnVTxZY9F4FiO-qRIw">install_vpn_linux_x86.sh</a>，提取码：1j8z <br/></p></blockquote><blockquote><p>手机端也可以登陆VPN，登陆方法可以参考：<a href="https://pan.baidu.com/s/1cohDBaSCZdLte7PVILxp6w">EasyConnect-移动端登陆.pdf</a> ，提取码：vykc </p></blockquote><h3 id="再次登陆VPN"><a href="#再次登陆VPN" class="headerlink" title="再次登陆VPN"></a>再次登陆VPN</h3><p>可以通过浏览器，输入网址，再输入用户名和密码即可。和初次登陆不同，这一次不需要安装插件，因为第一次已经安装好了。</p><p>我们更推荐下面这种：</p><blockquote><p>通过开始菜单，搜索并打开”Easy Connect”（通常输入easy就够了），输入用户名和密码，点击登陆即可。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vpn/easyconnect-1.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vpn/easyconnect-2.png"></p><h2 id="3-vpn修复"><a href="#3-vpn修复" class="headerlink" title="3. vpn修复"></a>3. vpn修复</h2><p>如果遇到VPN无法登陆的情况，昨天还好好的，今天就不行了，我啥也没改啊，怎么办？？</p><p>推荐使用修复工具：</p><p><a href="http://download.sangfor.com.cn/download/product/sslvpn/SangforHelperToolInstaller.exe">SSL VPN Windows环境诊断修复工具，一键检测电脑插件问题</a></p><p>详细介绍可以参考：<a href="http://blog.mrzhenggang.com/vpn-sangforhelpertoolinstaller/">http://blog.mrzhenggang.com/vpn-sangforhelpertoolinstaller/</a></p>]]></content>
      
      
      <categories>
          
          <category> 超算入门课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vpn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超算入门课程0 致敬“银河•天河”40年超级计算奋进征途</title>
      <link href="//supercomputer-courses-history-40-years/"/>
      <url>//supercomputer-courses-history-40-years/</url>
      
        <content type="html"><![CDATA[<p>致敬“银河•天河”40年超级计算奋进征途——攻坚，攀登，创新，引领</p><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/history/tianhe.png"></p><blockquote><p>“中国人要搞四个现代化，不能没有巨型机。”自1978年邓小平同志在全国科技大会上批准搞中国人自己的超级计算机，40年过去了。这40年间，中国从研制出第一台每秒亿次计算的“银河-Ⅰ”巨型机实现“零”的突破，到“天河一号”超级计算机问鼎首个世界第一，再到“天河二号”连摘TOP500六次桂冠，中国超级计算走过了从“跟跑”到逐步迈上“领跑”的漫漫征途，这是改革开放以来，我国科技发展从艰辛到辉煌的一个缩影。 “银河”、“天河”系列超级计算机是中国数十年持续创新突破的代表。在国防科大与合作团队几十年的持续攻关过程中，我国全面掌握了超级计算机研制的“五大”自主核心技术，具备了自主芯片、自主操作系统、互联通信系统等核心产品的研制能力和产业化应用能力，并且催生了高性能计算为龙头，高性能微处理器与微电子、网络与通信、自主基础软件和信息安全等优势方向共同发展的创新体系，引领中国超算事业稳步向前。伴随着超级计算机的研制，我国超级计算应用同步发展，超级计算不仅带动着国家信息产业发展，并与大数据、人工智能等新兴领域息息相关，推动国家创新驱动发展，在我国建设创新型国家的战略与实践中占据了重要地位。</p></blockquote><h2 id="奋斗篇：从“零”到“夺冠”"><a href="#奋斗篇：从“零”到“夺冠”" class="headerlink" title="奋斗篇：从“零”到“夺冠”"></a>奋斗篇：从“零”到“夺冠”</h2><p>可以说，“银河”系列巨型机的诞生是中国人面对国际封锁、打压自强不息的结果。</p><p>改革开放初期，我国计算机专业技术人才奇缺、国产元器件落后，信息技术发展缓慢，“落后就要挨打”，在中国还没有自己的巨型机的岁月，外国提出，即使将巨型机卖给中国，也要把机器放在独立的机房里面，由他们管理和监控，中国科研人员不准进入，只能在玻璃窗户外面看着，这相当于外国人在新中国的土地上建立起了一块“技术殖民地”。</p><p>1978年，邓小平高瞻远瞩，决定立即上马巨型计算机研制工程，并把任务交给国防科大。时任国防科大计算机研究所所长的慈云桂时下已60岁高龄，他立下军令状：“就是豁出我这条老命，也一定要把我们自己的巨型机搞出来！”由于当时我们的技术基础、生产工艺等都与先进国家存在巨大差距，甚至空白，要把当时中国计算机每秒速度提升到一亿次，困难重重。而五年后，研发团队突破关键技术、完成整体设计，把整机系统的250万个焊点一个个焊起来，“银河-Ⅰ”巨型计算机最终研制成功，这宣告着中国成为了继美、日之后，世界上仅有的独立设计和制造亿次巨型机的国家。</p><p>为了紧跟飞速增长的现代化建设需求，上世纪九十年代，国防科大又接连成功研制“银河-Ⅱ”、“银河-Ⅲ”巨型机，性能持续得到大幅提升，而老一代的“银河”团队元勋，却一位位倒在了科研一线。这是一种“银河精神”，一种“胸怀祖国、团结协作、志在高峰、奋勇拼搏”的品质境界。在强烈的民族使命感中，“银河”团队打破了外国的垄断，奠定了我国在巨型机研制领域的国际地位。</p><p>追赶不易，引领更难，但中国人不可能永远跟在西方发达国家后面亦步亦趋。2008年6月，IBM“走鹃”亮相，把世界超级计算机的速度从百万亿次带入了千万亿次。仅一年半以后，2010年11月，“天河一号”以每秒4700万亿次的峰值速度和每秒2566万亿次的Linpack实测性能夺得世界TOP500排名的榜首，取得了我国自主研制超级计算机综合技术水平进入世界领先行列的历史性突破。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/history/group.png"></p><center>“银河·天河”发展征程</center><p>但是“第一”的光环还没闪亮，国内外质疑“天河”中看不中用，就是只为排世界第一的声音却接踵而至。为了让“天河一号”成为实实在在的“国之重器”，“天河”人坚持“5+2”“白+黑”、“把板凳坐穿，把鞋底磨穿”的奋斗传统，把“天河一号”的应用做到“顶天”支撑国家前沿基础创新、“立地”服务传统产业升级和培育新兴产业发展，做到世界认可。当天津“8.12”事故发生，人们纷纷撤离的时候，天河团队却逆向行驶，回到处于核心爆炸区的工作岗位，重新开启“天河一号”系统，经历新时代血与火的考验，凝聚新时代“天河”精神。</p><p>就在外界认为中国的成功不过是昙花一现时，“天河二号”再次以大幅进步摘夺了TOP500“六连冠”，峰值性能54.9Pflops，实测性能33.9Pflops，实现了从千万亿次到亿亿次的技术跨越。</p><p>现在，我国在“天河”系列超级计算机上获得的成功不是偶然，也不是一朝一夕的结果，而是来自一个具有“银河精神”的团队，历经漫长的摸索与发现、试错和重新出发，突破数不清的困难换来的。这样的努力与付出并不是单单为了夺冠，而是为了走出我国自主创新的科研之路，为了我国的超级计算技术不再受制于人。</p><h2 id="创新篇：勇攀科研高峰"><a href="#创新篇：勇攀科研高峰" class="headerlink" title="创新篇：勇攀科研高峰"></a>创新篇：勇攀科研高峰</h2><p>超级计算领域激烈的竞争背后是国家综合实力的较量，“天河”系列超级计算机之所以能够在世界舞台上发光，源自于一代代“银河”工程中对中国的技术与人才的磨砺，是我们在大规模集成电路芯片、结点机、操作系统、编译系统、通讯网络等超级计算机核心技术上进行的长期探索与创新积累的结果。</p><p>CPU+GPU异构融合体系创新思路是我国超级计算机研制团队做出的大胆尝试。早在2005年研制30万亿次机时，研制团队就意识到，世界超级计算机研制的CPU并行处理主流技术已面临障碍，必须探索新的体系结构。CPU并行处理体系结构的最大局限在于CPU造价高、能耗高、系统规模大，于是他们把目光转向流处理器和新的体系结构。沿着这一崭新的思路，团队创造新的提出了“CPU+GPU”的异构融合系统结构理论。异构体系结构设计的难点在于如何实现预想的运行速度、效率和节能水平。当使用了“CPU+GPU”异构融合系统的“天河一号”走上世界舞台上时，证明这条路选对了，异构融合体系这一中国人独创的结构很快走向了世界，为千万亿次、亿亿次等超级计算机体系结构设计带来了新的思路，引领世界超级计算体系结构发展新的技术潮流。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/history/certificate.png"></p><center>“天河一号”与世界第一证书 </center><p>让中国的超级计算拥有一颗“中国芯”，是中国超算人多年的梦想。作为计算机的“大脑”，CPU等高端处理芯片是超级计算机攻关的核心关键技术，也是西方发达国家严密封锁的高端微处理器。随着国防科大自主研发的“飞腾1000”芯片安装到“天河一号”上，从而取代部分进口芯片时，这一梦想变成了现实。在“天河二号”上，国产计算芯片更是为系统提供了系统绝大部分计算性能。这表明，我国国产自主芯片的研制与应用取得了创新突破，为今后“天河”的全部国产化奠定了基础。</p><p>而“银河”“天河”的核心技术不仅局限于此，“天河一号”夺冠后，一些外媒认为其主要计算性能还是美国芯片提供的，但是他们也不能不承认的，是“天河一号”背后的秘密武器——完全由中国设计制造的互联通信技术，该技术能够使数据以惊人的速度在所有的处理器之间来回传输。可以说，在系统越来越复杂、规模越来越庞大的现代超级计算机中，互联作为关键核心技术，其地位丝毫不亚于CPU。“天河一号”上使用的互联架构处理数据的速度比许多超级计算机普遍采用的InfiniBand互联架构大约快了一倍。</p><p>“天河一号”的另一大特色，是国防科大自主开发的高安全性软件操作系统。只有拥有了自主可控的系统，才能不受制于人，才能确保信息安全。</p><p>而现在，“天河三号E级原型机”已经研制成功，系统创新设计了“迈创”众核处理器、互连接口芯片和路由器芯片3大芯片，4类计算、存储、服务结点，10余种PCB电路板，实现各关键技术领域整体自主创新。经过几十年努力，“银河”与“天河”掌握了全面自主核心技术，所有核心技术和产品不再被国外卡脖子，打破了2015年美国对国防科大和“天河”系超算中心的高端芯片、高技术禁运封锁。</p><p>可以看到，超级计算机的意义并非只限于研制出大型计算机这一工具，由于超级计算机是最尖端电子信息技术的集合体，研制出超级计算机就意味着掌握电子信息领域的最尖端关键技术。而在“银河”“天河”系列超级计算机研制过程中的所有技术创新，全部指向了中国超级计算机发展从起步时就清晰的一个目标——自主可控。中国只有走自主创新的路，才能真正在科技领域登顶世界鳌头。</p><h2 id="驱动篇：国之重器"><a href="#驱动篇：国之重器" class="headerlink" title="驱动篇：国之重器"></a>驱动篇：国之重器</h2><p>拿“第一”固然鼓舞人心，但是把机器用好才是根本目的。自2010年“天河一号”研制并启用以来，中国超级计算需求以每年20%-30%的速度增长，超级计算在加速战略性新兴产业发展、支撑传统支柱产业升级、推动科技招商、实现产业聚集等方面发挥了巨大作用，推动了国家科技创新体系的建设，带动基础研究创新、产业转型升级创新，提升了国家的各个领域的科技发展能力，真正成为“算天”“算地”“算人”的“国之重器”。</p><p>我国超级计算机的研制，总是以现代化建设需求为驱动。以“银河-Ⅰ”为主机系统，当时的石油部门建立了自己的石油地震数据处理系统；为了建立我国独立自主的中期天气预报数字系统，研制了“银河-Ⅱ”巨型机，构建了中期数字天气预报系统，使我国成为当时世界上少数几个能进行5到7天中长期天气预报的国家之一；随后，“银河-Ⅲ”等系列巨型机相继研制成功，在航空航天飞行器设计、天气预报和气候模拟、新型能源的开发等多个领域发挥了支撑作用，并为以后超级计算机的应用铺垫了广泛的发展前景。</p><p>2015年开始，“天河一号”超级计算机就已经实现了满负荷运行，每天并发在线计算任务数超过1400项、每天完成近万项，做到了真正的“中看又中用”，在各个重大前沿科技和产业创新领域发挥重要作用。在油气勘探领域，服务能源发展，保障国家能源安全，研发自主核心软件，打破欧美垄断；在高端装备领域，支撑海洋装备、电力装备、环保装备、无人机、内燃机、汽车等进行数值模拟，实现相关行业企业的创新能力提升和转型升级；在生物医药领域，支撑艾滋病、癫痫、胰岛素等自主知识产权新药的研发并获得重大突破，助推我国脑科学研究，为改善民生做出贡献；在新材料研发领域，支撑前沿创新与先进制造，支持200多个从事金属、纳米、先进复合、储能、超导、磁性等新材料的科研团队开展新材料计算模拟研究，取得世界先进水平的科研成果，在Nature、PRL、JACS等国际顶尖期刊发表了数百篇论文。支撑科技创新方面，累计支持国家科技重大专项、国家重点研发计划等重大项目超过1600项，支持项目所涉及经费超过20亿，取得国家级、省部级奖励成果和包括Nature、Science在内学术成果超过2000项。支撑产业发展方面，依托“天河一号”构建了油气勘探、基因健康、工业设计与仿真、建筑与智慧城市等十余个专业化平台，聚集行业企业超过三千家，为近200家规模以上企业提供了高质量创新服务，节省研发投入数亿元，为企业带来相关经济效益近百亿元。部署“天河一号”超级计算机的国家超级计算天津中心已经成为我国目前应用范围最广、研发能力最强的超级计算中心。</p><p>“天河二号”不仅在新材料、新能源、高端装备制造、航空航天飞行器设计等领域发挥重要作用，同时与日常生活也息息相关，比如在PM2.5的预测预报、新型药物的设计、动漫渲染等领域都有着“天河二号”的身影。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/history/application.png"></p><center>“天河”广泛支撑国家科技与产业创新</center><p>总之，“天河”系列超级计算机已经融入国家创新驱动发展、国家信息安全、“互联网+”、“中国制造2025”等重大国家战略和发展计划，并在支撑智能制造、智慧港口、智慧交通、智慧城市等产业发展、社会公共服务能力等方面发挥重大作用。同时，“天河”超级计算机的应用与示范，引领了服务重大前沿基础科学研究与深度融入产业发展的“顶天”“立地”的综合应用模式，实现了提升国家公共资源利用效率和创造国家更加公平高效的创新创业环境，并将中国高性能服务器、计算集群产业化带入到世界第一梯度的新高度。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>今年11月，新一期全球超级计算机500强榜单发布，美国超级计算机“Summit”以峰值速度每秒20亿亿次占据榜首。在上榜的超算总数上，中国以227台位居第一，美国为109台。从“天河一号”夺冠到美国的“顶点”居首，期间经历了日本的“京”、美国的“红杉”和“泰坦”、中国的“天河二号”和“神威·太湖之光”，可以看出，美国、中国、日本同处于世界超级计算机研制的领先行列，形成了在具体系统上交替领先的格局。我国超级计算机在四十年的发展历程中得到锤炼，逐渐具备了从自主微处理器、自主互联、自主软件系统到自主应用的全方位自主创新研制能力。在这个过程中，“银河”与“天河”正成为中国迈向世界超级计算强国的核心动力。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/history/tianhe3-prototype.png"></p><center>“天河三号”E级原型机</center><p>国际超级计算机界的下一个目标是被称作“E级超算”的百亿亿次超级计算机，美国、日本、欧洲都部署了“E级超算”研发计划。今年5月在天津召开的第二届世界智能大会上，国防科大的“E级”的验证系统发布，目前已完成了大规模计算应用测试并逐步开放应用，测试涉及国家12个重大创新专项领域，数十个国家重点研发计划，已取得了一些突破性结果，将为我国科研及产业创新提供新的动力。“E级”验证系统是我国下一代百亿亿次超级计算机技术路线的一次探索和实践，我们有理由相信，新一代百亿亿次超级计算机系统将在我国大科学、大工程、大数据和人工智能等更加广泛和深入地应用中发挥不可替代的作用。</p><blockquote><p>就让我们一起，在改革开放40周年之际，致敬“银河”40年奋进历程，致敬“天河”10年创新发展！</p></blockquote><p>了解了振奋人心的辉煌历史，让我们开始正式的学习《超算入门课程》吧！</p>]]></content>
      
      
      <categories>
          
          <category> 超算入门课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> history </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Materials Studio 任务提交脚本详解</title>
      <link href="//ms-task-submit-script/"/>
      <url>//ms-task-submit-script/</url>
      
        <content type="html"><![CDATA[<p>Materials Studio是美国Accelrys公司生产的新一代材料计算软件，它是商业软件哦。</p><p>在天河系统上如果用户希望使用它，请安装使用正版软件。</p><p>结合slurm的作业管理系统，可以使用我们编写的 <code>ms-th-1A.sh</code> 脚本提交任务。</p><span id="more"></span><p>这个脚本的使用方法为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yhbatch -N NNODES -n NPROCS -p PARTITION ms-th-1A.sh server seedname         </span><br></pre></td></tr></table></figure><p>参数说明：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>NNODES</td><td>使用的节点数</td></tr><tr><td>NPROCES</td><td>使用的总核数</td></tr><tr><td>PARTITION</td><td>计算分区铭（可以用 yhi 命令查看</td></tr><tr><td>server</td><td>模块名称，如castep, dmol or dftb</td></tr><tr><td>seedname</td><td>xxx.param 前面的xxx，不需要加后缀</td></tr></tbody></table><p>举一个例子，如果希望用 <code>2</code> 个节点，<code>24</code> 个CPU核心，<code>TH_SR1</code> 分区，使用<code>castep</code> 模块，计算输入文件为 <code>Al.param</code> 的任务，可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yhbatch -N 2 -n 24 -p TH_SR1 ms-th-1A.sh castep Al     </span><br></pre></td></tr></table></figure><p>当你忘了这个脚本怎么用的时候，可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./ms-th-1A.sh</span><br><span class="line">./ms-th-1A.sh</span><br></pre></td></tr></table></figure><p>就会显示一下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yhbatch -N NNODES -n NPROCS -p PARTITION ms-th-1A.sh server seedname         </span><br><span class="line">                                                                             </span><br><span class="line">    NNODES    :  number of nodes on <span class="built_in">which</span> to run                             </span><br><span class="line">    NPROCES   :  number of tasks to run                                      </span><br><span class="line">    PARTITION :  partition requested (use <span class="string">&#x27;yhi&#x27;</span> to check available partition)</span><br><span class="line">                                                                             </span><br><span class="line">    server    :  server name (castep, dmol or dftb)                          </span><br><span class="line">    seedname  :  seed name                                                   </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 商业软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Materials Studio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python扩展包的安装方法 --- conda本地源使用说明</title>
      <link href="//python-package-install-with-conda/"/>
      <url>//python-package-install-with-conda/</url>
      
        <content type="html"><![CDATA[<p>由于天河系统使用VPN访问，故无法直接连接互联网，导致python依赖包的安装无法直接进行。因此，本文提供一个利用conda包管理工具，配置python环境的方法。</p><span id="more"></span><h2 id="配置自己的python环境"><a href="#配置自己的python环境" class="headerlink" title="配置自己的python环境"></a>配置自己的python环境</h2><h3 id="配置系统anaconda环境"><a href="#配置系统anaconda环境" class="headerlink" title="配置系统anaconda环境"></a>配置系统anaconda环境</h3><p>以vol-th文件系统为例，设置python3的环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module add python/3.6_anaconda</span><br></pre></td></tr></table></figure><h3 id="配置conda的环境文件"><a href="#配置conda的环境文件" class="headerlink" title="配置conda的环境文件"></a>配置conda的环境文件</h3><p>目的是在用户自己的账户下创建env环境，以及修改默认channel环境。</p><p>方法一：使用命令行配置condarc文件（推荐方法）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda config  --add  channels  file://vol-th/software/anaconda-pkgs/</span><br><span class="line">conda config  --add  envs_dirs  /vol-th/home/zhenggang/software/envs</span><br></pre></td></tr></table></figure><p>方法二：手动编辑condarc文件<br>创建文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim  ~/.condarc</span><br></pre></td></tr></table></figure><p>写入如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">envs_dirs:</span><br><span class="line"> - /vol-th/home/zhenggang/software/envs</span><br><span class="line">channels:</span><br><span class="line"> - file://vol-th/software/anaconda-pkgs/</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>1.envs_dirs 指的是把conda的环境安装在哪个目录，请设置为自己账户下的一个文件夹即可。（一定要修改为自己账户目录的某个文件夹）</li><li>2.channels 指的是使用conda install的时候，到哪里去找安装包，无需修改。</li></ul><h3 id="创建一个conda环境"><a href="#创建一个conda环境" class="headerlink" title="创建一个conda环境"></a>创建一个conda环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda  create  -n  myenv  python=3.6  --offline</span><br></pre></td></tr></table></figure><p>当提示是否继续的是，输入“y”继续。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proceed ([y]/n)? y</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>1.myenv 是自己创建的一个环境的名字，改成自己需要的名字即可。</li><li>2.如果用户使用的是自己的anaconda或miniconda环境，那么可以选择直接使用默认环境，无需创建新环境。</li></ul><h3 id="激活conda环境"><a href="#激活conda环境" class="headerlink" title="激活conda环境"></a>激活conda环境</h3><p>激活环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span>  activate  myenv</span><br></pre></td></tr></table></figure><p>说明：myenv 是刚刚创建的一个环境的名字。</p><h3 id="安装python包"><a href="#安装python包" class="headerlink" title="安装python包"></a>安装python包</h3><p>举例：安装一个常用数学库的包numpy</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda  install  --offline  numpy</span><br></pre></td></tr></table></figure><p>当提示是否继续的是，输入“y”继续。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proceed ([y]/n)? y</span><br></pre></td></tr></table></figure><p>安装完成后即可使用。</p><h3 id="测试使用python"><a href="#测试使用python" class="headerlink" title="测试使用python"></a>测试使用python</h3><p>输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python</span><br></pre></td></tr></table></figure><p>显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python 3.6.5 |Anaconda, Inc.| (default, Apr 29 2018, 16:14:56)</span><br><span class="line">[GCC 7.2.0] on linux</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>再输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import  numpy</span><br></pre></td></tr></table></figure><p>如果没有任何报错就说明导入成功了。</p><h3 id="退出conda环境"><a href="#退出conda环境" class="headerlink" title="退出conda环境"></a>退出conda环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span>  deactivate</span><br></pre></td></tr></table></figure><h2 id="conda的常用命令"><a href="#conda的常用命令" class="headerlink" title="conda的常用命令"></a>conda的常用命令</h2><h3 id="获取版本号"><a href="#获取版本号" class="headerlink" title="获取版本号"></a>获取版本号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conda  -version 或 conda  -V</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"><span class="comment">### 获取帮助</span></span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">conda  -<span class="built_in">help</span> 或 conda  -h</span><br></pre></td></tr></table></figure><p>查看某一命令的帮助，如update命令及remove命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda  update  -<span class="built_in">help</span> </span><br><span class="line">conda  remove  -<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>同理，以上命令中的-help也可以换成-h。</p><h3 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h3><p>查看环境管理的全部命令帮助 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda  env  -h</span><br></pre></td></tr></table></figure><h3 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h3><p>查看安装了哪些包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda  list</span><br></pre></td></tr></table></figure><p>查看当前存在哪些虚拟环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda  env  list 或 conda  info  -e</span><br></pre></td></tr></table></figure><p>检查更新当前conda</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda  update  conda</span><br></pre></td></tr></table></figure><h3 id="创建python虚拟环境"><a href="#创建python虚拟环境" class="headerlink" title="创建python虚拟环境"></a>创建python虚拟环境</h3><p>使用 conda create -n your_env_name python=X.X（2.7、3.6等)命令创建python版本为X.X、名字为your_env_name的虚拟环境。your_env_name文件可以在Anaconda安装目录envs文件下找到。</p><h3 id="使用激活-或切换不同python版本-的虚拟环境"><a href="#使用激活-或切换不同python版本-的虚拟环境" class="headerlink" title="使用激活(或切换不同python版本)的虚拟环境"></a>使用激活(或切换不同python版本)的虚拟环境</h3><p>使用如下命令即可 激活你的虚拟环境(即将python的版本改变)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span>  activate  your_env_name(虚拟环境名称)</span><br></pre></td></tr></table></figure><p>使用python -version可以检查当前python版本是否为想要的。</p><h3 id="对虚拟环境中安装额外的包"><a href="#对虚拟环境中安装额外的包" class="headerlink" title="对虚拟环境中安装额外的包"></a>对虚拟环境中安装额外的包</h3><p>使用命令即可安装package到your_env_name中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -n your_env_name [package]</span><br></pre></td></tr></table></figure><p>备注：本地安装需要增加 –offline参数</p><h3 id="关闭虚拟环境-即从当前环境退出返回使用PATH环境中的默认python版本"><a href="#关闭虚拟环境-即从当前环境退出返回使用PATH环境中的默认python版本" class="headerlink" title="关闭虚拟环境(即从当前环境退出返回使用PATH环境中的默认python版本)"></a>关闭虚拟环境(即从当前环境退出返回使用PATH环境中的默认python版本)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> deactivate</span><br></pre></td></tr></table></figure><h3 id="删除虚拟环境"><a href="#删除虚拟环境" class="headerlink" title="删除虚拟环境"></a>删除虚拟环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove -n your_env_name(虚拟环境名称) –all</span><br></pre></td></tr></table></figure><h3 id="删除环境中的某个包"><a href="#删除环境中的某个包" class="headerlink" title="删除环境中的某个包"></a>删除环境中的某个包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove -name your_env_name package_name</span><br></pre></td></tr></table></figure><p>备注：本部分来源：<a href="https://blog.csdn.net/lovejay7/article/details/80463110">https://blog.csdn.net/lovejay7/article/details/80463110</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国家超级计算天津中心用户大会培训资料下载</title>
      <link href="//user-conference-training-materials-20181216/"/>
      <url>//user-conference-training-materials-20181216/</url>
      
        <content type="html"><![CDATA[<p>大家好！非常感谢大家来参加本次的培训会。</p><table><thead><tr><th>报告题目</th><th>报告人</th><th>主讲人单位</th><th>下载链接</th><th>提取码</th></tr></thead><tbody><tr><td>MPI并行编程</td><td>汤善江</td><td>天津大学</td><td><a href="https://pan.baidu.com/s/1widc4eQ0Odcg_b5_V3rAzw" target="_blank">点我</a></td><td>c0u3</td></tr><tr><td>天河三号原型机技术培训</td><td>龚春叶</td><td>国防科技大学</td><td>内部资料暂不提供下载</td><td>-</td></tr><tr><td>天河用户使用培训</td><td>马庆珍</td><td>国家超级计算天津中心</td><td><a href="https://pan.baidu.com/s/1-7C98MY9bO2mKywh657TtA" target="_blank">点我</a></td><td>4slv</td></tr></tbody></table><span id="more"></span><p><del>相关资料将于1-2日内上传完成，提供一定时间的下载权限</del></p><p>资料下载有效期为7天，如无法下载可以联系我们。</p><p>如有任何意见或者建议，欢迎联系我们。（点击导航栏“关于”，可加我微信）</p>]]></content>
      
      
      <categories>
          
          <category> 培训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> slurm </tag>
            
            <tag> 培训 </tag>
            
            <tag> mpi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python扩展包的安装方法 --- pip本地源使用说明</title>
      <link href="//python-package-install-with-pip/"/>
      <url>//python-package-install-with-pip/</url>
      
        <content type="html"><![CDATA[<h2 id="天河系统python包本地安装方法"><a href="#天河系统python包本地安装方法" class="headerlink" title="天河系统python包本地安装方法"></a>天河系统python包本地安装方法</h2><p>当用户使用可以连接互联网的系统环境时，用pip命令安装python包(例如numpy)，只需要：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy</span><br></pre></td></tr></table></figure><span id="more"></span><p>当系统无法连接互联网时，可以前往 <code>https://pypi.org/project/</code> 官网，手动下载所需python包，然后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy-1.15.4-cp27-cp27m-manylinux1_x86_64.whl</span><br></pre></td></tr></table></figure><p>但是，当待安装的包依赖其他包时，这个过程变得非常繁琐，甚至于无法完成。</p><p>因此，我们可以在本地搭建一个pip的本地源，这样子在安装时，给出本地源的路径，就可以直接安装了。</p><p>下面给出在天河系统下用pip本地源安装python包的说明。</p><h3 id="Step1-加载含有pip命令的python环境"><a href="#Step1-加载含有pip命令的python环境" class="headerlink" title="Step1 加载含有pip命令的python环境"></a>Step1 加载含有pip命令的python环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module add python/2.7_anaconda</span><br></pre></td></tr></table></figure><p>如果想用其他的python版本，例如python3.6，还可以</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module add python/3.6_anaconda</span><br></pre></td></tr></table></figure><h3 id="Step2-安装包"><a href="#Step2-安装包" class="headerlink" title="Step2 安装包"></a>Step2 安装包</h3><p>我们可以手动指定本地源目录，每次指定目录安装，见步骤Step2-1；也可以通过配置文件，设置默认本地源路径，然后直接安装，见步骤Step2-2。</p><h4 id="Step2-1-手动指定本地源目录，直接执行安装命令"><a href="#Step2-1-手动指定本地源目录，直接执行安装命令" class="headerlink" title="Step2-1 手动指定本地源目录，直接执行安装命令"></a>Step2-1 手动指定本地源目录，直接执行安装命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip  install  numpy  -i  file:///vol-th/software/pypi/web/simple  --user</span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li><code>pip</code> 是执行的命令</li><li><code>install</code> 表示安装</li><li><code>numpy</code> 是安装包的名字（安装其他包时，请修改为包的名字）</li><li><code>-i file:///vol-th/software/pypi/web/simple</code> 指定本地源目录</li><li><code>--user</code> 指定安装位置为 <code>~/.local</code></li><li>可以用<code>--target=/path</code>来指定其他安装目录</li></ul><h4 id="Step2-2-配置默认本地源安装，然后执行安装命令"><a href="#Step2-2-配置默认本地源安装，然后执行安装命令" class="headerlink" title="Step2-2 配置默认本地源安装，然后执行安装命令"></a>Step2-2 配置默认本地源安装，然后执行安装命令</h4><p>在当前用户目录下创建.pip文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.pip</span><br><span class="line"><span class="built_in">cd</span> ~/.pip</span><br></pre></td></tr></table></figure><p>然后在该目录下创建 <code>pip.conf</code>文件填写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url=file:///vol-th/software/pypi/web/simple</span><br></pre></td></tr></table></figure><p>如果不熟悉的用户，可以执行如下命令来生成该文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[global]&quot;</span> &gt; ~/.pip/pip.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;index-url=file:///vol-th/software/pypi/web/simple&quot;</span> &gt;&gt; ~/.pip/pip.conf</span><br></pre></td></tr></table></figure><p>然后执行安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip  install  numpy  --user</span><br></pre></td></tr></table></figure><h3 id="Step3-测试"><a href="#Step3-测试" class="headerlink" title="Step3 测试"></a>Step3 测试</h3><p>开启python环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import numpy</span><br></pre></td></tr></table></figure><p>如果没有任务报错反馈，说明numpy包安装成功，其他包相同。</p><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>默认情况下，不需要额外设置环境变量。</p><p>当所安装的包生成了可执行文件的时候，请添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$HOME</span>/.<span class="built_in">local</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$HOME</span>/.<span class="built_in">local</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><p>如果用<code>--target=</code>指定了其他安装目录，需要手动设置环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> mypackage=/path/to/install  <span class="comment"># 用来指定安装的路径，将路径设置为实际安装路径</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$mypackage</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$mypackage</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> PYTHONPATH=<span class="variable">$mypackage</span>/lib/python2.7/site-packages:<span class="variable">$PYTHONPATH</span>  <span class="comment"># 适合与python2.7</span></span><br><span class="line"><span class="built_in">export</span> PYTHONPATH=<span class="variable">$mypackage</span>/lib/python3.6/site-packages:<span class="variable">$PYTHONPATH</span>  <span class="comment"># 适合与python3.6</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSL VPN Windows环境诊断修复工具，一键检测电脑插件问题</title>
      <link href="//vpn-SangforHelperToolInstaller/"/>
      <url>//vpn-SangforHelperToolInstaller/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>SangforHelperToolInstaller</strong>，一个用于windows系统检测vpn的工具。</p><span id="more"></span><p><a href="http://download.sangfor.com.cn/download/product/sslvpn/SangforHelperToolInstaller.exe">官网下载</a></p><h2 id="首页截图"><a href="#首页截图" class="headerlink" title="首页截图"></a>首页截图</h2><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vpn-SangforHelperToolInstaller/vpn1.png"></p><h2 id="检测中截图"><a href="#检测中截图" class="headerlink" title="检测中截图"></a>检测中截图</h2><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vpn-SangforHelperToolInstaller/vpn2.png"></p><h2 id="发现问题，一键修复"><a href="#发现问题，一键修复" class="headerlink" title="发现问题，一键修复"></a>发现问题，一键修复</h2><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vpn-SangforHelperToolInstaller/vpn3.png"></p><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vpn-SangforHelperToolInstaller/vpn4.png"></p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/vpn-SangforHelperToolInstaller/vpn5.png"></p>]]></content>
      
      
      <categories>
          
          <category> VPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vpn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>slurm作业管理：一行yhrun命令加载多个作业步</title>
      <link href="//slurm-multi-program/"/>
      <url>//slurm-multi-program/</url>
      
        <content type="html"><![CDATA[<p>我们希望运行一行 <code>yhrun</code> 命令加载多个作业步，该怎么办呢？可以使用 <code>yhrun</code> 命令的 <code>--multi-prog</code> 参数来实现。</p><p>通过指定 <code>--multi-prog</code> 选项，可使用 <code>yhrun</code> 加载多程序作业步，即不同的任务执<br>行不同的程序和 / 或参数。这时， yhrun 命令的参数中，最后跟的不是要执行的程序，而是一个配置文件，其中注明每个任务需要加载的程序。</p><span id="more"></span><p>配置文件按行组织，每行用空白分隔为若干个字段。第一个字段为任务号部分，可以包含逗号分隔的任务号列表，可以用 <code>min-max</code> 表示任务号范围，或在最后一行用 <code>*</code> 表示其余所有的任务号。第二个字段为所指定的任务要执行的程序。其它字段为执行程序时的参数。在程序和参数中，可以使用 <code>%t</code> 和 <code>%o</code>，分别表示替换为任务的任务号和任务在配置文件该行所指定的任务号中的偏移。</p><p>下面举一个例子 ^_^</p><p>配置文件 <code>mp.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 a.out abc</span><br><span class="line">1 b.out %t</span><br><span class="line">2,5,7-9 c.out %o</span><br><span class="line">* d.out</span><br></pre></td></tr></table></figure><p>加载作业步</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yhrun -n 16 --multi-prog mp.conf</span><br></pre></td></tr></table></figure><p>所有任务执行的程序分别为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0： a.out abc</span><br><span class="line">1： b.out 1</span><br><span class="line">2： c.out 0</span><br><span class="line">3,4,6,10-15： d.out</span><br><span class="line">5： c.out 1</span><br><span class="line">7： c.out 2</span><br><span class="line">8： c.out 3</span><br><span class="line">9： c.out 4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 作业调度 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> slurm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VASP 固定晶胞方向不优化</title>
      <link href="//vasp-fixed-cell-direction-no-optimize/"/>
      <url>//vasp-fixed-cell-direction-no-optimize/</url>
      
        <content type="html"><![CDATA[<p>在优化表面，二维或一维体系时，必须固定某个或某几个晶胞方向不优化。VASP本身没有这个功能，但是提供了 <code>constr_cell_relax.F</code> 文件来设置。根据文件中的提示，添加几行代码后，就可以任意固定晶胞方向了。</p><p>使用方法：在目录下建立文件 <code>OPTCELL</code> ，第一行输入三个数字（比如 <code>110</code> ），数字 <code>1</code> 表示优化，数字 <code>0</code> 表示不优化；三个数字依次对应于xyz方向。比如 <code>110</code> 表示z轴不优化；<code> 001</code> 表示x和y轴都不优化。</p><span id="more"></span><blockquote><p>注1. 无OPTCELL文件则完全是原版软件的功能；<br>注2. 只适用与正交晶胞，所有角都是直角。</p></blockquote><p>附：修改后的 <code>constr_cell_relax.F</code> 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">      SUBROUTINE CONSTR_CELL_RELAX(FCELL)</span><br><span class="line">      USE PREC</span><br><span class="line">      REAL(Q) FCELL(3,3), SAVE(3)</span><br><span class="line">      LOGICAL FILFLG</span><br><span class="line">      INTEGER ICELL(3)</span><br><span class="line"></span><br><span class="line">      INQUIRE(FILE=&#x27;OPTCELL&#x27;,EXIST=FILFLG)</span><br><span class="line">      IF (FILFLG) THEN</span><br><span class="line">        OPEN(67,FILE=&#x27;OPTCELL&#x27;,FORM=&#x27;FORMATTED&#x27;,STATUS=&#x27;OLD&#x27;)</span><br><span class="line">          READ(67,&quot;(3I1)&quot;) (ICELL(I),I=1,3)</span><br><span class="line">        CLOSE(67)</span><br><span class="line">        DO I=1,3</span><br><span class="line">          SAVE(I)=FCELL(I,I)</span><br><span class="line">        ENDDO</span><br><span class="line">        FCELL=0.0d0</span><br><span class="line">        DO I=1,3</span><br><span class="line">          IF (ICELL(I)==1) FCELL(I,I)=SAVE(I)</span><br><span class="line">        ENDDO</span><br><span class="line">      ENDIF</span><br><span class="line"></span><br><span class="line">!     just one simple example</span><br><span class="line">!     relaxation in x directions only</span><br><span class="line">!      SAVE=FCELL(1,1)</span><br><span class="line">!      FCELL=0   ! F90 style: set the whole array to zero</span><br><span class="line">!      FCELL(1,1)=SAVE</span><br><span class="line"></span><br><span class="line">      RETURN</span><br><span class="line">      END SUBROUTINE</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 应用软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vasp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ovito安装说明(windows+linux)</title>
      <link href="//ovito-install/"/>
      <url>//ovito-install/</url>
      
        <content type="html"><![CDATA[<p>OVITO是一个用于原子和粒子模拟数据的科学可视化和分析软件。 它有助于科学家更好地了解材料现象和物理过程。 该程序可在开源许可下免费用于所有主要平台。 计算模拟研究作为分析，理解和说明模拟结果的有力工具。</p><span id="more"></span><p>官网地址：<a href="http://www.ovito.org/">传送门</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/ovito/ovito-1.png"></p><p>下载地址：<a href="http://www.ovito.org/index.php/download">传送门</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/ovito/ovito-2.png"></p><h2 id="windows版本"><a href="#windows版本" class="headerlink" title="windows版本"></a>windows版本</h2><p>下载Windows版本的压缩包，<a href="http://www.ovito.org/download/2.9.0/ovito-2.9.0-win64.exe">Download OVITO 2.9.0</a>。正常安装即可。</p><p>安装后双击<code>ovito.exe</code>即可打开。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/ovito/ovito-3.png"></p><h2 id="linux版本"><a href="#linux版本" class="headerlink" title="linux版本"></a>linux版本</h2><p>下载Windows版本的压缩包，<a href="http://www.ovito.org/download/2.9.0/ovito-2.9.0-x86_64.tar.gz">Download OVITO 2.9.0</a>。</p><p>解压缩即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf ovito-2.9.0-x86_64.tar.gz</span><br><span class="line"><span class="built_in">cd</span> ovito-2.9.0-x86_64</span><br></pre></td></tr></table></figure><p>设置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> OVITO_HOME=/path/to/ovito-2.9.0-x86_64</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$OVITO_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><blockquote><p>请把 <code>/path/to/ovito-2.9.0-x86_64</code> 改为解压缩后的实际路径。</p></blockquote><p>然后在命令行输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> ovito</span><br></pre></td></tr></table></figure><p>如果反馈了 <code>ovito</code> 所在路径即设置完成，我们尝试运行它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ovito</span><br></pre></td></tr></table></figure><p>如果程序启动失败并显示错误消息 <code>ovito:/usr/lib64/libstdc++.so.6</code> : 版本<code>CXXABI_1.3.8</code> 未找到 ，请下载此版本的 <code>libstdc++</code> 。所以并复制两个 <code>.so</code> 文件 OVITO安装的 <code>lib/ovito/</code> 子目录。它们是必需的，因为系统上现有的 <code>libstdc++</code> 版本与OVITO二进制文件不兼容。</p><p>下载地址：<a href="http://www.ovito.org/download/2.9.0/libstdc++.so.6">libstdc++.so.6</a>，<a href="http://www.ovito.org/download/2.9.0/libstdc++.so.6.0.21">libstdc++.so.6.0.21</a>。</p><p>然后拷贝到对应目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> OVITO_HOME=/path/to/ovito-2.9.0-x86_64</span><br><span class="line">cp libstdc++.so.6 <span class="variable">$OVITO_HOME</span>/lib/ovito</span><br><span class="line">cp libstdc++.so.6.0.21 <span class="variable">$OVITO_HOME</span>/lib/ovito</span><br></pre></td></tr></table></figure><p>我们再次运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ovito</span><br></pre></td></tr></table></figure><p>如果成功打开界面，说明成功运行。</p><blockquote><p>如果是linux环境对图形界面支持的不好，我们可以用 <code>ovitos</code> 命令进行命令行方式进行图像处理。</p></blockquote><h2 id="报错：缺少nivida的库"><a href="#报错：缺少nivida的库" class="headerlink" title="报错：缺少nivida的库"></a>报错：缺少nivida的库</h2><p>在计算节点运行 <code>ovitos</code> 命令时，提示缺少libnvidia-tls.so和libnvidia-glcore.so库。</p><p>这个库存在于nvidia的驱动库中，我们从官网下载：<a href="https://developer.nvidia.com/cuda-75-downloads-archive">传送门</a>。依次选择：<code>Linux - x86_64 - RHEL - 6 - rpm(local)</code> ，下载 <code>cuda-repo-rhel6-7-5-local-7.5-18.x86_64.rpm</code> 压缩包。</p><p>然后解压缩rpm包并找到这两个库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rpm2cpio cuda-repo-rhel6-7-5-local-7.5-18.x86_64.rpm | cpio -div</span><br><span class="line"><span class="built_in">cd</span> var/cuda-repo-7-5-local</span><br><span class="line">rpm2cpio xorg-x11-drv-nvidia-libs-352.39-1.el6.x86_64.rpm  | cpio -div</span><br><span class="line">rpm2cpio xorg-x11-drv-nvidia-gl-352.39-1.el6.x86_64.rpm  | cpio -div</span><br><span class="line"><span class="built_in">cd</span> usr/lib64/nvidia</span><br></pre></td></tr></table></figure><p>我们就可以找到它们了，然后将这两个库拷贝到合适的位置，并添加到LD_LIBRARY_PATH环境变量中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span>  LD_LIBRARY_PATH=/path/to/nvidia-lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><blockquote><p>如果还是搞不定，问管理员吧，让他把节点的CUDA驱动配置好。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 可视化软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ovito </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用TACC launcher来批量提交串行任务</title>
      <link href="//how-to-use-tacc-launcher/"/>
      <url>//how-to-use-tacc-launcher/</url>
      
        <content type="html"><![CDATA[<h2 id="TACC-launcher-是什么？"><a href="#TACC-launcher-是什么？" class="headerlink" title="TACC launcher 是什么？"></a>TACC launcher 是什么？</h2><p>它是一个简单实用的工具，用来帮助用户在一个批处理脚本中提交多个单线程或多线程的任务。</p><p>它的详细介绍请参考官网：<a href="https://github.com/TACC/launcher/" title="TACC laucher 官网">传送门</a>。</p><p>它的下载地址：<a href="https://github.com/TACC/launcher/releases" title="TACC launcher 下载">传送门</a>。</p><span id="more"></span><h2 id="TACC-launcher-怎么用？"><a href="#TACC-launcher-怎么用？" class="headerlink" title="TACC launcher 怎么用？"></a>TACC launcher 怎么用？</h2><p>非常推荐前往官网查看它的使用方法，有很详细的介绍。我就不再重复了，英文不好的朋友可以使用网页翻译工具翻译一下。</p><p>简单讲，就是：</p><ol><li>将这个工具下载下来</li><li>解压缩</li><li>不需要编译！</li><li>配置环境变量</li><li>写一个joblist文件，里面写上所有需要执行的任务</li><li>使用launcher的命令提交</li></ol><h2 id="TACC-launcher-slurm-实例"><a href="#TACC-launcher-slurm-实例" class="headerlink" title="TACC launcher + slurm 实例"></a>TACC launcher + slurm 实例</h2><h3 id="准备算例"><a href="#准备算例" class="headerlink" title="准备算例"></a>准备算例</h3><p>我们准备一个joblist文件：myjoblist，里面写上要执行的任务，先简单些12行helloworld做测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span></span><br></pre></td></tr></table></figure><h3 id="编写提交脚本"><a href="#编写提交脚本" class="headerlink" title="编写提交脚本"></a>编写提交脚本</h3><p>我们再编写一个提交脚本sub.sh，里面写上launcher的相关命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">export</span> LAUNCHER_JOB_FILE=/path/to/myjoblist</span><br><span class="line"><span class="built_in">export</span> LAUNCHER_DIR=<span class="variable">$HOME</span>/launcher/launcher-3.1.1</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$LAUNCHER_DIR</span>:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LAUNCHER_PLUGIN_DIR=<span class="variable">$LAUNCHER_DIR</span>/plugins</span><br><span class="line"><span class="built_in">export</span> LAUNCHER_RMI=SLURM</span><br><span class="line"><span class="built_in">export</span> LAUNCHER_SCHED=interleaved</span><br><span class="line"><span class="built_in">export</span> LAUNCHER_WORKDIR=`<span class="built_in">pwd</span>`</span><br><span class="line"><span class="variable">$LAUNCHER_DIR</span>/paramrun</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>LAUNCHER_JOB_FILE 为myjoblist路径，请改为实际路径</li><li>LAUNCHER_DIR 为launcher的安装路径，请改为实际路径</li><li>其他的变量暂时不需要修改</li></ol><h3 id="提交脚本"><a href="#提交脚本" class="headerlink" title="提交脚本"></a>提交脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yhbatch -N 2 -n 6 -p debug sub.sh</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>-N 2 表示2个节点</li><li>-n 6 表示6个cpu核（一共6个，不是每个节点6个；另外，注意n需要能被N整除，否则报错）</li><li>-p debug 表示使用debug分区</li></ol><h3 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h3><p>使用slurm作业调度系统提交的任务会有一个默认的输出文件slurm-jobid.out，我们查看这个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Launcher: Setup complete.</span><br><span class="line"></span><br><span class="line">------------- SUMMARY ---------------</span><br><span class="line">   Number of hosts:    2</span><br><span class="line">   Working directory:  <span class="variable">$HOME</span>/workdir/<span class="built_in">test</span></span><br><span class="line">   Processes per host: 3</span><br><span class="line">   Total processes:    6</span><br><span class="line">   Total <span class="built_in">jobs</span>:         12</span><br><span class="line">   Scheduling method:  interleaved</span><br><span class="line"></span><br><span class="line">-------------------------------------</span><br><span class="line">Launcher: Starting parallel tasks...</span><br><span class="line">Launcher: Task 1 running job 2 on cn95 (<span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">Launcher: Task 0 running job 1 on cn95 (<span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">hello, world</span><br><span class="line">hello, world</span><br><span class="line">Launcher: Task 2 running job 3 on cn95 (<span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">hello, world</span><br><span class="line">Launcher: Job 1 completed <span class="keyword">in</span> 0 seconds.</span><br><span class="line">Launcher: Task 5 running job 6 on cn96 (<span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">Launcher: Task 4 running job 5 on cn96 (<span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">hello, world</span><br><span class="line">hello, world</span><br><span class="line">Launcher: Task 3 running job 4 on cn96 (<span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">Launcher: Job 3 completed <span class="keyword">in</span> 0 seconds.</span><br><span class="line">hello, world</span><br><span class="line">Launcher: Job 2 completed <span class="keyword">in</span> 0 seconds.</span><br><span class="line">Launcher: Job 6 completed <span class="keyword">in</span> 0 seconds.</span><br><span class="line">Launcher: Job 5 completed <span class="keyword">in</span> 0 seconds.</span><br><span class="line">Launcher: Job 4 completed <span class="keyword">in</span> 0 seconds.</span><br><span class="line">Launcher: Task 0 running job 7 on cn95 (<span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">hello, world</span><br><span class="line">Launcher: Task 2 running job 9 on cn95 (<span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">hello, world</span><br><span class="line">Launcher: Task 1 running job 8 on cn95 (<span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">hello, world</span><br><span class="line">Launcher: Task 5 running job 12 on cn96 (<span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">hello, world</span><br><span class="line">Launcher: Task 3 running job 10 on cn96 (<span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">hello, world</span><br><span class="line">Launcher: Task 4 running job 11 on cn96 (<span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">hello, world</span><br><span class="line">Launcher: Job 7 completed <span class="keyword">in</span> 0 seconds.</span><br><span class="line">Launcher: Job 9 completed <span class="keyword">in</span> 0 seconds.</span><br><span class="line">Launcher: Job 8 completed <span class="keyword">in</span> 0 seconds.</span><br><span class="line">Launcher: Job 12 completed <span class="keyword">in</span> 0 seconds.</span><br><span class="line">Launcher: Job 10 completed <span class="keyword">in</span> 0 seconds.</span><br><span class="line">Launcher: Job 11 completed <span class="keyword">in</span> 0 seconds.</span><br><span class="line">Launcher: Task 0 <span class="keyword">done</span>. Exiting.</span><br><span class="line">Launcher: Task 2 <span class="keyword">done</span>. Exiting.</span><br><span class="line">Launcher: Task 1 <span class="keyword">done</span>. Exiting.</span><br><span class="line">Launcher: Task 5 <span class="keyword">done</span>. Exiting.</span><br><span class="line">Launcher: Task 3 <span class="keyword">done</span>. Exiting.</span><br><span class="line">Launcher: Task 4 <span class="keyword">done</span>. Exiting.</span><br><span class="line">Launcher: Done. Job exited without errors</span><br></pre></td></tr></table></figure><p>说明：</p><table><thead><tr><th>参数</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>Number of hosts</td><td>2</td><td>-N 2，所以为2个节点</td></tr><tr><td>Working directory</td><td>$HOME/workdir/test</td><td>这个是实际的提交目录</td></tr><tr><td>Processes per host</td><td>3</td><td>每个节点的进程数，是通过 6/2=3 得到，所以注意要整除 !</td></tr><tr><td>Total processes</td><td>6</td><td>-n 6，所以有一共6个进程</td></tr><tr><td>Total jobs</td><td>12</td><td>在myjobslist中我们写了12行，所以是12个jobs</td></tr><tr><td>Scheduling method</td><td>interleaved</td><td>这个参数是调度方法，有3种，详见官网</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工具软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tacc-launcher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在ARM平台编译NAMD</title>
      <link href="//how-to-compile-namd-on-arm-platform/"/>
      <url>//how-to-compile-namd-on-arm-platform/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>NAMD是一种平行分子动力学代码，设计用于大型生物分子系统的高性能模拟。 利用Charm ++并行编程框架，NAMD可以扩展到几个核心，用于典型的仿真，超过500,000个核心，用于最大的仿真。</p><p>使用此系统编写的程序在具有或不具有共享内存的MIMD计算机上运行不变。 它提供了高级机制和策略，以促进开发甚至高度复杂的并行应用程序的任务。</p><span id="more"></span><p>有关Charm ++或NAMD的更多信息，请分别访问 <a href="http://charm.cs.illinois.edu/index">Charm++</a> 或 <a href="http://www.ks.uiuc.edu/Research/namd/">NAMD</a> 网站。</p><h2 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h2><p>这些说明着重于为多节点，多核平台构建NAMD。出于此构建的目的，使用以下组件：</p><table><thead><tr><th align="center">序号</th><th align="center">组件</th><th align="center">版本</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">NAMD</td><td align="center">Version 2.12</td></tr><tr><td align="center">2</td><td align="center">Charm++</td><td align="center">Version 6.7.1</td></tr><tr><td align="center">3</td><td align="center">GNU Compiler</td><td align="center">Version 4.9.3</td></tr><tr><td align="center">4</td><td align="center">MPICH</td><td align="center">Version 3.2.1</td></tr></tbody></table><h2 id="编译器配置"><a href="#编译器配置" class="headerlink" title="编译器配置"></a>编译器配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GNU COMPILER</span></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/bin:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MPI</span></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/mpi3/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/mpi3/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># environment</span></span><br><span class="line"><span class="built_in">export</span> CC=gcc</span><br><span class="line"><span class="built_in">export</span> CXX=g++</span><br><span class="line"><span class="built_in">export</span> FC=gfortran</span><br></pre></td></tr></table></figure><h2 id="下载源码包"><a href="#下载源码包" class="headerlink" title="下载源码包"></a>下载源码包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BUILD_DIR=~/NAMD</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$BUILD_DIR</span></span><br><span class="line">wget http://www.ks.uiuc.edu/Research/namd/2.12/download/832164/NAMD_2.12_Source.tar.gz </span><br><span class="line">tar -xf NAMD_2.12_Source.tar.gz</span><br><span class="line"><span class="built_in">cd</span> NAMD_2.12_Source</span><br></pre></td></tr></table></figure><h2 id="构建和安装Charm"><a href="#构建和安装Charm" class="headerlink" title="构建和安装Charm"></a>构建和安装Charm</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CHARMARCH=mpi-linux-aarch64</span><br><span class="line">tar xvf charm-6.7.1.tar</span><br><span class="line"><span class="built_in">cd</span> charm-6.7.1</span><br><span class="line"><span class="built_in">cd</span> src/arch</span><br><span class="line">mkdir <span class="variable">$CHARMARCH</span></span><br><span class="line">cp mpi-linux/conv-mach.* <span class="variable">$CHARMARCH</span> </span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$CHARMARCH</span></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">&quot;s/i386-gcc/generic64-light/&quot;</span> conv-mach.sh</span><br><span class="line">sed -i <span class="string">&quot;/#endif/i #define CMK_64BIT         1&quot;</span> conv-mach.h</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ../../..</span><br><span class="line"></span><br><span class="line"><span class="comment"># build</span></span><br><span class="line">./build charm++ <span class="variable">$CHARMARCH</span> --with-production -j8</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><blockquote><p>说明：因为针对ARM64，没有现成的ARCH配置，故自己拷贝一个类似的，然后修改。编译过程大约几分钟。</p></blockquote><h2 id="构建和安装NAMD"><a href="#构建和安装NAMD" class="headerlink" title="构建和安装NAMD"></a>构建和安装NAMD</h2><h3 id="配置FFTW库（使用官方的版本）"><a href="#配置FFTW库（使用官方的版本）" class="headerlink" title="配置FFTW库（使用官方的版本）"></a>配置FFTW库（使用官方的版本）</h3><p>下载FFTW库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.ks.uiuc.edu/Research/namd/libraries/fftw-linux-arm64.tar.gz </span><br><span class="line">tar xvf fftw-linux-arm64.tar.gz </span><br></pre></td></tr></table></figure><p>也可以手动下载源码，并拷贝到NAMD解压后的目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&quot;s%\$(HOME)%`pwd`%&quot;</span> arch/Linux-ARM64.fftw</span><br></pre></td></tr></table></figure><p>如果系统中已安装了fftw库，也可以直接使用，例如自己手动修改配置文件 <code>arch/Linux-ARM64.fftw</code> ，改为以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FFTDIR=/usr/<span class="built_in">local</span>/fftw</span><br><span class="line">FFTINCL=-I$(FFTDIR)/include</span><br><span class="line">FFTLIB=-L$(FFTDIR)/lib -lfftw3f </span><br><span class="line">FFTFLAGS=-DNAMD_FFTW -DNAMD_FFTW_3</span><br><span class="line">FFT=$(FFTINCL) $(FFTFLAGS)</span><br></pre></td></tr></table></figure><p>说明：FFTWDIR=/usr/local/fftw，指的是fftw库安装的根目录，请修改为自己的目录。</p><h3 id="配置TCL库的变量"><a href="#配置TCL库的变量" class="headerlink" title="配置TCL库的变量"></a>配置TCL库的变量</h3><p>下载TCL库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.ks.uiuc.edu/Research/namd/libraries/tcl8.5.9-linux-arm64-threaded.tar.gz</span><br><span class="line">tar xvf tcl8.5.9-linux-arm64-threaded.tar.gz </span><br></pre></td></tr></table></figure><p>也可以手动下载源码，并拷贝到NAMD解压后的目录。</p><p>修改配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&quot;s%\$(HOME)%`pwd`%&quot;</span> arch/Linux-ARM64.tcl</span><br></pre></td></tr></table></figure><h3 id="配置NAMD-ARCH的变量"><a href="#配置NAMD-ARCH的变量" class="headerlink" title="配置NAMD ARCH的变量"></a>配置NAMD ARCH的变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&quot;s/multicore-arm7/mpi-linux-aarch64/&quot;</span> arch/Linux-ARM64-g++.arch</span><br></pre></td></tr></table></figure><h3 id="编译NAMD"><a href="#编译NAMD" class="headerlink" title="编译NAMD"></a>编译NAMD</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./config  Linux-ARM64-g++ --charm-arch mpi-linux-aarch64 \</span><br><span class="line"> --with-fftw --with-tcl</span><br><span class="line"><span class="built_in">cd</span> Linux-ARM64-g++</span><br><span class="line">time make -j8 2&gt;&amp;1 | tee m.log</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><p>编译过程大约几分钟。</p><h3 id="配置运行环境"><a href="#配置运行环境" class="headerlink" title="配置运行环境"></a>配置运行环境</h3><p>安装后的NAMD可以将其拷贝到目标目录，并设置PATH路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSTALL_DIR=<span class="variable">$HOME</span>/software/namd/2.12</span><br><span class="line">mkdir -p <span class="variable">$INSTALL_DIR</span></span><br><span class="line">cp Linux-ARM64-g++/charmrun <span class="variable">$INSTALL_DIR</span></span><br><span class="line">cp Linux-ARM64-g++/namd2 <span class="variable">$INSTALL_DIR</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$INSTALL_DIR</span>:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>The Apoa1 example is a standard NAMD cross-platform benchmark. For more information on the Apoa1 example, see the NAMD website.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.ks.uiuc.edu/Research/namd/utilities/apoa1.tar.gz</span><br><span class="line">tar -xf apoa1.tar.gz</span><br><span class="line">mpirun -np 16 namd2  apoa1/apoa1.namd </span><br></pre></td></tr></table></figure><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><ol><li><a href="https://developer.arm.com/products/software-development-tools/hpc/resources/porting-and-tuning/building-namd-with-arm-compiler">官网关于单节点多核版本的安装说明</a></li><li>有关NAMD的更多信息，请访问 <a href="http://www.ks.uiuc.edu/Research/namd/">NAMD</a> 官网。</li><li>关于ARM平台应用程序移植和优化，请访问 <a href="https://blog.mrzhenggang.com/">Mr.ZhengGang</a>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 应用软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> namd </tag>
            
            <tag> arm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ANGSD 编译安装教程</title>
      <link href="//angsd-install/"/>
      <url>//angsd-install/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ANGSD: Analysis of next generation Sequencing Data 下一代测序数据的分析</p><p>ANGSD是一种用于分析下一代测序数据的软件。 该软件可以处理从映射读数到推算基因型概率的许多不同输入类型。 大多数方法都考虑了基因型不确定性，而不是基于被称为基因型的分析。 这对于低深度和中深度数据尤其有用。 该软件是用C++编写的，并且已经用于大样本量。</p><span id="more"></span><p>官网：<a href="http://www.popgen.dk/angsd/index.php/ANGSD">http://www.popgen.dk/angsd/index.php/ANGSD</a></p><p>下载：<a href="https://codeload.github.com/ANGSD/angsd/tar.gz/0.921">https://codeload.github.com/ANGSD/angsd/tar.gz/0.921</a></p><h2 id="安装CURL"><a href="#安装CURL" class="headerlink" title="安装CURL"></a>安装CURL</h2><p>cURL包中包含一个实用程序和一个库，用于将具有URL语法的文件传输到以下任何协议：FTP，FTPS，HTTP，HTTPS，SCP，SFTP，TFTP，TELNET，DICT，LDAP，LDAPS和FILE。 它可以将下载和上传文件的功能合并到其他程序中，以支持流媒体等功能。</p><p>官网：<a href="https://curl.haxx.se/">https://curl.haxx.se</a></p><p>下载：<a href="https://curl.haxx.se/download/curl-7.35.0.tar.bz2">https://curl.haxx.se/download/curl-7.35.0.tar.bz2</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf curl-7.60.0.tar.gz </span><br><span class="line"><span class="built_in">cd</span> curl-7.60.0</span><br><span class="line">time ./configure CC=gcc \</span><br><span class="line">--prefix=<span class="variable">$HOME</span>/software/nscc/curl-7.60.0 2&gt;&amp;1 | tee c.lo</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="安装XZ"><a href="#安装XZ" class="headerlink" title="安装XZ"></a>安装XZ</h2><p>XZ Utils是一款免费的通用数据压缩软件，具有高压缩比。 XZ Utils是为类似POSIX的系统编写的，但也适用于一些不那么POSIX系统。 XZ Utils是LZMA Utils的继承者。</p><p>官网：<a href="https://tukaani.org/xz/">https://tukaani.org/xz/</a></p><p>下载：<a href="https://sourceforge.net/projects/lzmautils/files/xz-5.2.4.tar.gz/download">https://sourceforge.net/projects/lzmautils/files/xz-5.2.4.tar.gz/download</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf xz-5.2.4.tar.gz</span><br><span class="line"><span class="built_in">cd</span> xz-5.2.4</span><br><span class="line">./configure CC=gcc \</span><br><span class="line">--prefix=<span class="variable">$HOME</span>/software/xz-5.2.4 \</span><br><span class="line">2&gt;&amp;1 | tee c.log</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="安装htslib"><a href="#安装htslib" class="headerlink" title="安装htslib"></a>安装htslib</h2><p>HTSlib — A C library for reading/writing high-throughput sequencing data.</p><p>官网：<a href="http://www.htslib.org/">http://www.htslib.org/</a></p><p>下载：<a href="https://github.com/samtools/htslib/archive/1.8.tar.gz">https://github.com/samtools/htslib/archive/1.8.tar.gz</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf htslib-1.8.tar.gz</span><br><span class="line"><span class="built_in">cd</span> htslib-1.8</span><br><span class="line">time ./configure CC=gcc \</span><br><span class="line">CFLAGS=<span class="string">&quot;-I<span class="variable">$HOME</span>/software/xz-5.2.4/include \</span></span><br><span class="line"><span class="string">-I<span class="variable">$HOME</span>/software/curl-7.60.0/include&quot;</span> \</span><br><span class="line">LDFLAGS=<span class="string">&quot;-L<span class="variable">$HOME</span>/software/xz-5.2.4/lib \</span></span><br><span class="line"><span class="string">-L<span class="variable">$HOME</span>/software/curl-7.60.0/lib&quot;</span> \</span><br><span class="line">--prefix=<span class="variable">$HOME</span>/software/htslib-1.8 \</span><br><span class="line">--enable-libcurl \</span><br><span class="line">2&gt;&amp;1 | tee c.log</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="安装angds"><a href="#安装angds" class="headerlink" title="安装angds"></a>安装angds</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf angsd-0.921.tar.gz</span><br><span class="line"><span class="comment"># 修改Makefile文件，设置安装路径</span></span><br><span class="line">sed -i <span class="string">&quot;s%prefix      = /usr/local%prefix      = \$&#123;PREFIX&#125;%&quot;</span> Makefile </span><br><span class="line"><span class="built_in">export</span> CC=gcc CXX=g++</span><br><span class="line">time make PREFIX=<span class="variable">$HOME</span>/software/angsd-0.921 \</span><br><span class="line">HTSSRC=<span class="variable">$HOME</span>/software/nscc/packages/htslib-1.8 \</span><br><span class="line">LDFLAGS=<span class="string">&quot;-L<span class="variable">$HOME</span>/software/xz-5.2.4/lib \</span></span><br><span class="line"><span class="string">-L<span class="variable">$HOME</span>/software/curl-7.60.0/lib&quot;</span> \</span><br><span class="line">install </span><br><span class="line">2&gt;&amp;1 |tee  m.log</span><br></pre></td></tr></table></figure><p>备注：设置HTSSRC变量，并没有给出安装后的路径，而是源码路径。是为了找到头文件和库的位置，如果给出安装后的路径，就需要修改Makefile中的HTS_INCDIR和HTS_LIBDID.</p><h2 id="设置运行环境"><a href="#设置运行环境" class="headerlink" title="设置运行环境"></a>设置运行环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> INSTALL_DIR=<span class="variable">$HOME</span>/software</span><br><span class="line"><span class="built_in">export</span> CURL_DIR=<span class="variable">$INSTALL_DIR</span>/curl-7.60.0</span><br><span class="line"><span class="built_in">export</span> XZ_DIR=<span class="variable">$INSTALL_DIR</span>/xz-5.2.4</span><br><span class="line"><span class="built_in">export</span> HTSLIB_DIR=<span class="variable">$INSTALL_DIR</span>/htslib-1.8</span><br><span class="line"><span class="built_in">export</span> ANGSD_DIR=<span class="variable">$INSTALL_DIR</span>/angsd-0.921</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$CURL_DIR</span>/bin:<span class="variable">$XZ_DIR</span>/bin:<span class="variable">$HTSLIB_DIR</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ANGSD_DIR</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$CURL_DIR</span>/lib:<span class="variable">$XZ_DIR</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRRAY_PATH=<span class="variable">$HTSLIB_DIR</span>/lib:<span class="variable">$ANGSD_DIR</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 应用软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angsd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc编译安装教程</title>
      <link href="//gcc-install/"/>
      <url>//gcc-install/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>GNU 编译器套件（GNU Compiler Collection）包括 C、 C++、 Objective-C、 Fortran、 Java、Ada 和 Go 语言的前端，也包括了这些语言的库（如 libstdc++、 libgcj 等等）。</p><span id="more"></span><p>官网地址：<a href="http://gcc.gnu.org/">传送门</a>。</p><h2 id="编译-4-9-4版本"><a href="#编译-4-9-4版本" class="headerlink" title="编译 4.9.4版本"></a>编译 4.9.4版本</h2><h3 id="下载相关依赖包"><a href="#下载相关依赖包" class="headerlink" title="下载相关依赖包"></a>下载相关依赖包</h3><p>GCC 4.9.4 released [2016-08-03]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GCC</span></span><br><span class="line">ftp://gcc.gnu.org/pub/gcc/releases/gcc-4.9.4/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Necessary to build GCC. </span></span><br><span class="line"><span class="comment"># 当您使用的系统不能直接链接互联网的时候，可以手动下载依赖包</span></span><br><span class="line"><span class="comment"># 否者就不需要手动下载了</span></span><br><span class="line"></span><br><span class="line">MPFR=mpfr-2.4.2</span><br><span class="line">ftp://gcc.gnu.org/pub/gcc/infrastructure/mpfr-2.4.2.tar.bz2</span><br><span class="line">GMP=gmp-4.3.2</span><br><span class="line">ftp://gcc.gnu.org/pub/gcc/infrastructure/gmp-4.3.2.tar.bz2</span><br><span class="line">MPC=mpc-0.8.1</span><br><span class="line">ftp://gcc.gnu.org/pub/gcc/infrastructure/mpc-0.8.1.tar.gz</span><br><span class="line"><span class="comment"># Necessary to build GCC with the Graphite loop optimizations.</span></span><br><span class="line">ISL=isl-0.12.2</span><br><span class="line">ftp://gcc.gnu.org/pub/gcc/infrastructure/isl-0.12.2.tar.bz2</span><br><span class="line">CLOOG=cloog-0.18.1</span><br><span class="line">ftp://gcc.gnu.org/pub/gcc/infrastructure/cloog-0.18.1.tar.gz</span><br></pre></td></tr></table></figure><blockquote><p>备注：怎么知道下载哪些依赖包呢？<br>vim ./contrib/download_prerequisites<br>查看所需的依赖库的下载了路径，例如：<br>MPFR=mpfr-2.4.2<br>wget <a href="ftp://gcc.gnu.org/pub/gcc/infrastructure/$MPFR.tar.bz2">ftp://gcc.gnu.org/pub/gcc/infrastructure/$MPFR.tar.bz2</a> || exit 1<br>因此，mpfr 的下载路径为：<br><a href="ftp://gcc.gnu.org/pub/gcc/infrastructure/mpfr-2.4.2.tar.bz2">ftp://gcc.gnu.org/pub/gcc/infrastructure/mpfr-2.4.2.tar.bz2</a></p></blockquote><h3 id="配置依赖文件"><a href="#配置依赖文件" class="headerlink" title="配置依赖文件"></a>配置依赖文件</h3><p>1）将下载的压缩包上传，现将 gcc-4.9.4.tar.bz2 压缩包解压缩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar jxvf gcc-4.9.4.tar.bz2</span><br></pre></td></tr></table></figure><p>2）然后将其他依赖包移动至解压后的 gcc-4.9.4 文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv mpfr-2.4.2.tar.bz2 gmp-4.3.2.tar.bz mpc-0.8.1.tar.gz \</span><br><span class="line">  mpc-0.8.1.tar.gz cloog-0.18.1.tar.gz gcc-4.9.4</span><br></pre></td></tr></table></figure><p>3）修改 download_prerequisites 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ./gcc-4.9.4/contrib/download_prerequisites</span><br></pre></td></tr></table></figure><p>在带有 wget 的每一行最前面添加“#”字符，将其注释掉</p><p>4）配置依赖文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> gcc-4.9.4</span><br><span class="line">./contrib/download_prerequisites</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><h3 id="编译-gcc"><a href="#编译-gcc" class="headerlink" title="编译 gcc"></a>编译 gcc</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mkdir gcc-build-4.9.4</span><br><span class="line"><span class="built_in">cd</span> gcc-build-4.9.4</span><br><span class="line">../gcc-4.9.4/configure \</span><br><span class="line">  --prefix=<span class="variable">$HOME</span>/software/gcc/4.9.4 \</span><br><span class="line">  --enable-bootstrap \</span><br><span class="line">  --enable-shared \</span><br><span class="line">  --enable-checking=release \</span><br><span class="line">  --enable-threads=posix \</span><br><span class="line">  --enable-languages=all \</span><br><span class="line">  --with-system-zlib \</span><br><span class="line">  --enable-__cxa_atexit \</span><br><span class="line">  --build=x86_64-kylin-linux \</span><br><span class="line">  2&gt;&amp;1 | tee configure.log</span><br><span class="line">make -j12</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$HOME</span>/software/gcc/4.9.4/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$HOME</span>/software/gcc/4.9.4/lib64:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gcc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>citrix 安装记录及报错记录</title>
      <link href="//citrix-install/"/>
      <url>//citrix-install/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Citrix"><a href="#安装Citrix" class="headerlink" title="安装Citrix"></a>安装Citrix</h2><p>我下载了Citrix的4.5版本安装成功，安装过程如下。</p><p>下载地址：<a href="https://downloads.citrix.com/12343/CitrixReceiver.exe?__gda__=1525850932_45326f77dc844c1c50110ff2c417c0cd">传送门</a> </p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/citrix/citrix-1.jpg" alt="开始安装"></p><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/citrix/citrix-2.jpg" alt="同意协议"></p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/citrix/citrix-3.jpg" alt="正在安装"></p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/citrix/citrix-4.jpg" alt="完成安装"></p><h2 id="报错记录：未能注册模块-DVCRenderingAdpater-dll"><a href="#报错记录：未能注册模块-DVCRenderingAdpater-dll" class="headerlink" title="报错记录：未能注册模块 DVCRenderingAdpater.dll"></a>报错记录：未能注册模块 DVCRenderingAdpater.dll</h2><p>安装CitrixReceiver.exe的时候报错了， 报错为“<strong>未能注册模块 DVCRenderingAdpater.dll</strong>”。</p><p>如下截图：</p><p>操作系统：<strong>Win7 64位 旗舰版</strong></p><p>Citrix版本：4.11 （截至2018.5.9最新）</p><p>百度许久未果，猜测和版本有关，尝试降低版本安装，安装4.5版本成功。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/citrix/citrix-5.jpg" alt="安装报错"></p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/citrix/citrix-6.jpg" alt="安装报错"></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ul><li><a href="https://www.citrix.com.cn/">Citrix中文官网</a></li><li><a href="https://downloadplugins.citrix.com/Windows/CitrixReceiver.exe">Citrix最新版本点击下载</a></li><li><a href="https://www.citrix.com.cn/downloads/citrix-receiver/legacy-receiver-for-windows/">Citrix多个旧版本网址</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 可视化软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> citrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R编译安装教程</title>
      <link href="//R-install/"/>
      <url>//R-install/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>R是用于统计分析、绘图的语言和操作环境。R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。</p><span id="more"></span><p>官网地址：<a href="https://www.r-project.org/">传送门</a>。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>在集群上安装R环境，安装R-3.0.0版本的时候比较顺利，安装最新版本R-3.4.4的时候，由于依赖比较多且软件版本要求比较新，故需要预先安装很多包，否则报错。</p><p>我走通流程后将其记录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置安装目录</span></span><br><span class="line">R_INSTALL_DIR=<span class="variable">$HOME</span>/software/R-3.4.4</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$R_INSTALL_DIR</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># zlib</span></span><br><span class="line">tar zxvf zlib-1.2.11.tar.gz</span><br><span class="line"><span class="built_in">cd</span> zlib-1.2.11</span><br><span class="line">./configure --prefix=<span class="variable">$R_INSTALL_DIR</span></span><br><span class="line">make -j 12</span><br><span class="line">make install</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># bzip</span></span><br><span class="line">tar zxvf bzip2-1.0.6.tar.gz </span><br><span class="line"><span class="built_in">cd</span> bzip2-1.0.6</span><br><span class="line">make -j 12</span><br><span class="line">make install PREFIX=<span class="variable">$R_INSTALL_DIR</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># xz</span></span><br><span class="line">tar zxvf xz-5.2.3.tar.gz</span><br><span class="line"><span class="built_in">cd</span> xz-5.2.3</span><br><span class="line">./configure --prefix=<span class="variable">$R_INSTALL_DIR</span></span><br><span class="line">make -j 12</span><br><span class="line">make install</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># pcre  &quot;--enable-utf8&quot; 因为提示需要支持这个，而默认是关闭的</span></span><br><span class="line">tar zxvf pcre-8.42.tar.gz </span><br><span class="line"><span class="built_in">cd</span> pcre-8.42</span><br><span class="line">./configure --prefix=<span class="variable">$R_INSTALL_DIR</span> --enable-utf8</span><br><span class="line">make -j 12</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># curl</span></span><br><span class="line">tar zxvf curl-7.59.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> curl-7.59.0</span><br><span class="line">./configure --prefix=<span class="variable">$R_INSTALL_DIR</span></span><br><span class="line">make -j 12</span><br><span class="line">make install</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># R</span></span><br><span class="line">tar zxvf R-3.4.4.tar.gz </span><br><span class="line"><span class="built_in">cd</span> R-3.4.4</span><br><span class="line">./configure --prefix=<span class="variable">$R_INSTALL_DIR</span> \</span><br><span class="line">  CPPFLAGS=<span class="string">&quot;-I<span class="variable">$R_INSTALL_DIR</span>/include&quot;</span> \</span><br><span class="line">  LDFLAGS=<span class="string">&quot;-L<span class="variable">$R_INSTALL_DIR</span>/lib&quot;</span></span><br><span class="line">make -j 12</span><br><span class="line">make install</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swash编译安装教程</title>
      <link href="//swap-install/"/>
      <url>//swap-install/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SWASH是一个通用的数值计算工具，用于模拟非稳态、非流体静力学的、自由表面的或旋转的流动，以及以及由波浪、潮汐、浮力或风力驱动的沿海水域的运输现象。</p><span id="more"></span><p>官网地址：<a href="http://swash.sourceforge.net/">传送门</a>；<br>源码下载：<a href="http://swash.sourceforge.net/download/zip/swash-4.01.tar.gz">传送门</a>。</p><h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><p>串行版需要fortran编译器，多线程版本需要支持openmp，MPI版本需要具备mpi编译环境。</p><h2 id="编译方法"><a href="#编译方法" class="headerlink" title="编译方法"></a>编译方法</h2><p>本文给出使用intel2013编译器和mpich并行编译器编译的基本步骤：</p><h3 id="加载编译环境"><a href="#加载编译环境" class="headerlink" title="加载编译环境"></a>加载编译环境</h3><p>不同的平台，编译器的安装及加载方式不同，在此给出最常见的加载方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /opt/intel/composer_xe_2013.0.079/bin/iccvars.sh intel64</span><br><span class="line"><span class="built_in">source</span> /opt/intel/composer_xe_2013.0.079/bin/ifortvars.sh intel64</span><br><span class="line"><span class="built_in">source</span> /opt/intel/composer_xe_2013.0.079/mkl/bin/mklvars.sh intel64</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>前两行为加载icc（包括icpc等）及ifort编译器。使用source命令，加载编译器安装路径下的的sh脚本，并给出intel64参数，表明是64位操作系统。</li><li>第三行与之前的类似，加载intel的MKL数学库，因为接下来会用到它。注意修改为自己的intel编译器路径。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/mpi-intel2013/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/mpi-intel2013/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>第一行为使用 export 命令，声明环境变量 PATH ，它是用来寻找可执行命令路径的环境变量。先给出mpich的安装路径下的bin目录，然后在用 “$” 符号引用 PATH 变量。意味着给 PATH 变量增加一个搜索路径，这样子就能找到我们需要的例如 mpif90命令了。</li><li>第二行与第一行类似， LD_LIBRARY_PATH 声明的是加载动态库的路径。<br>注意修改为自己的mpi编译器路径。</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf swash-4.0.1.tar.gz  </span><br><span class="line"><span class="built_in">cd</span> swash</span><br><span class="line">make config</span><br><span class="line">make mpi</span><br><span class="line">chmod +x swashrun</span><br></pre></td></tr></table></figure><p>编译完成后会生成一个名为swash.exe的可执行文件。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="普通运行"><a href="#普通运行" class="headerlink" title="普通运行"></a>普通运行</h3><p>准备好输入文件，如test.sws，a13stwav.bot。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/path/to/swash/swashrun -input <span class="built_in">test</span> -mpi 12 &gt; swashout</span><br></pre></td></tr></table></figure><p>说明：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>/path/to/swash/swashrun</td><td>swashrun脚本的路径和名称</td></tr><tr><td>-input test</td><td>输入文件的名称，注意没有sws后缀</td></tr><tr><td>-mpi 12</td><td>使用12个cpu核并行</td></tr><tr><td>&gt; swashout</td><td>将屏幕输入重定向到swashout文件</td></tr></tbody></table><h3 id="在天河系统上运行"><a href="#在天河系统上运行" class="headerlink" title="在天河系统上运行"></a>在天河系统上运行</h3><p>因为天河系统使用了自主高速网络互联以及slurm作业调度系统，故默认的mpirun变为了yhrun命令，所以需要手动修改一下swashrun脚本，并结合作业调度系统运行。</p><p><strong>修改swashrun脚本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第50行</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -f <span class="variable">$dir</span>/mpirun; <span class="keyword">then</span> <span class="comment"># 修改前</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -f <span class="variable">$dir</span>/yhrun; <span class="keyword">then</span> <span class="comment"># 修改后</span></span><br><span class="line"><span class="comment"># 第109行</span></span><br><span class="line">mpirun -np <span class="variable">$npmpi</span> -machinefile machinefile swash.exe  <span class="comment"># 修改前</span></span><br><span class="line">yhrun -n <span class="variable">$npmpi</span> swash.exe  <span class="comment"># 修改后</span></span><br><span class="line"><span class="comment"># 第114行</span></span><br><span class="line">mpirun -p <span class="variable">$npmpi</span> swash.exe <span class="comment"># 修改前</span></span><br><span class="line">yhrun -p <span class="variable">$npmpi</span> swash.exe <span class="comment"># 修改后</span></span><br></pre></td></tr></table></figure><p><strong>编写作业提交脚本</strong></p><p>编写一个作业提交脚本，名为runswash.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># change these parameters for each jobs as your need</span></span><br><span class="line">nodenum=2   <span class="comment"># node number</span></span><br><span class="line">cpuspernode=12   <span class="comment"># cpu number per node</span></span><br><span class="line">partition=<span class="string">&quot;debug&quot;</span>  <span class="comment"># partition : debug (only for test, just can run 30mis) or TH_NEW1</span></span><br><span class="line">input=<span class="string">&quot;test&quot;</span>  <span class="comment"># input file </span></span><br><span class="line">logfile=<span class="string">&quot;swashout&quot;</span> <span class="comment"># log file </span></span><br><span class="line">SWASHROOT=<span class="string">&quot;/vol-th/software/swash/4.0.1&quot;</span> <span class="comment"># change only once for your install directory</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------                     </span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$SWASHROOT</span>:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">exe=<span class="string">&quot;swashrun-th&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">totalcpus=$[ <span class="variable">$nodenum</span> * <span class="variable">$cpuspernode</span> ]</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># create a submit script file</span></span><br><span class="line">subScript=<span class="string">&quot;sub.sh&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># rename sub.sh</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="variable">$subScript</span> ];<span class="keyword">then</span></span><br><span class="line">    mv <span class="variable">$subScript</span> <span class="variable">$&#123;subScript&#125;</span>-bak</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># create sub.sh</span></span><br><span class="line">\cat &gt; <span class="variable">$subScript</span> &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">#!/bin/bash</span></span><br><span class="line"><span class="string">echo &quot;Partition is $partition&quot;</span></span><br><span class="line"><span class="string">echo &quot;totalcpus is $totalcpus&quot;</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># write hostlist</span></span><br><span class="line"><span class="string">yhrun -N $nodenum -n $totalcpus -p $partition hostname | sort -n | uniq &gt; .hostlist</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># reame machinefile</span></span><br><span class="line"><span class="string">if [ -f machinefile ];then</span></span><br><span class="line"><span class="string">    mv machinefile machinefile-bak</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string"># create machinefile</span></span><br><span class="line"><span class="string">cat .hostlist | while read line;</span></span><br><span class="line"><span class="string">do</span></span><br><span class="line"><span class="string">    echo \$line:$cpuspernode &gt;&gt; machinefile</span></span><br><span class="line"><span class="string">done</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># swashrun</span></span><br><span class="line"><span class="string">$exe -input $input -mpi $totalcpus &gt; $logfile </span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># submit job</span></span><br><span class="line">yhbatch -N <span class="variable">$nodenum</span> -n <span class="variable">$totalcpus</span> -p <span class="variable">$partition</span> <span class="variable">$subScript</span></span><br></pre></td></tr></table></figure><p><strong>提交任务</strong><br>由于将该任务所需的信息均已在脚本中提供，故仅需要提交该脚本即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh runswash.sh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 应用软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在lammps里加入新的势函数形式?</title>
      <link href="//how-to-add-a-new-potential-function-form-to-lammps/"/>
      <url>//how-to-add-a-new-potential-function-form-to-lammps/</url>
      
        <content type="html"><![CDATA[<h2 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h2><p>参考官方手册，先看看：<a href="http://lammps.sandia.gov/doc/Manual.html">传送门</a>。</p><span id="more"></span><h2 id="自己编程"><a href="#自己编程" class="headerlink" title="自己编程"></a>自己编程</h2><p>如果没有，就自己写吧。</p><p>可以先参考已经有的势函数，弄清楚框架和写法，再写自己的。有的时候不仅要写 .cpp 文件，还要写一个 .h 头文件。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>把写好的东东放在lammps/src目录，然后按照以前的方法make即可。</p><p>可以参考文章：<a href="https://blog.mrzhenggang.com/lammps-install">lammps 编译安装教程 </a>。</p>]]></content>
      
      
      <categories>
          
          <category> 应用软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lammps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MOLPRO安装使用说明</title>
      <link href="//molpro-install/"/>
      <url>//molpro-install/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MOLPRO是国际上广泛使用的专业级电子结构量化计算软件，由H.-J. Werner和P. J. Knowles负责设计和维护。不同于其它的量子化学软件包，MOLPRO的重点是高精度计算，通过多参考CI，耦合簇和有关的方法，广泛处理电子相关问题。使用最近开发的直接积分局域电子相关方法，可以极大地减少随分子尺寸增加的计算量，能够对更大的分子体系进行准确的从头计算。程序的核心是MCSCF，MR-CI，和耦合簇程序，以及一系列附加功能。 主页可以申请试用版。</p><span id="more"></span><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://www.molpro.net/download">官方下载地址</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>将下载到预先编译的脚本文件molpro-mpp-2015.1.20.ompi.sh上传到系统上，添加可执行权限，直接执行即可安装。</p><h3 id="创建目录（如果不存在则创建，否则安装过程报错找不到）"><a href="#创建目录（如果不存在则创建，否则安装过程报错找不到）" class="headerlink" title="创建目录（如果不存在则创建，否则安装过程报错找不到）"></a>创建目录（如果不存在则创建，否则安装过程报错找不到）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/software/molpro/2015/bin</span><br></pre></td></tr></table></figure><h3 id="添加脚本可执行权限"><a href="#添加脚本可执行权限" class="headerlink" title="添加脚本可执行权限"></a>添加脚本可执行权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x molpro-mpp-2015.1.20.ompi.sh <span class="comment"># 下载到预先编译好的脚本文件</span></span><br></pre></td></tr></table></figure><h3 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">./molpro-mpp-2015.1.20.ompi.sh</span><br><span class="line"></span><br><span class="line">Enter bin directory to link Molpro (optional) []</span><br><span class="line"><span class="variable">$HOME</span>/software/molpro/2015/bin</span><br><span class="line">Enter installation directory <span class="keyword">for</span> Molpro files </span><br><span class="line">[/usr/<span class="built_in">local</span>/molpro/molprop_2015_1_linux_x86_64_i8]</span><br><span class="line"><span class="variable">$HOME</span>/software/molpro/2015/molprop_2015_1_linux_x86_64_i8</span><br><span class="line">Installation of Molpro files complete</span><br><span class="line">Please give your username <span class="keyword">for</span> accessing molpro</span><br><span class="line">    <span class="comment"># 直接回车</span></span><br><span class="line">Please give your password <span class="keyword">for</span> accessing molpro</span><br><span class="line">    <span class="comment"># 直接回车</span></span><br><span class="line">Token download unsuccessful - please install manually</span><br></pre></td></tr></table></figure><h2 id="配置Token"><a href="#配置Token" class="headerlink" title="配置Token"></a>配置Token</h2><p>配置Token可以在对应的lib文件夹添加.token文件，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/software/molpro/2015/molprop_2015_1_linux_x86_64_i8/lib</span><br><span class="line">vim .token</span><br><span class="line">id=***,date=:2025/02/05,version=:2015,mpp=32767,modules=mpp,password=******</span><br></pre></td></tr></table></figure><p>然后写入你的账户密码信息，保存即可。<br>也可以声明环境变量，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> MOLPRO_KEY=<span class="string">&quot;id=***,date=:2025/02/05,version=:2015,\</span></span><br><span class="line"><span class="string">    mpp=32767,modules=mpp,password=******&quot;</span></span><br></pre></td></tr></table></figure><h2 id="额外配置"><a href="#额外配置" class="headerlink" title="额外配置*"></a>额外配置*</h2><p>在实际测试过程中，发现有时候会缺少lscpu命令，所以我们从登陆节点拷贝一份到bin目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/bin/lscpu <span class="variable">$HOME</span>/software/molpro/2015/molprop_2015_1_linux_x86_64_i8/bin</span><br></pre></td></tr></table></figure><h2 id="默认提交"><a href="#默认提交" class="headerlink" title="默认提交"></a>默认提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认输出文件明.out</span></span><br><span class="line">molpro h2o.inp </span><br><span class="line"><span class="comment"># 不保存已有.out文件，而是重写</span></span><br><span class="line">molpro -s h2o.inp</span><br><span class="line"><span class="comment"># 指定输出文件名</span></span><br><span class="line">molpro -o water.output h2o.inp </span><br><span class="line"><span class="comment"># 设置使用内存</span></span><br><span class="line">molpro -m 4M h2o.inp</span><br><span class="line"><span class="comment"># 8核并行</span></span><br><span class="line">molpro -n 8 h2o.inp</span><br><span class="line"><span class="comment"># 设置临时目录，默认为/tmp/$USER;设置TMPDIR变量，或-d 参数指定</span></span><br><span class="line">molpro -d /scratch/<span class="variable">$USER</span> h2o.inp </span><br></pre></td></tr></table></figure><h2 id="使用slurm作业管理系统提交"><a href="#使用slurm作业管理系统提交" class="headerlink" title="使用slurm作业管理系统提交"></a>使用slurm作业管理系统提交</h2><p>因为使用作业管理系统提交任务的时候，它会自动将 <code>-n</code> 给定的值为环境变量允许的最大值的上限，并且跨节点并行有些问题，这并不是我们想要的，所以我就写了一个脚本，如果想要，欢迎给我留言。</p>]]></content>
      
      
      <categories>
          
          <category> 商业软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> molpro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译程序的四个过程简介</title>
      <link href="//the-most-basic-introduction-to-compilation/"/>
      <url>//the-most-basic-introduction-to-compilation/</url>
      
        <content type="html"><![CDATA[<p>简要介绍编译、编译器和编译过程</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>将人类比较容易理解的高级语言（例如C/C++，FORTRAN等），“翻译”为，计算机能够识别的二进制语言。</p><span id="more"></span><h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>编译器就是将“一种语言（通常为高级语言）”翻译为“另一种语言（通常为低级语言）”的程序。</p><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><ol><li>预处理</li><li>编译</li><li>汇编</li><li>链接</li></ol><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>编写源代码hello.c：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细过程：<br>将源代码hello.c，通过预处理器cpp，生成预处理后的中间文件hello.i（还是源码语言）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure><p>将预处理后的文件hello.i，通过编译器cc1，生成汇编文件hello.s（汇编语言）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure><p>将汇编文件hello.s，通过汇编器as，生成目标文件hello.o（二进制语言）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure><p>将目标文件，通过链接器ld，链接成一个可执行的文件hello</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure><p>一般情况下，gcc会替我们做这些事儿。直接输入下面的命令，就能自动完成一些列操作了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.cpp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CP2K编译安装教程</title>
      <link href="//cp2k-install/"/>
      <url>//cp2k-install/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CP2K是一种量子化学和固态物理软件包，可以执行固态，液态，分子，周期，材料，晶体和生物系统的原子模拟。 CP2K为不同的建模方法提供了一般框架，例如使用混合高斯和DFT的DFT接近GPW和GAPW。</p><span id="more"></span><p>链接：<a href="https://www.cp2k.org/">官网地址</a>，<a href="https://github.com/cp2k/cp2k/releases">下载地址</a></p><h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><p>cp2k 支持 multi-threading, MPI, and CUDA </p><p>单线程版本只需要串行编译器即可，多线程版本需要编译器支持例如-fopenmp参数，MPI版本需要MPI编译器，CUDA版本需要CUDA编译器。</p><p>本文仅介绍前两种，针对CUDA的编译暂略。</p><p>设置编译环境举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置intel编译器环境</span></span><br><span class="line"><span class="built_in">source</span> /opt/intel/composer_xe_2013.0.079/bin/iccvars.sh intel64</span><br><span class="line"><span class="built_in">source</span> /opt/intel/composer_xe_2013.0.079/bin/ifortvars.sh intel64</span><br><span class="line"><span class="built_in">source</span> /opt/intel/composer_xe_2013.0.079/mkl/bin/mklvars.sh intel64</span><br><span class="line"><span class="comment"># 设置mpi编译环境</span></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/mpi-intel2013/bin:<span class="variable">$PATH</span>  </span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/mpi-intel2013/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><h2 id="一些依赖库"><a href="#一些依赖库" class="headerlink" title="一些依赖库"></a>一些依赖库</h2><h3 id="BLAS-LAPACK"><a href="#BLAS-LAPACK" class="headerlink" title="BLAS/LAPACK"></a>BLAS/LAPACK</h3><p>使用Intel编译器，直接用MKL库即可。</p><h3 id="LIBINT"><a href="#LIBINT" class="headerlink" title="LIBINT"></a>LIBINT</h3><p>Libint is a software stack for computing integrals used in molecular quantum mechanics.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载:https://sourceforge.net/projects/libint/files/v1-releases/</span></span><br><span class="line">./configure CC=icc CXX=icpc FC=ifort \</span><br><span class="line">  --prefix=<span class="variable">$HOME</span>/software/libint-1.1.5 --enable-deriv</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="LIBXC"><a href="#LIBXC" class="headerlink" title="LIBXC"></a>LIBXC</h3><p>Libxc is a library of exchange-correlation functionals for density-functional theory. The aim is to provide a portable, well tested and reliable set of exchange and correlation functionals that can be used by all the ETSF codes and also other codes.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载：http://octopus-code.org/wiki/Libxc:download</span></span><br><span class="line">tar zxvf libxc-2.2.3.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libxc-2.2.3</span><br><span class="line">./configure CC=icc CXX=icpc FC=ifort --prefix=<span class="variable">$HOME</span>/libxc/2.2.3</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="编译cp2k"><a href="#编译cp2k" class="headerlink" title="编译cp2k"></a>编译cp2k</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf cp2k-4.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> cp2k-4.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为用的是mpich，所以修改mpi的编译命令</span></span><br><span class="line">sed -i <span class="string">&quot;s/mpiicpc/mpicxx/g&quot;</span> arch/Linux-x86-64-intel-mic.psmp </span><br><span class="line">sed -i <span class="string">&quot;s/mpiicc/mpicc/g&quot;</span> arch/Linux-x86-64-intel-mic.psmp</span><br><span class="line">sed -i <span class="string">&quot;s/mpiifort/mpif90/g&quot;</span> arch/Linux-x86-64-intel-mic.psmp</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> makefiles/</span><br><span class="line">make -j 12 ARCH=Linux-x86-64-intel-host \</span><br><span class="line">  VERSION=popt \</span><br><span class="line">  LIBINTROOT=<span class="variable">$HOME</span>/software/libint/1.1.5 \</span><br><span class="line">  LIBXCROOT=<span class="variable">$HOME</span>/software/libxc/2.2.3 \</span><br><span class="line">  MKL_STATIC=2</span><br></pre></td></tr></table></figure><p>说明：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-j 12</td><td>用 12 个核同时编译</td></tr><tr><td>ARCH=Linux-x86-64-intel-host</td><td>指定ARCH为linux系统，x86_64架构，用intel编译器</td></tr><tr><td>VERSION=popt</td><td>指定为mpi版本</td></tr><tr><td>LIBINTROOT=$HOME/software/libint/1.1.5</td><td>给出libint路径，不给出则不支持该库</td></tr><tr><td>LIBXCROOT=$HOME/software/libxc/2.2.3</td><td>给出libxc路径，不给出则不支持该库</td></tr><tr><td>MKL_STATIC=2</td><td>选择动态MKL库的支持</td></tr></tbody></table><p>备注：</p><ol><li>可以依据需求编译各种版本：<ul><li>sopt 串行</li><li>ssmp 多线程</li><li>popt mpi版本</li><li>psmp mpi+多线程</li></ul></li><li>网络上有一个非常详细的教程，可以参考：<ul><li><a href="http://www.doc88.com/p-3147489674051.html">cp2k4.x-5.x 最新多进程并行版(host.popt版)超详细完美安装教程</a></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 应用软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cp2k </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>slurm作业管理：一次提交运行多个任务</title>
      <link href="//slurm-submit-multiple-tasks-at-once/"/>
      <url>//slurm-submit-multiple-tasks-at-once/</url>
      
        <content type="html"><![CDATA[<p>针对抢占式的作业调度系统，如果分配节点时候是独占节点，那么每次申请的资源最少就是1个节点。如何实现一次提交作业，计算多个任务呢？（包括串行、openmp或mpi的任务）。最简单的方式就是按照自己的需求写一个运行脚本，然后通过作业管理系统提交即可。下面给出一个具体的例子加以说明，先给出实例，然后给出详细解释：</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/helloworld</span><br><span class="line">yhrun -N1 -n1 ./helloworld &amp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/gaussian</span><br><span class="line"><span class="built_in">export</span> OMP_NUM_THREADS=2 </span><br><span class="line">yhrun -N1 -n1 ./g09 &amp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/vasp</span><br><span class="line">yhrun -N1 -n3 ./vasp &amp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/lmp</span><br><span class="line"><span class="built_in">export</span> OMP_NUM_THREADS=3</span><br><span class="line">yhrun -N1 -n2 ./lmp &lt; in.lj &amp; </span><br><span class="line"></span><br><span class="line"><span class="built_in">wait</span></span><br></pre></td></tr></table></figure><p>详细解释如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 这是一个bash的脚本</span></span><br><span class="line"><span class="comment"># 脚本里面写什么，就会执行什么</span></span><br><span class="line"><span class="comment"># 我将会申请1个有12cpu核的计算节点，具体如何分配这些核做计算，我自己说了算</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先用1个核运行一个helloworld吧</span></span><br><span class="line"><span class="built_in">cd</span> ~/helloworld <span class="comment"># 进入到helloworld所在目录</span></span><br><span class="line">yhrun -N1 -n1 ./helloworld &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># yhrun 是天河系列的集群的&quot;mpirun&quot;</span></span><br><span class="line"><span class="comment"># -N1表示1个节点</span></span><br><span class="line"><span class="comment"># -n1表示一个核</span></span><br><span class="line"><span class="comment"># helloworld 是 可执行程序的名字</span></span><br><span class="line"><span class="comment"># &amp; 表示放到后台执行（计算节点的后台），如果不写的话，脚本就会卡在这一行，</span></span><br><span class="line"><span class="comment">#   直到执行完这一行，才会往下执行。而我们希望同时执行多个任务，所以放到后台</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再用2个核，运行一个openmp的程序吧</span></span><br><span class="line"><span class="built_in">cd</span> ~/gaussian</span><br><span class="line"><span class="built_in">export</span> OMP_NUM_THREADS=2 </span><br><span class="line">yhrun -N1 -n1 ./g09 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># OMP_NUM_THREADS=2 表示用OMP线程数=2</span></span><br><span class="line"><span class="comment"># ./g09 是一个openmp程序的名字（举例）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再用3个核，运行一个mpi的程序吧</span></span><br><span class="line"><span class="built_in">cd</span> ~/vasp</span><br><span class="line">yhrun -N1 -n3 ./vasp &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -n3 启用3个mpi进程，运行mpi任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后用6个核，运行一个mpi+openmp的程序吧</span></span><br><span class="line"><span class="built_in">cd</span> ~/lmp</span><br><span class="line"><span class="built_in">export</span> OMP_NUM_THREADS=3</span><br><span class="line">yhrun -N1 -n2 ./lmp &lt; in.lj &amp; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置n=2，omp=3 开启2个mpi进程，每个mpi进程开启3个omp线程</span></span><br><span class="line"><span class="comment"># ./lmp 是mpi+openmp的程序名</span></span><br><span class="line"><span class="comment"># &lt; in.lj 给定输入文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 末尾增加</span></span><br><span class="line"><span class="built_in">wait</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加wait，让脚本等待以上后台任务运行结束后再停止</span></span><br><span class="line"><span class="comment"># 不添加的话，脚本运行到末尾就结束了，作业也就结束了。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然，其实还有一种更为“精确”的控制每个进程运行哪个任务的高阶写法，但对于普通用户，一般没这个需求，故不在此介绍了。如确实有这个需求的欢迎留言。</p>]]></content>
      
      
      <categories>
          
          <category> 作业调度 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> slurm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>COMSOL安装教程</title>
      <link href="//comsol-install/"/>
      <url>//comsol-install/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>COMSOL 集团是全球多物理场建模解决方案的提倡者与领导者。凭借创新的团队、协作的文化、前沿的术、出色的产品，这家高科技工程软件公司正飞速发展，并有望成为行业领袖。其旗舰产品 COMSOL Multiphysics 使工程师和科学家们可以通过模拟，赋予设计理念以生命。它有无与伦比的能力，使所有的物理现象可以在计算机上完美重现。</p><span id="more"></span><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>例如， 购买的版本为： COMSOL52_1.iso。</p><h2 id="上传，解压缩"><a href="#上传，解压缩" class="headerlink" title="上传，解压缩"></a>上传，解压缩</h2><p>使用例如 winscp 等工具上传压缩包 COMSOL52_1.iso 及 license 文件 COMSOL52_1.lic。<br>使用 p7zip 工具解压缩， 命令为： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z x COMSOL52_1.iso</span><br></pre></td></tr></table></figure><p>备注：<br>如果系统未安装 p7zip 请自行下载安装。</p><h2 id="添加可执行权限"><a href="#添加可执行权限" class="headerlink" title="添加可执行权限"></a>添加可执行权限</h2><p>使用 cd 命令， 切换到解压后的路径，然后为文件添加可执行的权限，命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x -R .</span><br></pre></td></tr></table></figure><p>备注：<br>注意命令最后有一个“.”，表示当前路径。</p><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>使用如下命令启动交互界面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./setup</span><br></pre></td></tr></table></figure><p>备注：<br>请使用支持图形界面的终端软件， 例如 xmanager 中的 xstart， 设置如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/comsol/1.png"></p><p>运行上述命令后会弹出图形界面，请依照图形界面提示，进行软件安装。（类似 windows）</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/comsol/2.png"></p><p>选择“English”，或者选择“简体中文”，单击下一步“Next&gt;”。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/comsol/3.png"></p><p>单击“New COMSOL 5.2 Installation”， 进入下一步。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/comsol/4.png"></p><p>选择”I accept”，选择“License format” 为“License file”，单击”Browse”按钮，设置 lic 文件所在路径， 单击下一步“Next&gt;”。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/comsol/5.png"></p><p>点击“Browse…”弹出对话框，设置安装路径，或者手动输入安装路径。然后单击下一步“Next&gt;”。安装路径可以设置为用户账户目录下的任意位置。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/comsol/6.png"></p><p>取消“Check for updates”的勾选， 单击下一步“Next&gt;”。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/comsol/7.png"></p><p>单击“Install”， 软件进入正常安装，等待到达 100%即可。该过程依据不同的机器配置，需要的时间从几分钟到十几分钟不等。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/comsol/8.png"></p><p>安装完成后，单击“Close”关闭对话框。</p><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p>为了方便调用 COMSOL 及相关命令，将 COMSOL 的相关环节变量进行设置，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> COMSOL_HOME=<span class="variable">$HOME</span>/software/comsol/52/multiphysics</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$COMSOL_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> ARCH=glnxa64</span><br><span class="line"><span class="variable">$COMSOL_HOME</span>/bin/setuplibpath</span><br></pre></td></tr></table></figure><p>如果写入~/.bashrc 文件， 则可以在启动终端后自动运行该行命令。<br>备注：</p><ul><li>COMSOL_HOME 设置为安装目录。</li><li>ARCH 版本为 glnxa64， 可以前往$COMSOL_HOME/bin 文件夹查看 ARCH 类型</li></ul><h2 id="运行软件"><a href="#运行软件" class="headerlink" title="运行软件"></a>运行软件</h2><p>再次在终端输入”comsol”命令，启动图形界面如下，然后就可以正常使用该软件了。</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/comsol/9.png"></p><p>打开后如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/comsol/10.png"></p><p>至此就搞定了！</p>]]></content>
      
      
      <categories>
          
          <category> 商业软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> comsol </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VASP编译安装教程</title>
      <link href="//vasp-install/"/>
      <url>//vasp-install/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>VASP 全称 Vienna Ab-initio Simulation Package。它是维也纳大学 Hafner 小组开发的进行电子结构计算和量子力学-分子动力学模拟软件包。它是目前材料模拟和计算物质科学研究中最流行的商用软件之一。</p><span id="more"></span><p>官网地址：<a href="http://www.vasp.at/">传送门</a>。</p><p>截止目前（2017.4.22）的最新版本：<a href="http://www.vasp.at/index.PHP/news/44-administrative/118-new-release-vasp-5-4-4">VASP5.4.4简介</a>。</p><p>下载：商业软件，需要购买版权。</p><h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><p>VASP是FOTRAN语言编写的程序，需要先编译，然后才能运行可执行程序。</p><p>因此，需要安装编译器：</p><ul><li><a href="https://gcc.gnu.org/" title="gcc编译器官网">GNU Compiler </a></li><li><a href="https://software.intel.com/en-us/intel-compilers" title="intel编译器官网">INTEL Compiler</a></li></ul><p>以及MPI编译器（如果需要并行计算）：</p><ul><li><a href="http://www.mpich.org/" title="MPICH | High-Performance Portable MPI">MPICH</a></li><li><a href="https://www.open-mpi.org/" title="Open MPI | Open Source High Performance Computing">OPENMPI</a></li></ul><p>以及CUDA编译环境（如果需要GPU加速）：</p><ul><li><a href="https://developer.nvidia.com/cuda-downloads" title="CUDA官网下载页">CUDA</a></li></ul><p>安装neb版本需要下载额外的vtstcode：</p><ul><li><a href="http://theory.cm.utexas.edu/vtsttools/">Transition State Tools for VASP</a></li></ul><h2 id="编译方法"><a href="#编译方法" class="headerlink" title="编译方法"></a>编译方法</h2><p>我们购买VASP后会得到它的源码包，例如vasp5.4.4.tar.gz。在此我们介绍在linux平台下使用intel compiler 及 mpich 编译VASP的方法。</p><h3 id="加载编译环境"><a href="#加载编译环境" class="headerlink" title="加载编译环境"></a>加载编译环境</h3><p>不同的平台，编译器的安装及加载方式不同，在此给出最常见的加载方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /opt/intel/composer_xe_2013.0.079/bin/iccvars.sh intel64</span><br><span class="line"><span class="built_in">source</span> /opt/intel/composer_xe_2013.0.079/bin/ifortvars.sh intel64</span><br><span class="line"><span class="built_in">source</span> /opt/intel/composer_xe_2013.0.079/mkl/bin/mklvars.sh intel64</span><br></pre></td></tr></table></figure><p><strong>说明：</strong><br>前两行为加载icc（包括icpc等）及ifort编译器。使用source命令，加载编译器安装路径下的的sh脚本，并给出intel64参数，表明是64位操作系统。<br>第三行与之前的类似，加载intel的MKL数学库，因为接下来会用到它。<br>注意修改为自己的intel编译器路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/mpi-intel2013/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/mpi-intel2013/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><p><strong>说明：</strong><br>第一行为使用 export 命令，声明环境变量 PATH ，它是用来寻找可执行命令路径的环境变量。先给出mpich的安装路径下的bin目录，然后在用 “$” 符号引用 PATH 变量。意味着给 PATH 变量增加一个搜索路径，这样子就能找到我们需要的例如 mpif90命令了。<br>第二行与第一行类似， LD_LIBRARY_PATH 声明的是加载动态库的路径。<br>注意修改为自己的mpi编译器路径。</p><h3 id="修改makefile文件"><a href="#修改makefile文件" class="headerlink" title="修改makefile文件"></a>修改makefile文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf vasp.5.4.4.tar.gz</span><br><span class="line"><span class="built_in">cd</span> vasp.5.4.4</span><br><span class="line">cp ./arch/makefile.include.linux_intel makefile.include</span><br></pre></td></tr></table></figure><p>简要分析makefile.include，说几个我们可能会修改的部分吧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Precompiler options                 </span></span><br><span class="line">CPP_OPTIONS= -DHOST=\&quot;LinuxIFC\&quot;\</span><br><span class="line">             -DMPI -DMPI_BLOCK=8000 \</span><br><span class="line">             -Duse_collective \</span><br><span class="line">             -DscaLAPACK \</span><br><span class="line">             -DCACHE_SIZE=4000 \</span><br><span class="line">             -Davoidalloc \</span><br><span class="line">             -Duse_bse_te \</span><br><span class="line">             -Dtbdyn \</span><br><span class="line">             -Duse_shmem</span><br></pre></td></tr></table></figure><p>这部分是一些预编译选项，以前的版本中（5.3及以前），如果我们想让vasp支持自旋轨道耦合计算，就需要调整这个参数。但从5.4.1开始，默认情况下我们就可以编译出 std 、 ncl 及 gam 版本的vasp，所以暂时不需要手动修改了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FC         = mpiifort</span><br><span class="line">FCL        = mpiifort -mkl=sequential -lstdc++</span><br></pre></td></tr></table></figure><p>这部分是用来设定编译时候的编译器及链接参数。mpiifort是intel mpi的命令，我们使用的是mpich，所以这里需要修改一下，将以上两行中的“mpiifort”修改为“mpif90”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MKL_PATH   = $(MKLROOT)/lib/intel64</span><br><span class="line">BLAS       =</span><br><span class="line">LAPACK     =</span><br><span class="line">BLACS      = -lmkl_blacs_intelmpi_lp64</span><br><span class="line">SCALAPACK  = $(MKL_PATH)/libmkl_scalapack_lp64.a $(BLACS)</span><br></pre></td></tr></table></figure><p>这部分是用来定义一些数学库的，BLAS/LAPACK之所以为空，是应为在“FCL”命令中，加入了“-mkl”这个参数，它会自动的链接所需的MKL库。<br>特别要指出的是，在以前的vasp版本中，BLACS变量默认是“-lmkl_blacs_openmpi_lp64”，我们需要手动修改一下，改为“-lmkl_blacs_intelmpi_lp64”，现在就不用了。<br>因此vasp5.4以后，编译变得简单了许多。</p><h3 id="编译make"><a href="#编译make" class="headerlink" title="编译make"></a>编译make</h3><p>直接执行make即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>编译成功后会在bin文件夹下生成三个可执行文件vasp_std、vasp_ncl及vasp_gam。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>下面举例说明如何在天河超算平台下，通过slurm作业管理系统，提交vasp程序。</p><h3 id="准备输入文件"><a href="#准备输入文件" class="headerlink" title="准备输入文件"></a>准备输入文件</h3><p>准备一个输入文件，如用vasp的一个标准beachmark算例。</p><h3 id="编写提交脚本"><a href="#编写提交脚本" class="headerlink" title="编写提交脚本"></a>编写提交脚本</h3><p>编写一个名为sub.sh的脚本文件，里面写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line">yhrun -N 2 -n 24 -p debug /path/to/vasp</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>yhrun</td><td>slurm作业管理系统中，并行执行mpi程序的命令，类似mpirun</td></tr><tr><td>-N</td><td>任务所需的总节点数</td></tr><tr><td>-n</td><td>任务所需的总核数</td></tr><tr><td>-p</td><td>计算分区</td></tr><tr><td>/path/to/vasp_std</td><td>vasp_std可执行程序所在位置，请替换为实际的路径</td></tr></tbody></table><p>vasp_std命令会自动寻找当前目录下的INCAR文件作为输入文件进行计算。</p><h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><p>使用yhbatch命令提交作业：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yhbatch -N 2 -n 24-p debug sub.sh  </span><br></pre></td></tr></table></figure><h3 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h3><p>计算完成后会在默认的输出文件OUTCAR中生成结果文件，查看是否正确。</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>vasp的编译除了这些之外，还有几种其他的情况：</p><ul><li>编译neb版本的vasp</li><li>编译gpu版本的vasp</li><li>编译只优化固定轴的vasp</li><li>编译支持wannier90的vasp</li><li>编译5.3.5及以前版本的vasp（修改makefile比较复杂）</li></ul><p>这些内容如果有感兴趣的朋友可以给我留言。</p>]]></content>
      
      
      <categories>
          
          <category> 应用软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vasp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fftw 编译安装教程</title>
      <link href="//fftw-install/"/>
      <url>//fftw-install/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是DFT"><a href="#什么是DFT" class="headerlink" title="什么是DFT"></a>什么是DFT</h2><p>DFT（Discrete Fourier Transform），即离散傅里叶变换，是傅里叶变换在时域和频域上都呈离散的形式,将信号的时域采样变换为其DTFT的频域采样。</p><span id="more"></span><h2 id="什么是FFT"><a href="#什么是FFT" class="headerlink" title="什么是FFT"></a>什么是FFT</h2><p>FFT（Fast Fourier Transformation），即为快速傅氏变换，是离散傅氏变换（DFT）的快速算法，它是根据离散傅氏变换的奇、偶、虚、实等特性，对离散傅立叶变换的算法进行改进获得的。</p><h2 id="什么是FFTW"><a href="#什么是FFTW" class="headerlink" title="什么是FFTW"></a>什么是FFTW</h2><p>FFTW ( the Faster Fourier Transform in the West)是一个快速计算离散傅里叶变换的标准C语言程序集，其由MIT的M.Frigo和S. Johnson开发。可计算一维或多维实和复数据以及任意规模的DFT。</p><p>官网地址：<a href="http://www.fftw.org/">传送门</a>，下载地址：<a href="http://www.fftw.org/download.html">传送门</a>。</p><p>目前最新版本为<br>Version 3.3.6 is the latest stable release of FFTW ( 截止2017-04-30）</p><h2 id="FTW库所需的编译环境"><a href="#FTW库所需的编译环境" class="headerlink" title="FTW库所需的编译环境"></a>FTW库所需的编译环境</h2><p>Intel Compiler /GNU Compiler + MPI Compiler （如果编译mpi版的fftw）</p><h2 id="默认编译"><a href="#默认编译" class="headerlink" title="默认编译"></a>默认编译</h2><p>安装fftw仅需要遵循常见的三步骤即可（configure+make+make install），在这里先介绍一下默认安装，再然着重介绍一些configure的配置选项。</p><p>以fftw-3.3.6-pl2.tar.gz为例，先从官网下载该压缩包。解压缩，并进入源码目录进行编译即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf fftw-3.3.6-pl2.tar.gz  </span><br><span class="line"><span class="built_in">cd</span> fftw-3.3.6-pl2  </span><br><span class="line">./configure  </span><br><span class="line">make  </span><br><span class="line">make install  </span><br></pre></td></tr></table></figure><p>这样就可以把fftw库按照默认配置，安装到默认的路径下。<br>使用的是GNU的编译器，安装到的是/usr/local下面。</p><h2 id="优化编译参数介绍"><a href="#优化编译参数介绍" class="headerlink" title="优化编译参数介绍"></a>优化编译参数介绍</h2><p>但是，我们通常会依据./configure -help得到的信息来添加一些参数来达到优化编译的目录。<br>接下来我们使用命令查看一些常用配置参数：</p><p>设定安装目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Installation directories:</span><br><span class="line">--prefix=PREFIX    install architecture-independent files <span class="keyword">in</span> PREFIX[/usr/<span class="built_in">local</span>]</span><br></pre></td></tr></table></figure><p>是否编译动态库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional Features:</span><br><span class="line">--enable-shared[=PKGS]    build shared libraries [default=no]</span><br></pre></td></tr></table></figure><p>是否编译静态库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--enable-static[=PKGS]    build static libraries [default=yes]</span><br></pre></td></tr></table></figure><p>是否编译单精度版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--enable-single         compile fftw <span class="keyword">in</span> single precision</span><br><span class="line">--enable-float          synonym <span class="keyword">for</span> --enable-single</span><br></pre></td></tr></table></figure><p>开启针对特定机器架构的优化，这个取决于机器CPU（下面有介绍）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--enable-sse            <span class="built_in">enable</span> SSE optimizations</span><br><span class="line">--enable-sse2           <span class="built_in">enable</span> SSE/SSE2 optimizations</span><br><span class="line">--enable-avx            <span class="built_in">enable</span> AVX optimizations</span><br><span class="line">--enable-avx2           <span class="built_in">enable</span> AVX2 optimizations</span><br><span class="line">--enable-neon           <span class="built_in">enable</span> ARM NEON optimizations</span><br></pre></td></tr></table></figure><p>开启积和熔加运算(Fused Multiply-Add/FMA)的优化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--enable-fma            <span class="built_in">enable</span> optimizations <span class="keyword">for</span> machineswith fused multiply-add</span><br></pre></td></tr></table></figure><p>是否编译mpi版的fftw库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--enable-mpi            compile FFTW MPI library</span><br></pre></td></tr></table></figure><p>是否使用OpenMP指令进行并行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--enable-openmp         use OpenMP directives <span class="keyword">for</span> parallelism</span><br></pre></td></tr></table></figure><p>是否编译FFTW SMP线程库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--enable-threads        compile FFTW SMP threads library</span><br></pre></td></tr></table></figure><p>这部分是指定编译器及编译参数，默认是用GNU的编译器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Some influential environment variables:</span><br><span class="line">  CC          C compiler <span class="built_in">command</span></span><br><span class="line">  CFLAGS      C compiler flags</span><br><span class="line">  CPP         C preprocessor</span><br><span class="line">  MPICC       MPI C compiler <span class="built_in">command</span></span><br><span class="line">  F77         Fortran 77 compiler <span class="built_in">command</span></span><br><span class="line">  FFLAGS      Fortran 77 compiler flags</span><br></pre></td></tr></table></figure><p>为了用intel的编译器，我们需要特别指定一下：CC=icc F77=ifort，相关的参数通常保持默认即可。</p><p>备注：<br>1）如何查看CPU是否支持某个指令集呢？使用如下命令可以列出支持的指令集名称</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep flags | uniq</span><br></pre></td></tr></table></figure><p>2）SIMD<br>SIMD单指令流多数据流(SingleInstructionMultiple Data,SIMD)是一种采用一个控制器来控制多个处理器，同时对一组数据（又称“数据向量”）中的每一个分别执行相同的操作从而实现空间上的并行性的技术。</p><p>MMX是由英特尔开发的一种SIMD多媒体指令集，SSE（Streaming SIMDExtensions）是MMX的扩充指令集，AVX（Advanced VectorExtensions）是Intel的SSE延伸架构，FMA（Fused MultiplyAccumulate）是Intel的AVX扩充指令集。</p><p>NEON实际上是ARM的SIMD（Single InstructionMultiple Data）技术的延续，它是一个结合64和128 bit的SIMD（Single InstructionMultiple Data 单指令多重数据）指令集。</p><h2 id="优化编译单精度版本"><a href="#优化编译单精度版本" class="headerlink" title="优化编译单精度版本"></a>优化编译单精度版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=<span class="variable">$HOME</span>/software/fftw/3.3.6-pl2-icc13 \  </span><br><span class="line">  CC=icc F77=ifort \  </span><br><span class="line">  --enable-shared --enable-static \  </span><br><span class="line">  --enable-float \  </span><br><span class="line">  --enable-sse --enable-sse2 \  </span><br><span class="line">  --enable-avx --enable-avx2 --enable-fma \  </span><br><span class="line">  --enable-mpi \  </span><br><span class="line">  --enable-threads--enable-openmp  </span><br><span class="line">make  </span><br><span class="line">make install  </span><br></pre></td></tr></table></figure><h2 id="优化编译双精度版本"><a href="#优化编译双精度版本" class="headerlink" title="优化编译双精度版本"></a>优化编译双精度版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=<span class="variable">$HOME</span>/software/fftw/3.3.6-pl2-icc13 \  </span><br><span class="line">  CC=icc F77=ifort \  </span><br><span class="line">  --enable-shared --enable-static \  </span><br><span class="line">  --enable-sse2 --enable-avx --enable-avx2 --enable-fma \  </span><br><span class="line">  --enable-mpi \  </span><br><span class="line">  --enable-threads--enable-openmp  </span><br><span class="line">make  </span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="编译一些需要fftw的软件"><a href="#编译一些需要fftw的软件" class="headerlink" title="编译一些需要fftw的软件"></a>编译一些需要fftw的软件</h2><p>通常会用到的是libfftw.a以及一些头文件，在编译或链接的时候，给出它的路径即可。</p><p>比如：<br>gromacs软件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-DFFTWF_LIBRARY=<span class="string">&quot;<span class="variable">$HOME</span>/software/fftw/3.3.6-pl2-icc13&quot;</span> </span><br><span class="line">-DFFTWF_INCLUDE_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/fftw/include/&quot;</span>  </span><br></pre></td></tr></table></figure><p>这里介绍的是官网题的fftw库，我们还可以使用Intel MKL库中的fftw接口。</p>]]></content>
      
      
      <categories>
          
          <category> 数学库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fftw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>slurm作业管理系统怎么用？</title>
      <link href="//how-to-use-slurm/"/>
      <url>//how-to-use-slurm/</url>
      
        <content type="html"><![CDATA[<p>对于大型集群环境，通常需要有作业管理系统来调度分配系统资源，本文介绍一款开源免费的容错和高度可扩展的集群管理和作业调度系统：SLURM。在我国首次获得世界TOP500计算机排名第一的天河一号计算机上使用的集群管理和作业调度系统，就是基于SLURM二次开发的，可见其强大。</p><span id="more"></span><p>它的官网是：<a href="https://slurm.schedmd.com/" title="slurm作业管理系统官网">传送门</a>。</p><h2 id="准备可执行程序和输入文件"><a href="#准备可执行程序和输入文件" class="headerlink" title="准备可执行程序和输入文件"></a>准备可执行程序和输入文件</h2><p>我们想提交一个计算任务，首先要准备好可执行程序和输入文件。</p><ul><li>可执行程序需要系统管理员进行编译安装，并配置好环境。</li><li>输入文件需要每一位用户针对自己的计算问题进行配置，并上传到自己的账户目录下。</li></ul><p>然后我们要看看自己登录的账户可用的资源情况，这样子才能有针对性的提交到合适的计算分区，申请相应的系统资源进行作业的计算。</p><p>这里我们假设：可执行程序的名字叫做 <strong>program.exe</strong>，输入文件的名字叫做 <strong>inputfile</strong>。</p><h2 id="查看可用计算节点信息"><a href="#查看可用计算节点信息" class="headerlink" title="查看可用计算节点信息"></a>查看可用计算节点信息</h2><p>查看可用计算节点信息的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinfo</span><br></pre></td></tr></table></figure><p>天河系统的相应命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yhi</span><br></pre></td></tr></table></figure><p>显示如下（举例）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PARTITION AVAIL  TIMELIMIT  NODES  STATE  NODELIST</span><br><span class="line">debug        up      30:00     10  drain  cn[1-2]</span><br><span class="line">debug        up      30:00     10  alloc  cn[3-4]</span><br><span class="line">debug        up      30:00     10   idle  cn[5-6]</span><br></pre></td></tr></table></figure><p>说明：</p><table><thead><tr><th>关键词</th><th>含义</th></tr></thead><tbody><tr><td>PARTITION</td><td>分区名，大型集群为了方便管理，会将节点划分为不同的分区设置不同权限</td></tr><tr><td>AVAIL</td><td>可用状态：up 可用；down 不可用</td></tr><tr><td>TIMELIMIT</td><td>该分区的作业最大运行时长限制, 30:00 表示30分钟，如果是2-00:00:00表示2天，如果是infinite表示不限时间</td></tr><tr><td>NODES</td><td>节点的数量</td></tr><tr><td>STATE</td><td>节点的状态：drain: 排空状态，表示该类结点不再分配到其他；idle: 空闲状态；alloc: 被分配状态</td></tr></tbody></table><p>通过查看系统可用资源情况，我们就知道了要将计算任务提交到那里了，比如例子中的debug计算分区。</p><h2 id="提交作业进行计算"><a href="#提交作业进行计算" class="headerlink" title="提交作业进行计算"></a>提交作业进行计算</h2><p>接下来应该就是使用slurm作业管理系统进行作业提交了，常用的提交方式有2种，分别介绍如下：</p><h3 id="方式1：使用srun直接执行可执行程序"><a href="#方式1：使用srun直接执行可执行程序" class="headerlink" title="方式1：使用srun直接执行可执行程序"></a>方式1：使用srun直接执行可执行程序</h3><p>在命令行终端直接执行srun命令进行作业提交计算：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srun -N 2 -n 24 -p debug program.exe &lt; inputfile</span><br></pre></td></tr></table></figure><p>天河系统的相应命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yhrun -N 2 -n 24 -p debug program.exe &lt; inputfile</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><table><thead><tr><th>关键词</th><th>含义</th></tr></thead><tbody><tr><td>srun</td><td>srun是slurm作业管理系统并行执行mpi程序的命令，类似mpirun</td></tr><tr><td>-N</td><td>任务所需的总节点数</td></tr><tr><td>-n</td><td>任务所需的总核数</td></tr><tr><td>-p</td><td>任务申请的计算分区名称，刚刚用sinfo查询过，记得吗？</td></tr><tr><td>program.exe</td><td>可执行程序名称</td></tr><tr><td>inputfile</td><td>输入文件的名称，”&lt;”简单讲，就是把inputfile文件给program.exe</td></tr></tbody></table><p>备注：</p><ol><li>有的程序不需要特别指定输入文件的名称，会自动寻找，那么就不需要写 <code>&lt; inputfile</code> 了。</li><li>关于结果输出：<ol><li>如果程序有内置的输出文件名，那么就会写到默认的输出文件中；</li><li>如果没有的话，使用 <code>srun</code> 提交的任务的输出会显示在当前屏幕中；</li><li>如果想将输出结果定向到别的文件，可以使用例如 <code>&gt; outputfile</code> 的写法，将输出结果写到 <code>outputfile</code> 文件中。 </li></ol></li><li>不过要注意的是，在有登录节点和计算节点的大型集群中，使用 <code>srun</code> 命令提交任务，会由于用户的当前终端关闭而导致任务断掉，因此建议用户使用下面的方式提交组偶也。 </li></ol><h3 id="方式2：使用sbatch提交批处理脚本进行任务计算"><a href="#方式2：使用sbatch提交批处理脚本进行任务计算" class="headerlink" title="方式2：使用sbatch提交批处理脚本进行任务计算"></a>方式2：使用sbatch提交批处理脚本进行任务计算</h3><p>这种方式是最为推荐的方式，先编写一个脚本（别担心，很简单），然后用提交命令提交这个脚本即可。</p><p><strong>编写脚本</strong></p><p>使用文本编辑器（例如vim等），创建一个用于提交作业的脚本文件，例如名为<strong>sub.sh</strong>的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim sub.sh</span><br></pre></td></tr></table></figure><p>然后写入脚本内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">srun -N 2 -n 24 -p debug program.exe &lt; inputfile</span><br></pre></td></tr></table></figure><p>天河系统的相应命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yhrun -N 2 -n 24 -p debug program.exe &lt; inputfile</span><br></pre></td></tr></table></figure><p>第一行表示这个文件是一个bash的脚本文件。<br>第二行表示我要用srun命令，申请2个节点，一共24个cpu核，在debug分区，使用program.exe程序计算inputfile输入文件所设定的具体计算任务。</p><p>这个和方式1种的命令，完全相同。</p><p><strong>提交脚本</strong></p><p>我们用命令将刚刚写的脚本提交一下，放到后台，这样子就不担心因为当前终端关闭而导致任务断掉的问题了，命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbatch -N 2 -n 24 -p debug sub.sh  </span><br></pre></td></tr></table></figure><p>天河系统的相应命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yhbatch -N 2 -n 24 -p debug sub.sh</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><table><thead><tr><th>关键词</th><th>含义</th></tr></thead><tbody><tr><td>sbatch</td><td>sbatch是slurm作业管理系统提交批处理脚本的命令</td></tr><tr><td>-N</td><td>任务所需的总节点数</td></tr><tr><td>-n</td><td>任务所需的总核数</td></tr><tr><td>-p</td><td>任务申请的计算分区名称</td></tr><tr><td>sub.sh</td><td>脚本的名字，我们起的名字是sub.sh</td></tr></tbody></table><p>使用这种方式提交的任务，会自动生成一个名为slurm-jobid.out的文件，其中”jobid”是slurm分配给这个任务的具体编号数字。里面会有除了程序特殊指定，或用户重定向以外的所有作业的标准输出和错误信息。当计算任务出现错误的时候，我们也是第一时间查看该文件，寻找原因。</p><h2 id="查看作业状态"><a href="#查看作业状态" class="headerlink" title="查看作业状态"></a>查看作业状态</h2><p>如果我们想查看一下当前用户的作业状态，可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squeue</span><br></pre></td></tr></table></figure><p>天河系统的相应命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yhqueue</span><br><span class="line">或</span><br><span class="line">yhq</span><br></pre></td></tr></table></figure><p>显示如下（举例）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JOBID   PARTITION  NAME     USER       ST  TIME      NODES NODELIST(REASON)</span><br><span class="line">100001  debug      sub.sh   zhenggang  R   00:05:00  1     cn6</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><table><thead><tr><th>关键词</th><th>含义</th></tr></thead><tbody><tr><td>JOBID</td><td>job的id号，每个成功提交的任务都会有唯一的id</td></tr><tr><td>PARTITION</td><td>计算分区名</td></tr><tr><td>NAME</td><td>任务名，默认以提交脚本的名称当作任务名</td></tr><tr><td>USER</td><td>用户名，提交该任务的用户名</td></tr><tr><td>ST</td><td>任务状态：PD排队；R运行；S挂起；CG正在退出</td></tr><tr><td>TIME</td><td>任务运行时间，例子中为5分钟</td></tr><tr><td>NODES</td><td>任务作占节点数，例子中为1个</td></tr><tr><td>NODELIST(REASON)</td><td>任务所占节点列表，如果是排队状态的任务，则会给出排队原因</td></tr></tbody></table><p>备注：常见排队原因：</p><ul><li>AssociationResourceLimit：关联的资源限制已满 — 账户有使用节点数限制，已经用满了。</li><li>Resources：当前可用资源不能满足作业需求 — 系统的可用节点资源不足</li><li>Dependency：作业的依赖关系未满足 — 作业之间有依赖关系，依赖的作业没完成</li><li>PartitionDown：作业所在的分区处于 down 状态 — 分区down，所以节点不可用。</li></ul><h2 id="取消作业"><a href="#取消作业" class="headerlink" title="取消作业"></a>取消作业</h2><p>如果提交作业后，发现有些输入文件参数设置错了，或者其他原因想停止这个作业，可以先使用squeue（或yhq)找到该作业的id号，如100001，然后使用如下命令杀掉任务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scancel 100001</span><br></pre></td></tr></table></figure><p>天河系统的相应命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yhcancel 100001</span><br></pre></td></tr></table></figure><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>关于slurm作业管理系统，还有非常丰富的内容，本文仅给出了最最常用的几个命令。如果想深入了解，可以关于以后的文章。</p><p>比如：</p><ul><li>如何给任务起名字，让每个任务不一样</li><li>如何限制任务的运行时间</li><li>如何申请特定节点，排除特定的节点</li><li>如何查看作业运行的详细信息，比如提交目录、运行耗时</li><li>如何设置作业之间的依赖关系，让某个作业在另一个之后才运行</li></ul><p>不过这些通常用户用到的不多，如果想知道的话，留言哦。</p>]]></content>
      
      
      <categories>
          
          <category> 作业调度 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> slurm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python扩展包的安装方法</title>
      <link href="//python-package-install/"/>
      <url>//python-package-install/</url>
      
        <content type="html"><![CDATA[<p>python拥有非常丰富的扩展包，下面介绍常见的扩展包安装方法。</p><h2 id="使用Anaconda集成环境"><a href="#使用Anaconda集成环境" class="headerlink" title="使用Anaconda集成环境"></a>使用Anaconda集成环境</h2><p>通过使用该python的集成环境，可以解决大部分常见包的安装以相互依赖问题。</p><h2 id="使用zip-tar等格式源码包安装"><a href="#使用zip-tar等格式源码包安装" class="headerlink" title="使用zip/tar等格式源码包安装"></a>使用zip/tar等格式源码包安装</h2><p>例如我们想安装numpy，可以：</p><h3 id="下载源码包"><a href="#下载源码包" class="headerlink" title="下载源码包"></a>下载源码包</h3><p>通过<a href="https://pypi.python.org/">pip网站</a>下载<a href="https://pypi.python.org/packages/c0/3a/40967d9f5675fbb097ffec170f59c2ba19fc96373e73ad47c2cae9a30aed/numpy-1.13.1.zip#md5=2c3c0f4edf720c3a7b525dacc825b9ae">numpy-1.13.1.zip</a></p><p>该源码包是zip格式的，我们可以用unzip命令解压缩。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unzip numpy-1.13.1.zip</span><br><span class="line"><span class="built_in">cd</span> numpu-1.13.1</span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>如果是安装在当前系统环境python的默认路径下，那么直接执行下面的命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install </span><br></pre></td></tr></table></figure><p>如果是希望修改安装路径，可以加上<code>--prefix参数</code>，即：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install --prefix=/path/to/install  <span class="comment"># 等号后面写安装路径</span></span><br></pre></td></tr></table></figure><h2 id="使用egg格式文件安装"><a href="#使用egg格式文件安装" class="headerlink" title="使用egg格式文件安装"></a>使用egg格式文件安装</h2><p>安装方法也很简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">easy_install 123.egg <span class="comment"># 123.egg 是egg包的名字</span></span><br></pre></td></tr></table></figure><p>使用这类包的时候，请注意：</p><ul><li>下载的版本与系统的python版本相对应，如py2表示python2版本，py3.6表示python3.6版本</li><li>下载的版本与系统的版本相对应，一般的i686对应32位系统，x86_64对应64位系统</li></ul><p>设置安装路径也是添加 <code>--prefix=/path/to/install</code> 即可。</p><h2 id="使用whl格式文件安装"><a href="#使用whl格式文件安装" class="headerlink" title="使用whl格式文件安装"></a>使用whl格式文件安装</h2><p>安装方法也很简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 123.whl <span class="comment"># 123.whl 是whl包的名字</span></span><br></pre></td></tr></table></figure><p>我们可以通过添加 <code>--target=/path/to/install</code> 来指定安装路径</p><h2 id="使用conda命令安装"><a href="#使用conda命令安装" class="headerlink" title="使用conda命令安装"></a>使用conda命令安装</h2><p>集成环境中其实配置了python包的管理工具，我们可以使用它来管理包。不过有时候，从国外下载包会比较慢。</p><p>比如，我想安装numpy-1.13.1，只需要输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install numpy=1.13.1</span><br></pre></td></tr></table></figure><p>如果是更新的话，只需要输入例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update numpy=1.13.11</span><br></pre></td></tr></table></figure><p>可以查看官网的<a href="https://conda.io/docs/user-guide/overview.html">conda介绍</a>。</p><h2 id="设置默认安装路径"><a href="#设置默认安装路径" class="headerlink" title="设置默认安装路径"></a>设置默认安装路径</h2><p>一般情况下，我们使用setup.py 或者 pip等方式安装一个python的扩展包时，都是安装到当前环境中的python的默认对应路径。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> python</span><br><span class="line"><span class="variable">$HOME</span>/software/python/bin/python</span><br></pre></td></tr></table></figure><p>默认包的安装路径很可能为（对于2.7版本）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME/software/python/lib/python2.7/site-packages</span><br></pre></td></tr></table></figure><p>如何修改默认的安装路径，让我们不需要指定例如 <code>--prefix</code> 参数就可以实现呢？</p><p>我们可以在$HOME目录下创建一个配置文件 “.pydistutils.cfg” ，用来特别指定python的packages的默认安装目录，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> [install]</span><br><span class="line">install_lib = <span class="variable">$HOME</span>/software/lib/python</span><br><span class="line">install_scripts = <span class="variable">$HOME</span>/software/python/bin</span><br></pre></td></tr></table></figure><p>通过配置此文件，即可修改默认安装目录。</p><p>如果在安装python的packages过程中并未指定安装路径，但在默认的安装路径中并未发现安装的文件，可以找找此文件看一下。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UV-CDAT 安装教程</title>
      <link href="//uv-cdat-install/"/>
      <url>//uv-cdat-install/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Ultrascale Visualization Climate Data Analysis Tools<br>官网介绍：<a href="http://uvcdat.llnl.gov/index.html">传送门</a>。<br>安装说明参考：<a href="https://github.com/UV-CDAT/uvcdat/wiki/Install-on-RedHat-or-CentOS">传送门</a>。</p><span id="more"></span><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ul><li><a href="http://heanet.dl.sourceforge.net/project/cdat/Releases/UV-CDAT/2.0.0/qt-CentOS-6.5-RedHat6-64bit-4.8.4.tar.bz2">qt-CentOS-6.5-RedHat6-64bit-4.8.4</a></li><li><a href="http://ncu.dl.sourceforge.net/project/cdat/Releases/UV-CDAT/2.2.0/UV-CDAT-2.2.0-CentOS-6.5-RedHat6-64bit.tar.gz">UV-CDAT-2.2.0-CentOS-6.5-RedHat6-64bit</a></li></ul><h2 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h2><p>下载得到2个压缩包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qt-CentOS-6.5-RedHat6-64bit-4.8.4.tar.bz2</span><br><span class="line">UV-CDAT-2.2.0-CentOS-6.5-RedHat6-64bit.tar.gz</span><br></pre></td></tr></table></figure><p>解压缩，并复制到指定目录。例如$HOME/software/uvcdat目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/software/uvcdat</span><br><span class="line">tar xvf qt-CentOS-6.5-RedHat6-64bit-4.8.4.tar.bz2 -C ~/software/uvcdat</span><br><span class="line">mv ~/software/uvcdat/usr/<span class="built_in">local</span>/Qt  ~/software/uvcdat</span><br><span class="line"></span><br><span class="line">tar xvf UV-CDAT-2.2.0-CentOS-6.5-RedHat6-64bit.tar.gz -C ~/software/uvcdat</span><br><span class="line">mv ~/software/uvcdat/usr/<span class="built_in">local</span>/uvcdat  ~/software/uvcdat</span><br><span class="line">rm -rf ~/software/uvcdat/usr</span><br></pre></td></tr></table></figure><p>备注：为了放置到自己的目录下，而不是/usr/local</p><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p>打开bashrc文件，进行环境变量配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>添加如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># QT</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$HOME</span>/software/uvcdat/Qt/4.8.4/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$HOME</span>/software/uvcdat/Qt/4.8.4/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="comment"># UVCDAT</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$HOME</span>/software/uvcdat/uvcdat/2.2.0/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$HOME</span>/software/uvcdat/uvcdat/2.2.0/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><p>重新加载bashrc文件以便环境变量生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>备注：注意软件版本，上述为qt为4.8.4，UV-CDAT为2.2.0版本。</p><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>修改文件 ~/software/uvcdat/uvcdat/2.2.0/bin/setup_runtime.sh</p><p>将：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install_prefix=<span class="string">&quot;/usr/local/uvcdat/2.2.0&quot;</span></span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install_prefix=<span class="string">&quot;<span class="variable">$HOME</span>/software/uvcdat/uvcdat/2.2.0&quot;</span></span><br></pre></td></tr></table></figure><p>修改文件 ~/software/uvcdat/uvcdat/2.2.0/bin/uvcdat</p><p>将：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">. <span class="string">&quot;/usr/local/uvcdat/2.2.0/bin/setup_runtime.sh&quot;</span></span><br><span class="line"></span><br><span class="line">python2.7 <span class="string">&quot;/usr/local/uvcdat/2.2.0/vistrails/vistrails/uvcdat.py&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">. <span class="string">&quot;<span class="variable">$HOME</span>/software/uvcdat/uvcdat/2.2.0/bin/setup_runtime.sh&quot;</span></span><br><span class="line">python2.7 <span class="string">&quot;<span class="variable">$HOME</span>/software/uvcdat/uvcdat/2.2.0/vistrails/vistrails/uvcdat.py&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>在终端运行命令即可启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uvcdat</span><br></pre></td></tr></table></figure><blockquote><p>请使用支持图形界面的ssh工具，例如xmanage。另外，远程使用图形界面需要保证一定的带宽以确保流畅度。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 应用软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uv-cdat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LAMMPS编译安装教程</title>
      <link href="//lammps-install/"/>
      <url>//lammps-install/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LAMMPS即Large-scale Atomic/MolecularMassivelyParallel Simulator，可以翻译为大规模原子分子并行模拟器，主要用于分子动力学相关的一些计算和模拟工作。</p><span id="more"></span><p>链接：<a href="http://lammps.sandia.gov/">官网地址</a>，<a href="http://lammps.sandia.gov/download.html">下载最新稳定版</a>，<a href="http://lammps.sandia.gov/tars/">下载指定版本</a></p><h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><p>需要的编译环境为：</p><ul><li>c/c++的编译器，如gcc/icc等</li><li>mpi编译器，如mpich等</li><li>fftw数学库</li></ul><p>下面以intel 2013 compiler 编译器 和 mpich3.0.4 版本为例，介绍 lammps 的安装。</p><p>我们需要先设置一下环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置编译c/c++的环境</span></span><br><span class="line"><span class="built_in">source</span> /opt/intel/composer_xe_2013.0.079/bin/iccvars.sh intel64 </span><br><span class="line"><span class="comment"># 设置mpi编译环境  </span></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/mpi-intel2013/bin:<span class="variable">$PATH</span> </span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/mpi-intel2013/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><p>不同机器的编译器版本、安装目录不同，请依据自己的情况修改，不要直接copy。</p><h2 id="安装lammps的说明"><a href="#安装lammps的说明" class="headerlink" title="安装lammps的说明"></a>安装lammps的说明</h2><p>lammps包含了非常丰富的packages，截止到现在大约有60多个，默认开启的是：</p><ul><li>KSPACE</li><li>MANYBODY</li><li>MOLECULE</li></ul><p>其他的包，我大致分为3类：</p><ul><li>直接通过 make yes 就能安装的包，如ASPHERE、BODY、CLASS2等。</li><li>需要在lammps/lib文件夹下手动编译的包，如atc、quip、reaxc等。</li><li>需要在lammps/lib文件夹下，额外下载源码安装，然后再链接的包，如kim、voronoi、user-quip等。</li></ul><p>另外特别指出，还有一些功能可以支持，部分列举如下：</p><ul><li>lammps支持GPU，可以编译出GPU版本</li><li>安装jpeg/png的库，并通过修改lammps的makefile来支持</li><li>修改lammps的makefile的宏定义来支持ffmpeg</li><li>修改lammps的makefile的宏定义来编译出不同精度的lammps</li></ul><p>此次编译仅安装默认的包，其他的内容以后会介绍。</p><h2 id="编译lammps"><a href="#编译lammps" class="headerlink" title="编译lammps"></a>编译lammps</h2><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><p>如果我们下载到的压缩包为lammps-30Jul16.tar.gz，将其放置在某个目录下，例如用户根目录$HOME,先进行解压缩：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar lammps-30Jul16.tar.gz</span><br><span class="line"><span class="built_in">cd</span> lammps-30Jul16</span><br><span class="line"><span class="built_in">cd</span> src</span><br></pre></td></tr></table></figure><h3 id="修改Makefile"><a href="#修改Makefile" class="headerlink" title="修改Makefile"></a>修改Makefile</h3><p>我们使用文本编辑器（例如vim），打开lammps的makefile文件，修改其中的参数为我们需要的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim MAKE/Makefile.mpi</span><br></pre></td></tr></table></figure><p>需要修改的参数包括如下部分：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># intel的FFTW  </span></span><br><span class="line">MKLROOT = /opt/intel/composer_xe_2013.0.079/mkl  </span><br><span class="line">FFT_INC =    -DFFT_FFTW3  -I$(MKLROOT)/include/fftw  </span><br><span class="line">FFT_PATH =  </span><br><span class="line">FFT_LIB =  $(MKLROOT)/interfaces/fftw3xf/libfftw3xf_intel.a  </span><br></pre></td></tr></table></figure><p>备注：MKLROOT为系统中Intel Compiler的mkl库的根目录，请依据自己的情况进行修改为实际路径。默认情况下安装的Intel Compiler的MKL库并未编译fftw的静态库，故需要手动编译。以后关于intel FFTW库的文章会介绍道的。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make mpi <span class="comment"># 如果是多核的机器可以并行编译，如make -j 4 mpi 表示用4个cpu核一起编译</span></span><br></pre></td></tr></table></figure><p>如果编译成功，会会生成一个名为 lmp_mpi 的可执行文件。</p><h2 id="测试lammps"><a href="#测试lammps" class="headerlink" title="测试lammps"></a>测试lammps</h2><p>下面举例说明如何在天河超算平台下，通过slurm作业管理系统，提交lammps程序。</p><h3 id="准备输入文件"><a href="#准备输入文件" class="headerlink" title="准备输入文件"></a>准备输入文件</h3><p>准备一个输入文件，如用lammps自带的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> lammps/bench</span><br></pre></td></tr></table></figure><p>里面有一个名为in.lj的文件。</p><h3 id="编写提交脚本"><a href="#编写提交脚本" class="headerlink" title="编写提交脚本"></a>编写提交脚本</h3><p>编写一个名为sub.sh的脚本文件，里面写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line">yhrun -N 2 -n 24 -p debug /path/to/lmp_th &lt; in.lj  </span><br></pre></td></tr></table></figure><p>参数说明如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>yhrun</td><td>slurm作业管理系统中，并行执行mpi程序的命令，类似mpirun</td></tr><tr><td>-N</td><td>任务所需的总节点数</td></tr><tr><td>-n</td><td>任务所需的总核数</td></tr><tr><td>-p</td><td>计算分区</td></tr><tr><td>/path/to/lmp_mpi</td><td>lmp_mpi可执行程序所在位置，请替换为实际的路径</td></tr><tr><td>&lt; in.lj</td><td>表示以in.lj作为输入文件</td></tr></tbody></table><h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><p>使用yhbatch命令提交作业：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yhbatch -N 2 -n 24-p debug sub.sh  </span><br></pre></td></tr></table></figure><h3 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h3><p>计算完成后会在默认的输出文件log.lammps中生成结果文件，查看是否正确。</p>]]></content>
      
      
      <categories>
          
          <category> 应用软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lammps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda 安装教程</title>
      <link href="//anaconda-install/"/>
      <url>//anaconda-install/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Anaconda是一个用于科学计算的Python发行版，支持 Linux, Mac, Windows系统，提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。</p><span id="more"></span><p><a href="https://www.continuum.io/what-is-anaconda">官网简介</a></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://www.anaconda.com/distribution/">官方下载地址</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><p>将Anaconda2-4.4.0-Linux-x86_64.sh上传到系统某文件夹，例如$HOME文件夹。</p><h3 id="增加可执行权限"><a href="#增加可执行权限" class="headerlink" title="增加可执行权限"></a>增加可执行权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x Anaconda2-4.4.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><h3 id="执行安装"><a href="#执行安装" class="headerlink" title="执行安装"></a>执行安装</h3><p>执行如下命令开始安装<br><strong>./Anaconda2-4.4.0-Linux-x86_64.sh</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Anaconda2 4.4.0 (by Continuum Analytics, Inc.)</span><br><span class="line"></span><br><span class="line">In order to <span class="built_in">continue</span> the installation process, please review the license</span><br><span class="line">agreement.</span><br><span class="line">Please, press ENTER to <span class="built_in">continue</span></span><br><span class="line">&gt;&gt;&gt;  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入回车</span></span><br><span class="line"></span><br><span class="line">===================================</span><br><span class="line">Anaconda End User License Agreement</span><br><span class="line">===================================</span><br><span class="line"></span><br><span class="line">Copyright 2017, Continuum Analytics, Inc.</span><br><span class="line"></span><br><span class="line">All rights reserved under the 3-clause BSD License:</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span><br><span class="line">--More--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按多次空格进行翻页</span></span><br><span class="line"></span><br><span class="line">kerberos (krb5, non-Windows platforms)</span><br><span class="line">A network authentication protocol designed to provide strong authentication</span><br><span class="line"><span class="keyword">for</span> client/server applications by using secret-key cryptography.</span><br><span class="line"></span><br><span class="line">cryptography</span><br><span class="line">A Python library <span class="built_in">which</span> exposes cryptographic recipes and primitives.</span><br><span class="line"></span><br><span class="line">Do you approve the license terms? [yes|no]</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入yes，同意license</span></span><br><span class="line"></span><br><span class="line">Anaconda2 will now be installed into this location:</span><br><span class="line"><span class="variable">$HOME</span>/anaconda2</span><br><span class="line"></span><br><span class="line">  - Press ENTER to confirm the location</span><br><span class="line">  - Press CTRL-C to abort the installation</span><br><span class="line">  - Or specify a different location below</span><br><span class="line"></span><br><span class="line">[/home/zhenggang/anaconda2] &gt;&gt;&gt;  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入安装路径，回车；如直接回车，则按默认路径安装</span></span><br><span class="line"></span><br><span class="line">PREFIX=<span class="variable">$HOME</span>/anaconda2</span><br><span class="line">installing: python-2.7.13-0 ...</span><br><span class="line">installing: _license-1.1-py27_1 ...</span><br><span class="line">installing: alabaster-0.7.10-py27_0 ...</span><br><span class="line">installing: anaconda-client-1.6.3-py27_0 ...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">installing: anaconda-4.4.0-np112py27_0 ...</span><br><span class="line">installing: conda-4.3.21-py27_0 ...</span><br><span class="line">installing: conda-env-2.6.0-0 ...</span><br><span class="line">Python 2.7.13 :: Continuum Analytics, Inc.</span><br><span class="line">creating default environment...</span><br><span class="line">installation finished.</span><br><span class="line">Do you wish the installer to prepend the Anaconda2 install location</span><br><span class="line">to PATH <span class="keyword">in</span> your <span class="variable">$HOME</span>/.bashrc ? [yes|no]</span><br><span class="line">[no] &gt;&gt;&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入yes，则将anaconda的path添加到~/.bashrc文件；</span></span><br><span class="line"><span class="comment"># 输入no，或者直接回车就不会了。</span></span><br><span class="line"></span><br><span class="line">Prepending PATH=<span class="variable">$HOME</span>/anaconda2/bin to PATH <span class="keyword">in</span> /vol-th/home/zhenggang/.bashrc</span><br><span class="line">A backup will be made to: <span class="variable">$HOME</span>/.bashrc-anaconda2.bak</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">For this change to become active, you have to open a new terminal.</span><br><span class="line"></span><br><span class="line">Thank you <span class="keyword">for</span> installing Anaconda2!</span><br><span class="line"></span><br><span class="line">Share your notebooks and packages on Anaconda Cloud!</span><br><span class="line">Sign up <span class="keyword">for</span> free: https://anaconda.org</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="配置使用"><a href="#配置使用" class="headerlink" title="配置使用"></a>配置使用</h2><p>如果anaconda的PATH没有添加到~/.bashrc文件中，那么每次使用之前，请在当前终端执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$HOME</span>/anaconda2/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>如果已经添加到~/.bashrc中，则每次启动终端后会自动调用该anaconda环境。</p><h2 id="执行python"><a href="#执行python" class="headerlink" title="执行python"></a>执行python</h2><p>在当前终端执行“python”命令，得到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Python 2.7.13 |Anaconda 4.4.0 (64-bit)| (default, Dec 20 2016, 23:09:15) </span><br><span class="line">[GCC 4.4.7 20120313 (Red Hat 4.4.7-1)] on linux2</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">Anaconda is brought to you by Continuum Analytics.</span><br><span class="line">Please check out: http://continuum.io/thanks and https://anaconda.org</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>如果我们同时安装的了anaconda2和anaconda3，那么可以在~/.bashrc中添加如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> py2=<span class="string">&#x27;export PATH=$HOME/anaconda2/bin:$PATH&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> py3=<span class="string">&#x27;export PATH=$HOME/anaconda2/bin:$PATH&#x27;</span></span><br></pre></td></tr></table></figure><p>当想使用python2的时候，就输入py2；同理，输入py3。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gromacs编译安装教程</title>
      <link href="//gromacs-install/"/>
      <url>//gromacs-install/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="https://cdn.jsdelivr.net/gh/mrzhenggang/CDN@master/img/gromacs/gromacs-logo.png"></p><p>GROMACS 是用于研究生物分子体系的分子动力学程序包。它可以用分子动力学、随机动力学或者路径积分方法模拟溶液或晶体中的任意分子，进行分子能量的最小化，分析构象等。它的模拟程序包包含 GROMACS 力场(蛋白质、核苷酸、糖等)，研究的范围可以包括玻璃和液晶、到聚合物、晶体和生物分子溶液。 GROMACS 是一个功能强大的分子动力学的模拟软件，其在模拟大量分子系统的牛顿运动方面具有极大的优势。</p><p>链接：<a href="http://www.gromacs.org/">官网地址</a>，<a href="http://www.gromacs.org/Downloads">下载指定版本</a></p><span id="more"></span><h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><p>需要的编译环境为：</p><ul><li>串行编译器：Intel Compiler / GNU Compiler</li><li>MPI编译器：mpich / openmpi（如果是MPI版本）</li><li>cmake</li><li>fftw</li><li>CUDA（如果是GPU版本）</li><li>plumed（如果开启plumed）</li></ul><h2 id="编译单精度CPU版本"><a href="#编译单精度CPU版本" class="headerlink" title="编译单精度CPU版本"></a>编译单精度CPU版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf gromacs-5.1.4.tar.gz <span class="comment"># 以5.1.4版本为例</span></span><br><span class="line"><span class="built_in">cd</span> gromacs-5.1.4 </span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/software/gromacs-5.1.4 \</span><br><span class="line">  -DCMAKE_C_COMPILER=icc -DCMAKE_CXX_COMPILER=icpc \</span><br><span class="line">  -DGMX_DOUBLE=off \</span><br><span class="line">  -DGMX_FFT_LIBRARY=fftw3 \</span><br><span class="line">  -DFFTWF_LIBRARY=<span class="string">&quot;<span class="variable">$HOME</span>/fftw/lib/libfftw3f.a&quot;</span> \</span><br><span class="line">  -DFFTWF_INCLUDE_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/fftw/include/&quot;</span>  \</span><br><span class="line">  -DGMX_MPI=on \</span><br><span class="line">  -DGMX_GPU=off \</span><br><span class="line">  2&gt;&amp;1 | tee cm.log</span><br><span class="line">make -j12 2&gt;&amp;1 | tee m.log</span><br><span class="line">make install 2&gt;&amp;1 | tee mi.log</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-DCMAKE_INSTALL_PREFIX</td><td>安装目录</td></tr><tr><td>-DCMAKE_C_COMPILER=icc</td><td>使用 icc 编译 c</td></tr><tr><td>-DCMAKE_CXX_COMPILER=icpc</td><td>使用 icpc 编译 cpp</td></tr><tr><td>-DGMX_DOUBLE=off</td><td>关闭double，编译单精度版本</td></tr><tr><td>-DGMX_FFT_LIBRARY=fftw3</td><td>使用 fftw3</td></tr><tr><td>-DFFTWF_LIBRARY=”$HOME/fftw/lib/libfftw3f.a”</td><td>fftw库,请改为自己的安装目录</td></tr><tr><td>-DFFTWF_INCLUDE_DIR=”$HOME/fftw/include”</td><td>fftw的头文件目录,请改为自己的安装目录</td></tr><tr><td>-DGMX_MPI=on</td><td>开启 MPI 支持</td></tr><tr><td>-DGMX_GPU=off</td><td>关闭 GPU 支持</td></tr></tbody></table><h2 id="编译双精度CPU版本"><a href="#编译双精度CPU版本" class="headerlink" title="编译双精度CPU版本"></a>编译双精度CPU版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf gromacs-5.1.4.tar.gz</span><br><span class="line"><span class="built_in">cd</span> gromacs-5.1.4 </span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/software/gromacs-5.1.4 \</span><br><span class="line">  -DCMAKE_C_COMPILER=icc -DCMAKE_CXX_COMPILER=icpc \</span><br><span class="line">  -DGMX_DOUBLE=on \</span><br><span class="line">  -DGMX_FFT_LIBRARY=fftw3 \</span><br><span class="line">  -DFFTW_LIBRARY=<span class="string">&quot;<span class="variable">$HOME</span>/fftw/lib/libfftw3.a&quot;</span> \</span><br><span class="line">  -DFFTW_INCLUDE_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/fftw/include/&quot;</span>  \</span><br><span class="line">  -DGMX_MPI=on \</span><br><span class="line">  -DGMX_GPU=off \</span><br><span class="line">  2&gt;&amp;1 | tee cm.log</span><br><span class="line">make -j12 2&gt;&amp;1 | tee m.log</span><br><span class="line">make install 2&gt;&amp;1 | tee mi.log</span><br></pre></td></tr></table></figure><h2 id="编译GPU版本"><a href="#编译GPU版本" class="headerlink" title="编译GPU版本"></a>编译GPU版本</h2><p>在执行cmake的时候，修改一下参数，增加一个参数即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf gromacs-5.1.4.tar.gz</span><br><span class="line"><span class="built_in">cd</span> gromacs-5.1.4 </span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/software/gromacs-5.1.4 \</span><br><span class="line">  -DCMAKE_C_COMPILER=icc -DCMAKE_CXX_COMPILER=icpc \</span><br><span class="line">  -DGMX_DOUBLE=off \</span><br><span class="line">  -DGMX_FFT_LIBRARY=fftw3 \</span><br><span class="line">  -DFFTW_LIBRARY=<span class="string">&quot;<span class="variable">$HOME</span>/fftw/lib/libfftw3.a&quot;</span> \</span><br><span class="line">  -DFFTW_INCLUDE_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/fftw/include/&quot;</span>  \</span><br><span class="line">  -DGMX_MPI=on \</span><br><span class="line">  -DGMX_GPU=on \</span><br><span class="line">  -DCUDA_TOOLKIT_ROOT_DIR=<span class="variable">$HOME</span>/software/cuda \</span><br><span class="line">   2&gt;&amp;1 | tee cm.log</span><br><span class="line">make -j12 2&gt;&amp;1 | tee m.log</span><br><span class="line">make install 2&gt;&amp;1 | tee mi.log</span><br></pre></td></tr></table></figure><h2 id="编译带plumed的版本"><a href="#编译带plumed的版本" class="headerlink" title="编译带plumed的版本"></a>编译带plumed的版本</h2><p>PLUMED 是分子系统中自由能计算的开源库，与一些最流行的分子动力学引擎一起工作。可以使用诸如元动力学，伞形采样和基于 Jarzynski 方程的转向 MD 之类的现有技术来执行自由能计算作为许多次序参数的函数，特别关注生物学问题。</p><p>官网地址：<a href="http://www.plumed.org/">传送门</a>。</p><p>编译安装方法如下：</p><h3 id="配置编译环境"><a href="#配置编译环境" class="headerlink" title="配置编译环境"></a>配置编译环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置编译c/c++的环境</span></span><br><span class="line"><span class="built_in">source</span> /opt/intel/composer_xe_2013.0.079/bin/iccvars.sh intel64</span><br><span class="line"><span class="comment"># 设置mpi编译环境  </span></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/mpi-intel2013/bin:<span class="variable">$PATH</span> </span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/mpi-intel2013/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><h3 id="编译plumed"><a href="#编译plumed" class="headerlink" title="编译plumed"></a>编译plumed</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf plumed2-2.3.0-tar.gz</span><br><span class="line"><span class="built_in">cd</span> plumed2-2.3.0</span><br><span class="line">time CC=icc FC=ifort ./configure \</span><br><span class="line">--prefix=<span class="variable">$HOME</span>/software/plumed2/2.3.0-icc13-mpich3 \</span><br><span class="line">2&gt;&amp;1 | tee c.log</span><br><span class="line"><span class="comment"># real 3m18.979s</span></span><br><span class="line">time make -j 12 2&gt;&amp;1 | tee m.log</span><br><span class="line"><span class="comment"># real 17m9.607s</span></span><br><span class="line">time make install 2&gt;&amp;1| tee mi.log</span><br></pre></td></tr></table></figure><h3 id="设置运行环境"><a href="#设置运行环境" class="headerlink" title="设置运行环境"></a>设置运行环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PLUMED2_HOME=<span class="variable">$HOME</span>/software/plumed2/2.3.0-icc13-mpich3</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PLUMED2_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$PLUMED2_HOME</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf gromacs-5.1.4.tar.gz</span><br><span class="line"><span class="built_in">cd</span> gromacs-5.1.4 </span><br></pre></td></tr></table></figure><h3 id="打plumed的patch"><a href="#打plumed的patch" class="headerlink" title="打plumed的patch"></a>打plumed的patch</h3><p>输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plumed patch -p</span><br></pre></td></tr></table></figure><p>然后依据gromacs的版本选择编号，gromacs-5.1.4选择5）即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PLUMED patching tool</span><br><span class="line"></span><br><span class="line">1) amber14    4) gromacs-5.0.77) namd-2.8</span><br><span class="line">2) gromacs-2016.1   5) gromacs-5.1.48) namd-2.9</span><br><span class="line">3) gromacs-4.5.7    6) lammps-6Apr139) qespresso-5.0.2</span><br><span class="line"></span><br><span class="line">Choose the best matching code/version:5</span><br><span class="line">MD engine: gromacs-5.1.4</span><br><span class="line">PLUMED location: <span class="variable">$HOME</span>/software/plumed2/2.3.0-icc13-mpich3.0.4/lib/plumed</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">patching file ./src/programs/mdrun/mdrun.cpp</span><br><span class="line">patching file ./src/programs/mdrun/repl_ex.cpp</span><br><span class="line">patching file ./src/programs/mdrun/repl_ex.h</span><br><span class="line">patching file ./src/programs/mdrun/runner.cpp</span><br><span class="line"></span><br><span class="line">PLUMED is compiled with MPI support so you can configure gromacs-5.1.4 with MPI</span><br></pre></td></tr></table></figure><h3 id="编译gromacs"><a href="#编译gromacs" class="headerlink" title="编译gromacs"></a>编译gromacs</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/software/gromacs-5.1.4-plumed2-2.3.0-icc13-mpich3.0.4 \</span><br><span class="line">  -DCMAKE_C_COMPILER=icc -DCMAKE_CXX_COMPILER=icpc \</span><br><span class="line">  -DGMX_DOUBLE=off \</span><br><span class="line">  -DGMX_OPENMP=ON \</span><br><span class="line">  -DGMX_FFT_LIBRARY=fftw3 \</span><br><span class="line">  -DFFTWF_LIBRARY=<span class="string">&quot;<span class="variable">$HOME</span>/fftw/lib/libfftw3f.a&quot;</span> \</span><br><span class="line">  -DFFTWF_INCLUDE_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/fftw/include/&quot;</span>  \</span><br><span class="line">  -DGMX_MPI=on \</span><br><span class="line">  -DGMX_GPU=off \</span><br><span class="line">  2&gt;&amp;1 | tee cm.log</span><br><span class="line">make -j12 2&gt;&amp;1 | tee m.log</span><br><span class="line">make install 2&gt;&amp;1 | tee mi.log</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-DCMAKE_INSTALL_PREFIX</td><td>安装目录</td></tr><tr><td>-DCMAKE_C_COMPILER=icc</td><td>使用 icc 编译 c</td></tr><tr><td>-DCMAKE_CXX_COMPILER=icpc</td><td>使用 icpc 编译 cpp</td></tr><tr><td>-DGMX_DOUBLE=off</td><td>关闭double，编译单精度版本</td></tr><tr><td>-DGMX_OPENMP=ON</td><td>开启openmp的支持</td></tr><tr><td>-DGMX_FFT_LIBRARY=fftw3</td><td>使用 fftw3</td></tr><tr><td>-DFFTWF_LIBRARY=”$HOME/fftw/lib/libfftw3f.a”</td><td>fftw库,请改为自己的</td></tr><tr><td>-DFFTWF_INCLUDE_DIR=”$HOME/fftw334/include/“</td><td>fftw的头文件目录,请改为自己的</td></tr><tr><td>-DGMX_MPI=on</td><td>开启 MPI 支持</td></tr><tr><td>-DGMX_GPU=off</td><td>关闭 GPU 支持</td></tr></tbody></table><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> <span class="variable">$HOME</span>/software/gromacs-5.1.4/bin/GMXRC</span><br></pre></td></tr></table></figure><p>执行这个脚本，就可以配置好环境了。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>下载一个官方算例<br><a href="ftp://ftp.gromacs.org/pub/benchmarks/ADH_bench_systems.tar.gz">ftp://ftp.gromacs.org/pub/benchmarks/ADH_bench_systems.tar.gz</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar xvf ADH_bench_systems.tar.gz <span class="comment"># 解压缩</span></span><br><span class="line"><span class="built_in">cd</span> adh_cubic <span class="comment"># 选择一个算例</span></span><br><span class="line">grompp_mpi -f rf_verlet.mdp <span class="comment"># 预处理</span></span><br><span class="line">yhrun -n24 -pdebug mdrun_mpi <span class="comment"># 并行执行mpi版</span></span><br><span class="line">yhrun -n1 -pdebug mdrun_mpi <span class="comment"># 执行gpu版</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 应用软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gromacs </tag>
            
            <tag> plumed </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
